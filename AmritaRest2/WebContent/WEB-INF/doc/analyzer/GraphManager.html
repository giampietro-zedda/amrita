<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_13) on Sat Dec 15 14:25:28 CET 2012 -->
<TITLE>
GraphManager
</TITLE>

<META NAME="date" CONTENT="2012-12-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GraphManager";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphManager.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../analyzer/GraphArcObjects.html" title="class in analyzer"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?analyzer/GraphManager.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphManager.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
analyzer</FONT>
<BR>
Class GraphManager</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>analyzer.GraphManager</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD>java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GraphManager</B><DT>extends java.lang.Object<DT>implements java.io.Serializable</DL>
</PRE>

<P>
copyright (c) 2009-2011 e-Amrita - Ing. Giampietro Zedda   Turin (ITALY)
 
 <h1>
 GraphManager
 </h1>
 <p>
 Questa classe modella un generico grafo di codice di programma, implementato con liste di adiacenza, 
 che viene popolato in fase di analisi preliminare del singolo sorgente.<br>
 Il grafo è progettato in modo generalizzato, svincolato dalla natura dei nodi e dalla struttura degli archi.  
 I nodi del grafo rappresentano punti rilevanti dal punto di vista logico (richiami a routines, copy etc.)  
 oppure dal punto di vista della struttura logica del programma (IF, CASE, etc.) 
 Il grafo viene utilizzato per descrivere la Procedure Division del COBOL ma può  
 essere utilizzato per qualsiasi linguaggio o le relazioni fra oggetti qualsiasi. 
 Sono implementati metodi per memorizzare/interrogare il grafo e per ottenere specifici  
 path di esecuzione in modo bidirezionale ed eventuali nodi sconnessi. 
 Il grafo può riferirsi a un programma, a un copy di codice richiamato in un programma  
 oppure a una routine interna a un programma. I metodi di analisi del grafo effettuano le ricerce  
 ricorsivamente in tutti i grafi da esplodere.<br>
 I nodi e gli archi presenti nel grafo vengono classificati e numerati a partire da zero. 
 Questa informazione è disponibile anche tramite il metodo toString. <br>
 <p>
 I tipi di nodi previsti rappresentano sono assimilabili a categorie di istruzioni che governano <br>
 il flusso procedurale di un generico programma (si veda <A HREF="../enums/EnumGraphNodeType.html" title="enum in enums"><CODE>EnumGraphNodeType</CODE></A>. <br>
 Concettualmente da un nodo, che può essere radice, possono partire 1 solo arco (NODE_GRAPH_BRANCH_INTERNAL), due archi (NODE_IF_THEN), <br>
 oppure 2 o più archi (NODE_CASE_STRUCTURE). Se un nodo viene esploso da un altro grafo il tipo sarà CALL_EMBEDDED.
 <Ul>
 <Li> NODE_ROOT
 <Li> NODE_JOIN 
 <Li> NODE_IF_THEN
 <Li> NODE_CASE_STRUCTURE
 <Li> NODE_CALL_INTERNAL
 <Li> NODE_GRAPH_BRANCH_INTERNAL
 </Ul>
 
 <h3> NODE_ROOT </h3>
 Rappresenta il nodo radice, dove inizia la parte procedurale del programma
 analizzato. Nel caso del Cobol viene associato all'istruzione <b>PROCEDURE DIVISION USING</b>. 
 A questo nodo vengono associati eventuali parametri di ingresso. 
 Da questo nodo può partire un solo arco (si veda <A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>
 
 <h3> NODE_JOIN </h3>
 Rappresenta un nodo a cui non corrisponde nessuna istruzione eseguibile, al quale si 
 può arrivare da uno o più nodi e dal quale parte un solo arco o nessuno. <br>
 Nel caso del Cobol e in genere per tutti i linguaggi, viene associato a una <b>LABEL</b>.
 Il processo di analisi del programma, nella generazione del grafo, potrebbe
 inserire dei nodi JOIN, da considerare label fittizie non presenti nel
 sorgente originale, per gestire strutture <b>IF-THEN-ELSE</b> e <b>CASE-WHEN</b>.<br>
 Da questo nodo può partire un solo arco o nessun arco (fine grafo) (si veda <A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>).
 
 <h3> NODE_IF_THEN </h3>
 Rappresenta un nodo di condizione a due vie. Nel caso del Cobol e in genere per tutti i linguaggi, 
 viene associato a una <b>IF THEN ELSE</b>.
 Da questo nodo può partire un solo arco, nel caso di IF THEN, oppure  
 2 archi, nel caso di IF THEN ELSE.
 
 <h3> NODE_CASE_STRUCTURE </h3>
 Rappresenta un nodo di condizione multipla a più vie. Nel caso del Cobol  
 viene associato a una <b>EVALUATE WHEN</b>. 
 Da questo nodo può partire un arco per ogni condizione di WHEN.(si veda <A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>
 
 <h3> NODE_CALL_INTERNAL </h3>
 Rappresenta un nodo che indica l'esplosione di un'altro grafo interno a quello corrente, descrivente  
 una procedura o una sezione di codice del programma. 
 Nel caso del Cobol questo nodo viene associato a una <b>PERFORM</b> a una <b>SECTION</b>  
 oppure a una <b>PERFORM</b> LabStart <b>THRU</b> LabEnd  
 Da questo nodo può partire un solo arco .(si veda <A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>)

 <h3> NODE_GRAPH_BRANCH_INTERNAL </h3>
 Rappresenta un nodo che indica uno o più salti incondizionati ad altri punti del programma,  
 modellati dal tipo nodo JOIN. 
 Nel caso del Cobol questo nodo viene associato a una <b>GOTO DEPENDING ON</b> a una serie <b>LABEL</b>  
 oppure a una specifica <b>GOTO</b> Label  
 Da questo nodo possono partire uno o più archi.(si veda <A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>)
<p>

 <h3>Funzionalità gestite</h3>
 <p>
 GraphManager è progettato per ottenere la massima velocità di esecuzione  e la completa flessibilità di utilizzo.
 In particolare sono gestite le seguenti funzionalità:
 
 <Ul>
 <Li> Caricamento nodi e archi 
 <Li> Restituzione possibili cammini di esecuzione fra nodo partenza e nodo arrivo
 <Li> Scelta da chiamante se utilizzare metodo di visita Forward o Backward
 <Li> Verifica se grafo connesso
 <Li> Gestione serializzazione/deserializzazione grafo
 <Li> Restituzione path con ndi da espandere o espansi
 <Li> Restituzione grafi interni non referenziati
 <Li> Ottimizzazione con valori di allocazione dinamici da .config
 <Li> Ottimizzazione con precaricamento path estratti e cache in Map/TreeMap
 <Li> Calcolo indice di complessità ciclomatica
 </Ul>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>2/11/2009</DD>
<DT><B>Version:</B></DT>
  <DD>1.0.0</DD>
<DT><B>Author:</B></DT>
  <DD>Giampietro Zedda</DD>
<DT><B>See Also:</B><DD><A HREF="../analyzer/GraphManager.html" title="class in analyzer"><CODE>GraphManager</CODE></A>, 
<A HREF="../analyzer/GraphArc.html" title="class in analyzer"><CODE>GraphArc</CODE></A>, 
<A HREF="../analyzer/GraphNode.html" title="class in analyzer"><CODE>GraphNode</CODE></A>, 
<A HREF="../analyzer/Instruction.html" title="class in analyzer"><CODE>Instruction</CODE></A>, 
<A HREF="../enums/EnumGraphNodeType.html" title="enum in enums"><CODE>EnumGraphNodeType</CODE></A>, 
<A HREF="../serialized-form.html#analyzer.GraphManager">Serialized Form</A></DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#GraphManager(analyzer.SystemDefaults, java.lang.String, enums.EnumGraphType, analyzer.GraphManager)">GraphManager</A></B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
             java.lang.String&nbsp;idGraph,
             <A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A>&nbsp;enGraphType,
             <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;mainGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Costruttore con numero di nodi da gestire di default</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#GraphManager(analyzer.SystemDefaults, java.lang.String, int, enums.EnumGraphType, analyzer.GraphManager)">GraphManager</A></B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
             java.lang.String&nbsp;idGraph,
             int&nbsp;NodeInitSize,
             <A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A>&nbsp;enGraphType,
             <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;mainGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Costruttore con numero nodi da gestire fornito</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#addNode(analyzer.GraphNode)">addNode</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;NodeToAdd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Inserimento nodo nel grafo principale o nel sottografo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#addSubGraph(java.lang.String, analyzer.GraphManager)">addSubGraph</A></B>(java.lang.String&nbsp;idSubGraph,
            <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Inserimento di un sottografo interno esplosione di un nodo NODE_CALL_INTERNAL
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#arcChild(analyzer.GraphNode, int)">arcChild</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeFather,
         int&nbsp;nArc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'arco uscente da un nodo padre, zero based</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#arcParent(analyzer.GraphNode, int)">arcParent</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeFather,
          int&nbsp;nArc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'arco entrante in un nodo figlio, zero based</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#arcs()">arcs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti gli archi definiti nel grafo o nel sottografo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#arcsAll()">arcsAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti gli archi definiti nel grafo principale
 e nei sottografi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#childFirst(analyzer.GraphNode)">childFirst</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il primo nodo figlio</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#childNext(analyzer.GraphNode)">childNext</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il successivo nodo figlio.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#childNodes(analyzer.GraphNode)">childNodes</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array di nodi figli</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#clearCacheSubGraphExpanded()">clearCacheSubGraphExpanded</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Svuotamento cache path espansi</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#clearCacheSubGraphInternal()">clearCacheSubGraphInternal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Svuotamento cache path completi di ogni sottografo</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#clearCacheSubGraphToExpand()">clearCacheSubGraphToExpand</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Svuotamento cache path da espandere</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#clearCountVisit()">clearCountVisit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clearCountVisit
 
 Azzera i contatori di visita di archi e nodi presenti nel grafo corrente e 
 nei sottografi richiamati.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#connectNodes(analyzer.GraphNode, analyzer.GraphNode, analyzer.GraphArc)">connectNodes</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeFather,
             <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeChild,
             <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>&nbsp;GraphArc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;connectNodes
 
 Connessione di due nodi del grafo o sottografo con un arco.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#debugShowPath(analyzer.GraphPath)">debugShowPath</A></B>(<A HREF="../analyzer/GraphPath.html" title="class in analyzer">GraphPath</A>&nbsp;path)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#disablePaths(analyzer.GraphNode, analyzer.GraphNode, analyzer.GraphArc[], java.util.Set)">disablePaths</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeStart,
             <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeTo,
             <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]&nbsp;ar_arcsInPath,
             java.util.Set&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt;&nbsp;set_subGraphWithArcInSetChains)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disabilitazione paths fra due nodi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#enableArcs()">enableArcs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abilita tutti gli archi presenti nel grafo corrente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#enableArcsAll()">enableArcsAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abilita tutti gli archi presenti nel grafo corrente e 
 nei sottografi richiamati.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getFromXML(java.lang.String, java.lang.String)">getFromXML</A></B>(java.lang.String&nbsp;fileName,
           java.lang.String&nbsp;pathToWrite)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Il grafo viene popolato a partire da una rappresentazione
 XML memorizzata su disco.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getGraphType()">getGraphType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Restituisce il tipo di grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getIdGraph()">getIdGraph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'identificativo completo alfanumerico del grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getIdGraphShort()">getIdGraphShort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'identificativo breve alfanumerico del grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/LoggerFacade.html" title="class in analyzer">LoggerFacade</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getLoggerFacade()">getLoggerFacade</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il reference al gestore di log</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getMaxPathsSize()">getMaxPathsSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getMaxPathsSize
 
 Restituisce il numero massimo di path da elaborare.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getSubGraph(java.lang.String)">getSubGraph</A></B>(java.lang.String&nbsp;idSubGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Recupero di un sottografo interno esplosione di un nodo NODE_CALL_INTERNAL</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#getSubGraphOwnerIndex(analyzer.GraphNode)">getSubGraphOwnerIndex</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero del nodo (l'indice) nel sottografo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isCachingSubGraphExpanded()">isCachingSubGraphExpanded</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce True se caching abilitato dei path estratti con i sottografi espansi,</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isCachingSubGraphToExpand()">isCachingSubGraphToExpand</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce True se caching abilitato dei path estratti con i sottografi ancora da espandere,
 False se i path contengono solo il richiamo al sottografo, i cui nodi visitati
 non vengono espansi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isNodeChild(analyzer.GraphNode, analyzer.GraphNode)">isNodeChild</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeFather,
            <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeChild)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il nodo è un figlio di quello padre fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isPathToGenerate()">isPathToGenerate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True indica che devono essere generati i path della visita al grafo</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isStopToFirstPath()">isStopToFirstPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;True indica che il processo di visita si ferma al primo path incontrato</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isSubGraphDefined(java.lang.String)">isSubGraphDefined</A></B>(java.lang.String&nbsp;idSubGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il sottografo è definito, false altrimenti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isSubGraphToExpandInPath()">isSubGraphToExpandInPath</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indica che vengono restituiti i path fra due nodi, espandendo 
 in modo ricorsivo tutti i sottografi richiamati</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isSubGraphWithArcSet(analyzer.GraphManager, java.util.Set)">isSubGraphWithArcSet</A></B>(<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraphCalled,
                     java.util.Set&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt;&nbsp;set_subGraphWithArcInSetChains)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il sottografo fornito o qualsiasi altro
 sottografo chiamato a qualsiasi livello di nesting, è fra quelli
 con archi in catene di trasformazione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#isThereConnection(analyzer.GraphNode, analyzer.GraphNode)">isThereConnection</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeStart,
                  <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;isThereConnection
 
 Restituisce true se i due nodi sono connessi da un qualche cammino.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#node(int)">node</A></B>(int&nbsp;nNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un nodo attraverso il suo id numerico progressivo di caricamento.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodeEnd()">nodeEnd</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'ultimo nodo definito nel grafo, che deve essere NODE_END.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodeIndex(analyzer.GraphNode)">nodeIndex</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'indice del nodo che corrisponde alla sequenza con cui è stato
 inserito nel grafo: 0 significa il primo nodo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodeIndexOnMainGraph(analyzer.GraphNode)">nodeIndexOnMainGraph</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'indice del nodo che corrisponde alla sequenza con cui è stato
 inserito nel grafo: 0 significa il primo nodo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodeLastInserted()">nodeLastInserted</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'ultimo nodo inserito nel grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodes()">nodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti i nodi definiti ne grafo corrente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodesAll()">nodesAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti i nodi definiti nel grafo corrente
 e in tutti i suoi sottografi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodesCallingSubGraph(java.lang.String)">nodesCallingSubGraph</A></B>(java.lang.String&nbsp;idSubGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituise tutti i nodi NODE_CALL_INTERNAL</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodesStop()">nodesStop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti i nodi di stop del grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#nodeStart()">nodeStart</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nodo di inizio del grafo</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#optimizeGraph()">optimizeGraph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Metodo da rihiamare alla fine del popolamento dei nodi, archi, delle connessioni
 e del caricamento degli eventuali sottografi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#parentFirst(analyzer.GraphNode)">parentFirst</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il primo nodo genitore</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#parentNext(analyzer.GraphNode)">parentNext</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il successivo nodo genitore</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#parentNodes(analyzer.GraphNode)">parentNodes</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con tutti i nodi adiacenti gentitori di quello fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphPath.html" title="class in analyzer">GraphPath</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#paths(analyzer.GraphNode, analyzer.GraphNode, enums.EnumGraphTypeVisit, enums.EnumPathCaching, enums.EnumPathDeep)">paths</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeStart,
      <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeTo,
      <A HREF="../enums/EnumGraphTypeVisit.html" title="enum in enums">EnumGraphTypeVisit</A>&nbsp;typeVisit,
      <A HREF="../enums/EnumPathCaching.html" title="enum in enums">EnumPathCaching</A>&nbsp;typePathCaching,
      <A HREF="../enums/EnumPathDeep.html" title="enum in enums">EnumPathDeep</A>&nbsp;typePathDeep)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;paths
 
 Restituisce tutti i possibili path fra i due nodi in input con algoritmo da utilizzare Backward o Forward
 fornito come parametro in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#serialize(java.lang.String, java.lang.String, java.lang.String)">serialize</A></B>(java.lang.String&nbsp;pathOutput,
          java.lang.String&nbsp;idObject,
          java.lang.String&nbsp;filePrefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Il grafo viene memorizzato su disco in formato serializzato.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setCachingSubGraphExpanded(boolean)">setCachingSubGraphExpanded</A></B>(boolean&nbsp;bCachingPathSubGraphExpanded)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abilita o disabilita il caching  dei path estratti con i sottografi espansi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setCachingSubGraphToExpand(boolean)">setCachingSubGraphToExpand</A></B>(boolean&nbsp;bCachingPathSubGraphToExpand)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abilita o disabilita il caching  dei path estratti con i sottografi espansi,
 In caso di disabilitazione i path contengono solo il richiamo al sottografo, i cui nodi visitati
 non vengono espansi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setIdGraph(java.lang.String)">setIdGraph</A></B>(java.lang.String&nbsp;idGraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta l'identificativo completo alfanumerico del grafo<br>
 
 Nel caso di grafo associato a procedura interna cobol, il nome
 del grafo è qualificato dal suo richiamo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setIdGraphShort(java.lang.String)">setIdGraphShort</A></B>(java.lang.String&nbsp;idGraphShort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta l'identificativo breve alfanumerico del grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setLoggerFacade(analyzer.LoggerFacade)">setLoggerFacade</A></B>(<A HREF="../analyzer/LoggerFacade.html" title="class in analyzer">LoggerFacade</A>&nbsp;loggerFacade)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il reference al gestore di log</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setMaxPathsSize(int)">setMaxPathsSize</A></B>(int&nbsp;maxPathsSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setMaxPathsSize
 
 Imposta il numero massimo di path da elaborare.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setStopToFirstPath(boolean)">setStopToFirstPath</A></B>(boolean&nbsp;stopToFirstPath)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se il processo di visita si ferma al primo path incontrato</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#setSubGraphOwner(analyzer.GraphNode, analyzer.GraphManager)">setSubGraphOwner</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode,
                 <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraphOwner)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#sizeNodes()">sizeNodes</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di nodi inseriti nel grafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#sizeNodesChild(analyzer.GraphNode)">sizeNodesChild</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di nodi figli</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#sizeNodesParent(analyzer.GraphNode)">sizeNodesParent</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di nodi genitori</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#subGraphNames()">subGraphNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array con i nomi dei sottografi definiti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#subGraphOwner(analyzer.GraphNode)">subGraphOwner</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il sottografo al quale il nodo si riferisce</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#subGraphs()">subGraphs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un array list con i sottografi richiamati direttamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#subGraphUnreferenced()">subGraphUnreferenced</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i sottografi interni non referenziati in nessun nodo (Codice morto)
 Questo metodo deve essere richiamato DOPO l'ottimizzazione (metodo optimize)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#unSerialize(java.lang.String, java.lang.String, java.lang.String)">unSerialize</A></B>(java.lang.String&nbsp;pathInput,
            java.lang.String&nbsp;idObject,
            java.lang.String&nbsp;filePrefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Il grafo viene popolato a partire dall'ouput serializzato
 memorizzata su disco.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/GraphManager.html#visit(analyzer.GraphNode, analyzer.GraphNode, enums.EnumGraphTypeVisit)">visit</A></B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeStart,
      <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeTo,
      <A HREF="../enums/EnumGraphTypeVisit.html" title="enum in enums">EnumGraphTypeVisit</A>&nbsp;typeVisit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;visit
 
 Effettua la visita completa fra il nodo di partenza e quello fornito in input.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GraphManager(analyzer.SystemDefaults, java.lang.String, enums.EnumGraphType, analyzer.GraphManager)"><!-- --></A><H3>
GraphManager</H3>
<PRE>
public <B>GraphManager</B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
                    java.lang.String&nbsp;idGraph,
                    <A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A>&nbsp;enGraphType,
                    <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;mainGraph)</PRE>
<DL>
<DD>Costruttore con numero di nodi da gestire di default
<P>
</DL>
<HR>

<A NAME="GraphManager(analyzer.SystemDefaults, java.lang.String, int, enums.EnumGraphType, analyzer.GraphManager)"><!-- --></A><H3>
GraphManager</H3>
<PRE>
public <B>GraphManager</B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
                    java.lang.String&nbsp;idGraph,
                    int&nbsp;NodeInitSize,
                    <A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A>&nbsp;enGraphType,
                    <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;mainGraph)</PRE>
<DL>
<DD>Costruttore con numero nodi da gestire fornito
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - NodeIntSize</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getIdGraph()"><!-- --></A><H3>
getIdGraph</H3>
<PRE>
public java.lang.String <B>getIdGraph</B>()</PRE>
<DL>
<DD>Restituisce l'identificativo completo alfanumerico del grafo.<br>
 <p>
 Nel caso di grafo associato a procedura interna cobol, il nome
 del grafo è qualificato dal suo richiamo.<br>
 Se la perform non include l'opzione thru, il nome del grafo coincide
 con il nome della procedura interna, sia essa una Section o una label.<br>
 Se invece la perform include l'opzione thru, allora l'dentificativo del
 grafo è formato da nomeSectionOlabel:labelThru.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the idGraph</DL>
</DD>
</DL>
<HR>

<A NAME="setIdGraph(java.lang.String)"><!-- --></A><H3>
setIdGraph</H3>
<PRE>
public void <B>setIdGraph</B>(java.lang.String&nbsp;idGraph)</PRE>
<DL>
<DD>Imposta l'identificativo completo alfanumerico del grafo<br>
 <p>
 Nel caso di grafo associato a procedura interna cobol, il nome
 del grafo è qualificato dal suo richiamo.<br>
 Se la perform non include l'opzione thru, il nome del grafo coincide
 con il nome della procedura interna, sia essa una Section o una label.<br>
 Se invece la perform include l'opzione thru, allora l'dentificativo del
 grafo è formato da nomeSectionOlabel:labelThru.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>idGraph</CODE> - the idGraph to set</DL>
</DD>
</DL>
<HR>

<A NAME="getIdGraphShort()"><!-- --></A><H3>
getIdGraphShort</H3>
<PRE>
public java.lang.String <B>getIdGraphShort</B>()</PRE>
<DL>
<DD>Restituisce l'identificativo breve alfanumerico del grafo.<br>
 <p>
 Nel caso di grafo associato a procedura interna cobol, il nome
 del grafo è qualificato dal suo richiamo.<br>
 Se la perform non include l'opzione thru, il nome del grafo coincide
 con il nome della procedura interna, sia essa una Section o una label.<br>
 Se invece la perform include l'opzione thru, allora l'dentificativo del
 grafo è formato da nomeSectionOlabel:labelThru.<br>
 <p>
 Questo metodo restituisce solo il nome della section o della label,
 indipendentemente dal tipo di richiamo.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the idGraphShort</DL>
</DD>
</DL>
<HR>

<A NAME="setIdGraphShort(java.lang.String)"><!-- --></A><H3>
setIdGraphShort</H3>
<PRE>
public void <B>setIdGraphShort</B>(java.lang.String&nbsp;idGraphShort)</PRE>
<DL>
<DD>Imposta l'identificativo breve alfanumerico del grafo.<br>
 <p>
 Nel caso di grafo associato a procedura interna cobol, il nome
 del grafo è qualificato dal suo richiamo.<br>
 Se la perform non include l'opzione thru, il nome del grafo coincide
 con il nome della procedura interna, sia essa una Section o una label.<br>
 Se invece la perform include l'opzione thru, allora l'dentificativo del
 grafo è formato da nomeSectionOlabel:labelThru.<br>
 <p>
 Questo metodo restituisce solo il nome della section o della label,
 indipendentemente dal tipo di richiamo.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>idGraphShort</CODE> - the idGraphShort to set</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphType()"><!-- --></A><H3>
getGraphType</H3>
<PRE>
public <A HREF="../enums/EnumGraphType.html" title="enum in enums">EnumGraphType</A> <B>getGraphType</B>()</PRE>
<DL>
<DD><h4>
 Restituisce il tipo di grafo.<br>
 </h4>
 <p>
 Si tratta del Main Graph, ovvero della mainline del programma,
 se il grafo rappresenta un programma Cobol, oppure di un sottografo,
 che in Cobol è la singola Section o procedura richiamata con Perform.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the enGraphType</DL>
</DD>
</DL>
<HR>

<A NAME="addNode(analyzer.GraphNode)"><!-- --></A><H3>
addNode</H3>
<PRE>
public int <B>addNode</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;NodeToAdd)</PRE>
<DL>
<DD><h4>
 Inserimento nodo nel grafo principale o nel sottografo.<br>
 </h4>
 <p>
 Il nodo risulta inizialmente sconnesso.  
 Il primo nodo con index=0 è il nodo ROOT.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - NodeToAdd
<DT><B>Returns:</B><DD>int Identificatore numerico nodo
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionGraphAddNode.html" title="class in exception">ExceptionGraphAddNode</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="addSubGraph(java.lang.String, analyzer.GraphManager)"><!-- --></A><H3>
addSubGraph</H3>
<PRE>
public <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A> <B>addSubGraph</B>(java.lang.String&nbsp;idSubGraph,
                                <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraph)</PRE>
<DL>
<DD><h4>
 Inserimento di un sottografo interno esplosione di un nodo NODE_CALL_INTERNAL
 </h4>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - idGraphInternal<DD><CODE>GraphManager</CODE> - graphInternal
<DT><B>Returns:</B><DD>GraphManager graphInternal</DL>
</DD>
</DL>
<HR>

<A NAME="getSubGraph(java.lang.String)"><!-- --></A><H3>
getSubGraph</H3>
<PRE>
public <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A> <B>getSubGraph</B>(java.lang.String&nbsp;idSubGraph)</PRE>
<DL>
<DD>Recupero di un sottografo interno esplosione di un nodo NODE_CALL_INTERNAL
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - idGraphInternal<DD><CODE>GraphManager</CODE> - graphInternal
<DT><B>Returns:</B><DD>GraphManager graphInternal</DL>
</DD>
</DL>
<HR>

<A NAME="isSubGraphDefined(java.lang.String)"><!-- --></A><H3>
isSubGraphDefined</H3>
<PRE>
public boolean <B>isSubGraphDefined</B>(java.lang.String&nbsp;idSubGraph)</PRE>
<DL>
<DD>Restituisce true se il sottografo è definito, false altrimenti.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - idGraphInternal
<DT><B>Returns:</B><DD>boolean true se esiste</DL>
</DD>
</DL>
<HR>

<A NAME="isSubGraphWithArcSet(analyzer.GraphManager, java.util.Set)"><!-- --></A><H3>
isSubGraphWithArcSet</H3>
<PRE>
public boolean <B>isSubGraphWithArcSet</B>(<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraphCalled,
                                    java.util.Set&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt;&nbsp;set_subGraphWithArcInSetChains)</PRE>
<DL>
<DD>Restituisce true se il sottografo fornito o qualsiasi altro
 sottografo chiamato a qualsiasi livello di nesting, è fra quelli
 con archi in catene di trasformazione.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subGraphNames()"><!-- --></A><H3>
subGraphNames</H3>
<PRE>
public java.lang.String[] <B>subGraphNames</B>()</PRE>
<DL>
<DD>Restituisce un array con i nomi dei sottografi definiti.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subGraphs()"><!-- --></A><H3>
subGraphs</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt; <B>subGraphs</B>()</PRE>
<DL>
<DD>Restituisce un array list con i sottografi richiamati direttamente.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodesCallingSubGraph(java.lang.String)"><!-- --></A><H3>
nodesCallingSubGraph</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>nodesCallingSubGraph</B>(java.lang.String&nbsp;idSubGraph)</PRE>
<DL>
<DD>Restituise tutti i nodi NODE_CALL_INTERNAL
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - idGraphInternal<DD><CODE>GraphManager</CODE> - graphInternal
<DT><B>Returns:</B><DD>GraphManager graphInternal</DL>
</DD>
</DL>
<HR>

<A NAME="subGraphUnreferenced()"><!-- --></A><H3>
subGraphUnreferenced</H3>
<PRE>
public java.lang.String[] <B>subGraphUnreferenced</B>()</PRE>
<DL>
<DD>Restituisce i sottografi interni non referenziati in nessun nodo (Codice morto)
 Questo metodo deve essere richiamato DOPO l'ottimizzazione (metodo optimize)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphManager graphInternal[]</DL>
</DD>
</DL>
<HR>

<A NAME="connectNodes(analyzer.GraphNode, analyzer.GraphNode, analyzer.GraphArc)"><!-- --></A><H3>
connectNodes</H3>
<PRE>
public boolean <B>connectNodes</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeFather,
                            <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeChild,
                            <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>&nbsp;GraphArc)
                     throws <A HREF="../exception/ExceptionGraphAddNode.html" title="class in exception">ExceptionGraphAddNode</A>,
                            <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD><h1>connectNodes</h1>
 <h4>
 Connessione di due nodi del grafo o sottografo con un arco.
 </h4>
 Il metodo connette due nodi con un arco fornito come parametro.<br>
 L'arco può contenere come oggetto un ArrayList con i numeri di 
 istruzione o null.<br>
 Nel caricamento dell'arco viene assegnato un numero identificativo
 univoco dell'arco nel grafo principale e, se l'oggetto corrente è
 un sottografo, anche un numero identificativo univoco nel sottografo.<br>
 Se l'arco appartiene al grafo principale i due numeri identificativi
 coincidono.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - NodeFather<DD><CODE>GraphNode</CODE> - NodeToAdd<DD><CODE>GraphArc</CODE> - Arc
<DT><B>Returns:</B><DD>boolean status
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionGraphAddNode.html" title="class in exception">ExceptionGraphAddNode</A></CODE>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="setSubGraphOwner(analyzer.GraphNode, analyzer.GraphManager)"><!-- --></A><H3>
setSubGraphOwner</H3>
<PRE>
public void <B>setSubGraphOwner</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode,
                             <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&nbsp;subGraphOwner)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="subGraphOwner(analyzer.GraphNode)"><!-- --></A><H3>
subGraphOwner</H3>
<PRE>
public <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A> <B>subGraphOwner</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</PRE>
<DL>
<DD>Restituisce il sottografo al quale il nodo si riferisce
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphManager sottografo dove il nodo è definito</DL>
</DD>
</DL>
<HR>

<A NAME="getSubGraphOwnerIndex(analyzer.GraphNode)"><!-- --></A><H3>
getSubGraphOwnerIndex</H3>
<PRE>
public java.lang.Integer <B>getSubGraphOwnerIndex</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)</PRE>
<DL>
<DD>Restituisce il numero del nodo (l'indice) nel sottografo.<br>
 <p>
 Il metodo deve essere richiamato dal grafo principale, altrimenti
 restituisce null.<br>
 <p>
 Il metodo ha senso per nodi definiti per un sottografo.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>the subGraphOwnerIndex</DL>
</DD>
</DL>
<HR>

<A NAME="getMaxPathsSize()"><!-- --></A><H3>
getMaxPathsSize</H3>
<PRE>
public int <B>getMaxPathsSize</B>()</PRE>
<DL>
<DD><h1>getMaxPathsSize</h1>
 
 Restituisce il numero massimo di path da elaborare.<br>
 <p>
 A fronte di qualsiasi funzione che produce cammini di esecuzione
 come <strong>paths()</strong>, i paths elaborati sono limitati a
 questo valore.<br>
 Ciò si rende necessario in quanto richieste di esecuzione non
 controllate potrebbero generare facilmente milioni di path mandando
 in crash il sistema.<br>
 Pur essendo le funzioni produzione dei path virtualmente sempre
 eseguibili, sono sufficienti 16 <code>IF</code> in cascata per generare 
 <code>2**16</code> path diversi.<br>
 Nei processi di soluzione delle logiche, sono stati adottati tutta
 una serie di algoritmi e meccanismi, per ridurre la complessità
 del grafo di programma al minimo possibile per l'elaborazione.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the maxPathsSize</DL>
</DD>
</DL>
<HR>

<A NAME="setMaxPathsSize(int)"><!-- --></A><H3>
setMaxPathsSize</H3>
<PRE>
public void <B>setMaxPathsSize</B>(int&nbsp;maxPathsSize)</PRE>
<DL>
<DD><h1>setMaxPathsSize</h1>
 
 Imposta il numero massimo di path da elaborare.<br>
 <p>
 A fronte di qualsiasi funzione che produce cammini di esecuzione
 come <strong>paths()</strong>, i paths elaborati sono limitati a
 questo valore.<br>
 Ciò si rende necessario in quanto richieste di esecuzione non
 controllate potrebbero generare facilmente milioni di path mandando
 in crash il sistema.<br>
 Pur essendo le funzioni produzione dei path virtualmente sempre
 eseguibili, sono sufficienti 16 <code>IF</code> in cascata per generare 
 <code>2**16</code> path diversi.<br>
 Nei processi di soluzione delle logiche, sono stati adottati tutta
 una serie di algoritmi e meccanismi, per ridurre la complessità
 del grafo di programma al minimo possibile per l'elaborazione.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>maxPathsSize</CODE> - the maxPathsSize to set</DL>
</DD>
</DL>
<HR>

<A NAME="node(int)"><!-- --></A><H3>
node</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>node</B>(int&nbsp;nNode)</PRE>
<DL>
<DD>Restituisce un nodo attraverso il suo id numerico progressivo di caricamento.<br>
 <p>
 Se il numero del nodo è out of range, restituisce null.         
 Se il metodo è richiamato sul grafo principale allora
 il numero del nodo deve essere quello assoluto di inserimento.
 Se invece il metodo è richiamato in un sottografo, il numero
 del nodo deve essere quello di inserimento nel sottografo.<br>
 In entrambi i casi viene restituito lo stesso oggetto GraphNode.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numNode
<DT><B>Returns:</B><DD>GraphNode node</DL>
</DD>
</DL>
<HR>

<A NAME="nodeIndex(analyzer.GraphNode)"><!-- --></A><H3>
nodeIndex</H3>
<PRE>
public int <B>nodeIndex</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
              throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce l'indice del nodo che corrisponde alla sequenza con cui è stato
 inserito nel grafo: 0 significa il primo nodo.<br>
 <p>
 Nel caso di nodo appartenente a un sottografo viene restituito l'indice relativo nel sottografo.
 Questo metodo rende trasparente nel processo di visita il grafo principale da un sottografo.
 Il numero del nodo codificato in GraphNode è sempre quello del grafo principale, dove sono definiti
 tutti i nodi, anche quelli dei vari sottografi.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>int indice nodo
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="nodeIndexOnMainGraph(analyzer.GraphNode)"><!-- --></A><H3>
nodeIndexOnMainGraph</H3>
<PRE>
public java.lang.Integer <B>nodeIndexOnMainGraph</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                                       throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce l'indice del nodo che corrisponde alla sequenza con cui è stato
 inserito nel grafo: 0 significa il primo nodo.<br>
 <p>
 Il metodo può essere richiamato sul grafo principale o su un sottografo.<br>
 Viene quindi restituito il numero di sequenza memorizzato nell'oggetto 
 GraphNode fornito in input, ovvero il numero del nodo 0-based.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>int indice nodo
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sizeNodes()"><!-- --></A><H3>
sizeNodes</H3>
<PRE>
public int <B>sizeNodes</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di nodi inseriti nel grafo.
  <p>
  Se il metodo viene richiamato sul grafo principale, include
  tutti i sottografi popolato con addNode().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>numero nodi</DL>
</DD>
</DL>
<HR>

<A NAME="nodesStop()"><!-- --></A><H3>
nodesStop</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>nodesStop</B>()</PRE>
<DL>
<DD>Restituisce un array con tutti i nodi di stop del grafo.<br>
 <p>
 Si tratta di nodi che non hanno figli adiacenti. 
 Se il grafo è un sottografo, vengono restituiti tutti i
 nodi del sottografo.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node[]</DL>
</DD>
</DL>
<HR>

<A NAME="nodes()"><!-- --></A><H3>
nodes</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>nodes</B>()</PRE>
<DL>
<DD>Restituisce un array con tutti i nodi definiti ne grafo corrente.<br>
 <p>
 Se il grafo è quello principale, vengono restituiti 
 solo i suoi nodi.<br>
 Se il grafo è un sottografo, vengono restituiti tutti i
 nodi del sottografo.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node[]</DL>
</DD>
</DL>
<HR>

<A NAME="nodesAll()"><!-- --></A><H3>
nodesAll</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>nodesAll</B>()</PRE>
<DL>
<DD>Restituisce un array con tutti i nodi definiti nel grafo corrente
 e in tutti i suoi sottografi.<br>
 <p>
 Il metodo deve essere attivata dal grafo principale.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node[]</DL>
</DD>
</DL>
<HR>

<A NAME="arcs()"><!-- --></A><H3>
arcs</H3>
<PRE>
public <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[] <B>arcs</B>()</PRE>
<DL>
<DD>Restituisce un array con tutti gli archi definiti nel grafo o nel sottografo.<br>
 <p>
 Gli archi sono stati definiti a fronte della connessione fra due
 nodi, con connectNodes().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphArc arc[]</DL>
</DD>
</DL>
<HR>

<A NAME="arcsAll()"><!-- --></A><H3>
arcsAll</H3>
<PRE>
public <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[] <B>arcsAll</B>()</PRE>
<DL>
<DD>Restituisce un array con tutti gli archi definiti nel grafo principale
 e nei sottografi.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphArc arc[]</DL>
</DD>
</DL>
<HR>

<A NAME="nodeStart()"><!-- --></A><H3>
nodeStart</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>nodeStart</B>()</PRE>
<DL>
<DD>Restituisce il nodo di inizio del grafo
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node</DL>
</DD>
</DL>
<HR>

<A NAME="nodeEnd()"><!-- --></A><H3>
nodeEnd</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>nodeEnd</B>()</PRE>
<DL>
<DD>Restituisce l'ultimo nodo definito nel grafo, che deve essere NODE_END. <br>
 <p>
 Se il metododo è richiamato sul grafo principale, viene restituito il<br>
 nodo di END della mainline, altrimenti quello del sottografo in considerazione.<br>
 <p>
 Se l'ultimo nodo non è del tipo NODE_END, restituisce null<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node</DL>
</DD>
</DL>
<HR>

<A NAME="nodeLastInserted()"><!-- --></A><H3>
nodeLastInserted</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>nodeLastInserted</B>()</PRE>
<DL>
<DD>Restituisce l'ultimo nodo inserito nel grafo.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node</DL>
</DD>
</DL>
<HR>

<A NAME="arcChild(analyzer.GraphNode, int)"><!-- --></A><H3>
arcChild</H3>
<PRE>
public <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A> <B>arcChild</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeFather,
                         int&nbsp;nArc)</PRE>
<DL>
<DD>Restituisce l'arco uscente da un nodo padre, zero based
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeFather<DD><CODE>int</CODE> - nArc
<DT><B>Returns:</B><DD>GraphArc arc</DL>
</DD>
</DL>
<HR>

<A NAME="arcParent(analyzer.GraphNode, int)"><!-- --></A><H3>
arcParent</H3>
<PRE>
public <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A> <B>arcParent</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeFather,
                          int&nbsp;nArc)</PRE>
<DL>
<DD>Restituisce l'arco entrante in un nodo figlio, zero based
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeFather<DD><CODE>int</CODE> - nArc
<DT><B>Returns:</B><DD>GraphArc arc</DL>
</DD>
</DL>
<HR>

<A NAME="childNodes(analyzer.GraphNode)"><!-- --></A><H3>
childNodes</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>childNodes</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                       throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce un array di nodi figli
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode[] nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sizeNodesChild(analyzer.GraphNode)"><!-- --></A><H3>
sizeNodesChild</H3>
<PRE>
public int <B>sizeNodesChild</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                   throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il numero di nodi figli
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode[] nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="sizeNodesParent(analyzer.GraphNode)"><!-- --></A><H3>
sizeNodesParent</H3>
<PRE>
public int <B>sizeNodesParent</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                    throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il numero di nodi genitori
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode[] nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="childFirst(analyzer.GraphNode)"><!-- --></A><H3>
childFirst</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>childFirst</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                     throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il primo nodo figlio
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="childNext(analyzer.GraphNode)"><!-- --></A><H3>
childNext</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>childNext</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                    throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il successivo nodo figlio. <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parentNodes(analyzer.GraphNode)"><!-- --></A><H3>
parentNodes</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>[] <B>parentNodes</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;node)
                        throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce un array con tutti i nodi adiacenti gentitori di quello fornito.<br>
 <p>
 Vengono restituiti i nodi nel verso di percorrenza Backward,
 ovvero tutte le adiacenze dal figlio verso il padre.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>GraphNode node[]
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parentFirst(analyzer.GraphNode)"><!-- --></A><H3>
parentFirst</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>parentFirst</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                      throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il primo nodo genitore
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - graphNode
<DT><B>Returns:</B><DD>GraphNode nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="parentNext(analyzer.GraphNode)"><!-- --></A><H3>
parentNext</H3>
<PRE>
public <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A> <B>parentNext</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNode)
                     throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce il successivo nodo genitore
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - idNode
<DT><B>Returns:</B><DD>GraphNode nodeChild
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isThereConnection(analyzer.GraphNode, analyzer.GraphNode)"><!-- --></A><H3>
isThereConnection</H3>
<PRE>
public boolean <B>isThereConnection</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeStart,
                                 <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeTo)
                          throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD><h1>isThereConnection</h1>
 <p>
 Restituisce true se i due nodi sono connessi da un qualche cammino.<br>
 <p>
 Viene prima verificata l'esistenza in cache dei path per la connessione richiesta.
 A partire dal nodeStart vengono analizzati tutti i possibili cammini
 di visita del grafo. Se viene visitato il nodo noteTo viene restituito
 true, altrimenti false. <br>
 Viene utilizzato l'algoritmo di visita BACWARD, per non prendere in considerazione rami
 del grafo a valle del nodo di destinazione.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeFrom<DD><CODE>GraphNode</CODE> - nodeTo
<DT><B>Returns:</B><DD>boolean isThereConnection
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isNodeChild(analyzer.GraphNode, analyzer.GraphNode)"><!-- --></A><H3>
isNodeChild</H3>
<PRE>
public boolean <B>isNodeChild</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeFather,
                           <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeChild)
                    throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Restituisce true se il nodo è un figlio di quello padre fornito in input.<br>
 <p>
 Viene prima verificata l'esistenza del nodo figlio nelle adiacenze forward del
 nodo padre.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeFather<DD><CODE>GraphNode</CODE> - nodeChild di cui verificare se figlio del nodo padre
<DT><B>Returns:</B><DD>boolean isChild of nodeFather
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isCachingSubGraphExpanded()"><!-- --></A><H3>
isCachingSubGraphExpanded</H3>
<PRE>
public boolean <B>isCachingSubGraphExpanded</B>()</PRE>
<DL>
<DD>Restituisce True se caching abilitato dei path estratti con i sottografi espansi,
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bCaching</DL>
</DD>
</DL>
<HR>

<A NAME="setCachingSubGraphExpanded(boolean)"><!-- --></A><H3>
setCachingSubGraphExpanded</H3>
<PRE>
public void <B>setCachingSubGraphExpanded</B>(boolean&nbsp;bCachingPathSubGraphExpanded)</PRE>
<DL>
<DD>Abilita o disabilita il caching  dei path estratti con i sottografi espansi.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>caching</CODE> - the bCaching to set</DL>
</DD>
</DL>
<HR>

<A NAME="isCachingSubGraphToExpand()"><!-- --></A><H3>
isCachingSubGraphToExpand</H3>
<PRE>
public boolean <B>isCachingSubGraphToExpand</B>()</PRE>
<DL>
<DD>Restituisce True se caching abilitato dei path estratti con i sottografi ancora da espandere,
 False se i path contengono solo il richiamo al sottografo, i cui nodi visitati
 non vengono espansi.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bCaching</DL>
</DD>
</DL>
<HR>

<A NAME="setCachingSubGraphToExpand(boolean)"><!-- --></A><H3>
setCachingSubGraphToExpand</H3>
<PRE>
public void <B>setCachingSubGraphToExpand</B>(boolean&nbsp;bCachingPathSubGraphToExpand)</PRE>
<DL>
<DD>Abilita o disabilita il caching  dei path estratti con i sottografi espansi,
 In caso di disabilitazione i path contengono solo il richiamo al sottografo, i cui nodi visitati
 non vengono espansi.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>caching</CODE> - the bCaching to set</DL>
</DD>
</DL>
<HR>

<A NAME="clearCacheSubGraphToExpand()"><!-- --></A><H3>
clearCacheSubGraphToExpand</H3>
<PRE>
public void <B>clearCacheSubGraphToExpand</B>()</PRE>
<DL>
<DD>Svuotamento cache path da espandere
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearCacheSubGraphExpanded()"><!-- --></A><H3>
clearCacheSubGraphExpanded</H3>
<PRE>
public void <B>clearCacheSubGraphExpanded</B>()</PRE>
<DL>
<DD>Svuotamento cache path espansi
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearCacheSubGraphInternal()"><!-- --></A><H3>
clearCacheSubGraphInternal</H3>
<PRE>
public void <B>clearCacheSubGraphInternal</B>()</PRE>
<DL>
<DD>Svuotamento cache path completi di ogni sottografo
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isPathToGenerate()"><!-- --></A><H3>
isPathToGenerate</H3>
<PRE>
public boolean <B>isPathToGenerate</B>()</PRE>
<DL>
<DD>True indica che devono essere generati i path della visita al grafo
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the PathToStore</DL>
</DD>
</DL>
<HR>

<A NAME="isStopToFirstPath()"><!-- --></A><H3>
isStopToFirstPath</H3>
<PRE>
public boolean <B>isStopToFirstPath</B>()</PRE>
<DL>
<DD>True indica che il processo di visita si ferma al primo path incontrato
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the stopToFirstPath</DL>
</DD>
</DL>
<HR>

<A NAME="setStopToFirstPath(boolean)"><!-- --></A><H3>
setStopToFirstPath</H3>
<PRE>
public void <B>setStopToFirstPath</B>(boolean&nbsp;stopToFirstPath)</PRE>
<DL>
<DD>Imposta se il processo di visita si ferma al primo path incontrato
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stopToFirstPath</CODE> - the stopToFirstPath to set</DL>
</DD>
</DL>
<HR>

<A NAME="isSubGraphToExpandInPath()"><!-- --></A><H3>
isSubGraphToExpandInPath</H3>
<PRE>
public boolean <B>isSubGraphToExpandInPath</B>()</PRE>
<DL>
<DD>Indica che vengono restituiti i path fra due nodi, espandendo 
 in modo ricorsivo tutti i sottografi richiamati
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the bPathSubGraphToExpand</DL>
</DD>
</DL>
<HR>

<A NAME="enableArcs()"><!-- --></A><H3>
enableArcs</H3>
<PRE>
public void <B>enableArcs</B>()</PRE>
<DL>
<DD>Abilita tutti gli archi presenti nel grafo corrente.<br>
 <p>
 Pertanto le successive visite del grafo restituiranno tutti i path possibili.<br>
 <p>
 Gli archi sono stati disabilitati a fronte del metodo disablePaths()
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="enableArcsAll()"><!-- --></A><H3>
enableArcsAll</H3>
<PRE>
public void <B>enableArcsAll</B>()</PRE>
<DL>
<DD>Abilita tutti gli archi presenti nel grafo corrente e 
 nei sottografi richiamati.<br>
 Il metodo ha senso se attivato sul grafo principale.<br>
 <p>
 Pertanto le successive visite del grafo restituiranno tutti i path possibili.<br>
 <p>
 Gli archi sono stati disabilitati a fronte del metodo disablePaths()
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearCountVisit()"><!-- --></A><H3>
clearCountVisit</H3>
<PRE>
public void <B>clearCountVisit</B>()</PRE>
<DL>
<DD><h1>clearCountVisit</h1>
 <p>
 Azzera i contatori di visita di archi e nodi presenti nel grafo corrente e 
 nei sottografi richiamati.<br>
 <p>
 I contatori sono stati incrementati nel processo di visita.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="disablePaths(analyzer.GraphNode, analyzer.GraphNode, analyzer.GraphArc[], java.util.Set)"><!-- --></A><H3>
disablePaths</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>&gt; <B>disablePaths</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeStart,
                                                  <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;nodeTo,
                                                  <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]&nbsp;ar_arcsInPath,
                                                  java.util.Set&lt;<A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A>&gt;&nbsp;set_subGraphWithArcInSetChains)
                                           throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Disabilitazione paths fra due nodi.<br>
 <p>
 Questa feature viene utilizzata da <A HREF="../analyzer/LogicManager.html" title="class in analyzer"><CODE>LogicManager</CODE></A> e <A HREF="../analyzer/ProgramCobol.html" title="class in analyzer"><CODE>ProgramCobol</CODE></A> per ridurre, 
 senza perdita di informazione utile, il numero di path fra due nodi, attraverso la
 disabilitazione degli archi ininfluenti. <br>
 <p>
 La disabilitazione NON è ricorsiva e si ferma al sottografo corrente senza analizzare
 i sottografi richiamati con NODE_CALL_INTERNAL.<br>
 Tuttavia path contenenti NODE_CALL_INTERNAL a subGraph senza archi indispensabili,
 vengono disabilitati.
 <p>
 Operativamente vengono generati i path fra i due nodi forniti. <br>
 Per ogni path si verifica se contiene almeno un arco fra quelli forniti 
 in input oppure se richiamano un sottografo che li contiene. <br>
 Se nessun arco in input è presente nel path, allora tutti gli
 archi del path vengono disabilitati, tranne uno. <br>
 <p>
 Nel processo di visita verrà quindi ignorati i path disabilitati, 
 come se non fossero presenti  nel grafo, riducendo fortemente la complessità.<br>
 Nel caso tutti i path fra i due nodi, caso più normale, non contenessero
 alcun arco fra quelli forniti in input, viene tenuto attivo almeno un
 path fra i due nodi, per mantenere il grafo connesso.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeStart<DD><CODE>GraphNode</CODE> - nodeTo<DD><CODE>GraphArc[]</CODE> - arcsInPath<DD><CODE>set</CODE> - di subgraph
<DT><B>Returns:</B><DD>Archi che sono stati disabilitati
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getFromXML(java.lang.String, java.lang.String)"><!-- --></A><H3>
getFromXML</H3>
<PRE>
public void <B>getFromXML</B>(java.lang.String&nbsp;fileName,
                       java.lang.String&nbsp;pathToWrite)</PRE>
<DL>
<DD>Il grafo viene popolato a partire da una rappresentazione
 XML memorizzata su disco.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - fileName<DD><CODE>String</CODE> - pathToWrite</DL>
</DD>
</DL>
<HR>

<A NAME="serialize(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
serialize</H3>
<PRE>
public void <B>serialize</B>(java.lang.String&nbsp;pathOutput,
                      java.lang.String&nbsp;idObject,
                      java.lang.String&nbsp;filePrefix)
               throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Il grafo viene memorizzato su disco in formato serializzato.
 Vengono forniti come parametri gli elementi per comporre 
 il nome del file di output, a cura del chiamante.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - pathOutput      completo di \ finale<DD><CODE>String</CODE> - idObject                nome file di output che può essere diverso da id graph corrente<DD><CODE>String</CODE> - filePrefix              Prefisso file di output .xxx
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="unSerialize(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
unSerialize</H3>
<PRE>
public <A HREF="../analyzer/GraphManager.html" title="class in analyzer">GraphManager</A> <B>unSerialize</B>(java.lang.String&nbsp;pathInput,
                                java.lang.String&nbsp;idObject,
                                java.lang.String&nbsp;filePrefix)
                         throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Il grafo viene popolato a partire dall'ouput serializzato
 memorizzata su disco. 
 Viene fornito come parametro lo strim dell'oggetto di putput già pronto
 per la serializzazione, ariato a ura dell'oggetto chiamante.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - pathInput               completo di \ finale<DD><CODE>String</CODE> - idObject                nome file di input che può essere diverso da id graph da recuperare<DD><CODE>String</CODE> - filePrefix              Prefisso file di input .xxx
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="optimizeGraph()"><!-- --></A><H3>
optimizeGraph</H3>
<PRE>
public void <B>optimizeGraph</B>()
                   throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD>Metodo da rihiamare alla fine del popolamento dei nodi, archi, delle connessioni
 e del caricamento degli eventuali sottografi. Senza questo metodo l'oggetto graphManager
 NON è ompletamente operativo.
 
 Funzioni
 --------
 
 1) Caricamento Map di indicizzazione grafi interni richiamati.
 2) Ottimizzazione size strutture utilizzate per velocizzare gli accessi successivi.
 3) Ottimizzazione di tutti i sottografi interni definiti (metodo optimizeGraph)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getLoggerFacade()"><!-- --></A><H3>
getLoggerFacade</H3>
<PRE>
public <A HREF="../analyzer/LoggerFacade.html" title="class in analyzer">LoggerFacade</A> <B>getLoggerFacade</B>()</PRE>
<DL>
<DD>Restituisce il reference al gestore di log
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the loggerFacade</DL>
</DD>
</DL>
<HR>

<A NAME="setLoggerFacade(analyzer.LoggerFacade)"><!-- --></A><H3>
setLoggerFacade</H3>
<PRE>
public void <B>setLoggerFacade</B>(<A HREF="../analyzer/LoggerFacade.html" title="class in analyzer">LoggerFacade</A>&nbsp;loggerFacade)</PRE>
<DL>
<DD>Imposta il reference al gestore di log
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>loggerFacade</CODE> - the loggerFacade to set</DL>
</DD>
</DL>
<HR>

<A NAME="debugShowPath(analyzer.GraphPath)"><!-- --></A><H3>
debugShowPath</H3>
<PRE>
public void <B>debugShowPath</B>(<A HREF="../analyzer/GraphPath.html" title="class in analyzer">GraphPath</A>&nbsp;path)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="visit(analyzer.GraphNode, analyzer.GraphNode, enums.EnumGraphTypeVisit)"><!-- --></A><H3>
visit</H3>
<PRE>
public void <B>visit</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeStart,
                  <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeTo,
                  <A HREF="../enums/EnumGraphTypeVisit.html" title="enum in enums">EnumGraphTypeVisit</A>&nbsp;typeVisit)
           throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD><h1>visit</h1>
 <p>
 Effettua la visita completa fra il nodo di partenza e quello fornito in input.
 Quando un nodo o un arco viene percorso nel processo di visita, viene incrementato il contatore di visite.<br>
 Non vengono generati paths di esecuzione e cache di alcun tipo. Obiettivo è solo quello di effettuare
 la visita del grafo corrente fra due nodi.<br>
 Si utilizza questo metodo per rilevare il codice morto, ovvero le istruzioni definite in nodi e archi
 non percorsi nel processo di visita.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeStart<DD><CODE>GraphNode</CODE> - nodeTo<DD><CODE>EnumGraphTypeVisit</CODE> - typeVisit
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="paths(analyzer.GraphNode, analyzer.GraphNode, enums.EnumGraphTypeVisit, enums.EnumPathCaching, enums.EnumPathDeep)"><!-- --></A><H3>
paths</H3>
<PRE>
public <A HREF="../analyzer/GraphPath.html" title="class in analyzer">GraphPath</A>[] <B>paths</B>(<A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeStart,
                         <A HREF="../analyzer/GraphNode.html" title="class in analyzer">GraphNode</A>&nbsp;graphNodeTo,
                         <A HREF="../enums/EnumGraphTypeVisit.html" title="enum in enums">EnumGraphTypeVisit</A>&nbsp;typeVisit,
                         <A HREF="../enums/EnumPathCaching.html" title="enum in enums">EnumPathCaching</A>&nbsp;typePathCaching,
                         <A HREF="../enums/EnumPathDeep.html" title="enum in enums">EnumPathDeep</A>&nbsp;typePathDeep)
                  throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD><h1>paths</h1>
 <p>
 Restituisce tutti i possibili path fra i due nodi in input con algoritmo da utilizzare Backward o Forward
 fornito come parametro in input.
 Utilizzato il processo di visita backard, si parte dal nodo di arrivo per arrivare, attraverso i nodi padre, 
 al nodo di partenza.
 Utilizzato il processo di visita forward,invece, si parte dal nodo di partenza per arrivare, attraverso 
 tutti i possibili cammini di esecuzione, al nodo di arrivo.<br>
 Viene quindi restituito un array dei possibili cammini di visita del grafo. Se non è possibile 
 determinare un cammino, ovvero i due nodi sono sconnessi, viene restituito un reference a null. <br>
 <p>
 I paths porodotti vengono limitati al numero <code>1000</code> di default che può essere modificato e/o
 interrogato da <code>getMaxPathsSize()</code> e <code>setMaxPathsSize()</code>.
 <P>
 Sono gestite le seguenti situazioni:<br>
 <P>
 <Ul>
 <Li> (1) Nodo partenza e arrivo tutti definiti nel grafo principale
 <Li> (2) Nodo partenza e arrivo tutti definiti dentro sottografi diversi
 <Li> (3) Nodo partenza definito nel grafo principale e nodo di arrivo in un sottografo
 <Li> (4) Nodo partenza definito in un sottografo e nodo di arrivo nel grafo principale
 <Li> (5) Nodo partenza e arrivo tutti definiti nello stesso sottografo
 </Ul>
  
 <h3> (1) Nodo partenza e arrivo tutti definiti nel grafo principale </h3>
 
 Viene attivato il normale processo di visita fra due nodi, vengono estratti tutti i possibili
 path e successivamente vengono moltiplicati per esplodere ricorsivamente eventuali sottografi
 interni.
 
 <h3> (2) Nodo partenza e arrivo tutti definiti dentro sottografi </h3>
 
 Inizialmente vengono generati tutti i possibili path a ritroso, partendo dal nodo di
 arrivo definito nel sottografo, fino al nodo del grafo principale che include il primo
 sottografo rihiamato (NODE_CALL_INTERNAL). Il nodo di arrivo può trovarsi a un qualsiasi livello di 
 annidamento. L'output di questo processo sono un nodo di partenza sul grafo prinipale e tutti i possibili 
 path da questo al nodo del sottografo.<BR>
 <P>
 Poi, per il nodo di partenza, anch'esso definito in un sottografo, si effettua la stessa procedura effettuata
 per il nodo di arrivo. A questo punto si verifica se c'è oonnessione fra i due nodi individuati.
 Se non c'è connessione significa che anche fra i due nodi originari definiti nei sottografi non
 può esserci connessione.<br>
 Se c'è connessione si salvano tutti i path fra i due nodi del grafo principale e si opera in questo modo:<br>
 Si individuano tutti i path a fra il nodo di partenza nel sottografo e l'ultimo nodo del sottografo.<br>
 Si moltiplicano, nell'ordine, i path appena individuati nel paragrafo preedente, i path già salvati
 fra i due nodi del grafo pricipale e quelli già individuati, a partire dal nodo di arrivo nel sottografo,
 fino al nodo scatenante nel grafo prinipale.
 
 <h3> (3) Nodo partenza definito nel grafo principale e nodo di arrivo in un sottografo</h3>    
 
 Ci si comporta esattamente come nel caso precedente ma, dal momento che il nodo di partenza è nel
 grafo principale, i path relativi al nodo origine coincidono con il nodo stesso.
 A differenza del punto precedente si moltiplicano, nell'ordine, i path fra i due nodi del grafo principale 
 e quelli già individuati a partire dal nodo di arrivo nel sottografo, fino al nodo scatenante nel grafo 
 principale.
  
 <h3> (4) Nodo partenza definito in un sottografo e nodo di arrivo nel grafo principale</h3>    
 
 Vengono generati tutti i possibili path a ritroso, partendo dal nodo di partenza definito nel sottografo, 
 fino al nodo del grafo principale che include il primo sottografo rihiamato (NODE_CALL_INTERNAL). 
 Il nodo di partenza può trovarsi a un qualsiasi livello di  annidamento. 
 L'output di questo processo sono un nodo di partenza sul grafo principale e tutti i possibili 
 path da questo al nodo del sottografo.<BR>
 Quindi si individuano tutti i path fra il nodo di partenza individuato sul grafo principale (NODE_CALL_INTERNAL)
 e il nodo di arrivo. Si moltiplicano i due insiemi di path individuati per ottenere l'insieme completo dei
 path richiesti.
 
 <Li> (5) Nodo partenza e arrivo tutti definiti nello stesso sottografo
 
 Viene recuperato l'oggetto sottografo di tipo GraphManager che a tutti gli effetti è un grafo definito
 in modo indipendente, con tutti i nodi definiti, le strutture etc. Su questo oggetto
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>GraphNode</CODE> - nodeStart<DD><CODE>GraphNode</CODE> - nodeTo<DD><CODE>EnumGraphTypeVisit</CODE> - typeVisit<DD><CODE>EnumPathCaching</CODE> - typePathCaching<DD><CODE>EnumPathDeep</CODE> - typePathDeep
<DT><B>Returns:</B><DD>GraphPath path[]
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphManager.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../analyzer/GraphArcObjects.html" title="class in analyzer"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../analyzer/GraphNode.html" title="class in analyzer"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?analyzer/GraphManager.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphManager.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
