<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_13) on Sat Dec 15 14:25:30 CET 2012 -->
<TITLE>
ProgramCobol
</TITLE>

<META NAME="date" CONTENT="2012-12-15">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="ProgramCobol";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ProgramCobol.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../analyzer/ProgramCallsStack.InnerCallStackEntry.html" title="class in analyzer"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?analyzer/ProgramCobol.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ProgramCobol.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_analyzer.Program">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
analyzer</FONT>
<BR>
Class ProgramCobol</H2>
<PRE>
java.lang.Object
  <IMG SRC="../resources/inherit.gif" ALT="extended by "><A HREF="../analyzer/Program.html" title="class in analyzer">analyzer.Program</A>
      <IMG SRC="../resources/inherit.gif" ALT="extended by "><B>analyzer.ProgramCobol</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../analyzer/AmritaConstants.html" title="interface in analyzer">AmritaConstants</A>, java.io.Serializable</DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ProgramCobol</B><DT>extends <A HREF="../analyzer/Program.html" title="class in analyzer">Program</A><DT>implements java.io.Serializable, <A HREF="../analyzer/AmritaConstants.html" title="interface in analyzer">AmritaConstants</A></DL>
</PRE>

<P>
Copyright (c) 2009-2011 e-Amrita - Ing. Giampietro Zedda   Turin (ITALY)
 
 <h1>
 ProgramCobol 
 </h1>
  <p>
 Questa classe  modella un programma del linguaggio Cobol.<br>
 Tutte le caratteristiche e le gestioni comuni a tutti i linguaggi, sono modellate dalla classe madre Program.<br>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>21/04/2010</DD>
<DT><B>Version:</B></DT>
  <DD>1.0.0</DD>
<DT><B>Author:</B></DT>
  <DD>Giampietro Zedda</DD>
<DT><B>See Also:</B><DD><A HREF="../analyzer/Program.html" title="class in analyzer"><CODE>Program</CODE></A>, 
<A HREF="../analyzer/DataItem.html" title="class in analyzer"><CODE>DataItem</CODE></A>, 
<A HREF="../analyzer/Analyzer.html" title="class in analyzer"><CODE>Analyzer</CODE></A>, 
<A HREF="../analyzer/AnalyzerCobol.html" title="class in analyzer"><CODE>AnalyzerCobol</CODE></A>, 
<CODE>AnalyzerCobolCopyDataDivision</CODE>, 
<CODE>AnalyzerCobolCopyProcedure</CODE>, 
<CODE>AnalyzerCobolProgram</CODE>, 
<A HREF="../serialized-form.html#analyzer.ProgramCobol">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_analyzer.Program"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from class analyzer.<A HREF="../analyzer/Program.html" title="class in analyzer">Program</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../analyzer/Program.html#al_Option">al_Option</A>, <A HREF="../analyzer/Program.html#al_programSectionGraph">al_programSectionGraph</A>, <A HREF="../analyzer/Program.html#al_programSectionUnreferencedGraph">al_programSectionUnreferencedGraph</A>, <A HREF="../analyzer/Program.html#lf">lf</A>, <A HREF="../analyzer/Program.html#map_Symbol">map_Symbol</A>, <A HREF="../analyzer/Program.html#mm">mm</A>, <A HREF="../analyzer/Program.html#programGraph">programGraph</A>, <A HREF="../analyzer/Program.html#programName">programName</A>, <A HREF="../analyzer/Program.html#programType">programType</A>, <A HREF="../analyzer/Program.html#sd">sd</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_analyzer.AmritaConstants"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface analyzer.<A HREF="../analyzer/AmritaConstants.html" title="interface in analyzer">AmritaConstants</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../analyzer/AmritaConstants.html#COBOL_CONDITION_NAME_FROM">COBOL_CONDITION_NAME_FROM</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_CONDITION_NAME_TO">COBOL_CONDITION_NAME_TO</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_DATA_ITEM_USED_INPUT">COBOL_DATA_ITEM_USED_INPUT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_DATA_ITEM_USED_INPUT_OR_OUTPUT">COBOL_DATA_ITEM_USED_INPUT_OR_OUTPUT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_DATA_ITEM_USED_OUTPUT">COBOL_DATA_ITEM_USED_OUTPUT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_FD">COBOL_FD</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_JUSTIFIED_LEFT">COBOL_JUSTIFIED_LEFT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_JUSTIFIED_RIGHT">COBOL_JUSTIFIED_RIGHT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OCCURS_ASCENDING_KEY">COBOL_OCCURS_ASCENDING_KEY</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OCCURS_DESCENDING_KEY">COBOL_OCCURS_DESCENDING_KEY</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OPEN_EXTEND">COBOL_OPEN_EXTEND</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OPEN_I_O">COBOL_OPEN_I_O</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OPEN_INPUT">COBOL_OPEN_INPUT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_OPEN_OUTPUT">COBOL_OPEN_OUTPUT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_PREFETCH_PARSING_ROWS">COBOL_PREFETCH_PARSING_ROWS</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_SD">COBOL_SD</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_SIGN_LEADING">COBOL_SIGN_LEADING</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_SIGN_TRAILING">COBOL_SIGN_TRAILING</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_SYNCRONIZED_LEFT">COBOL_SYNCRONIZED_LEFT</A>, <A HREF="../analyzer/AmritaConstants.html#COBOL_SYNCRONIZED_RIGHT">COBOL_SYNCRONIZED_RIGHT</A>, <A HREF="../analyzer/AmritaConstants.html#DATA_ITEMS_ALL">DATA_ITEMS_ALL</A>, <A HREF="../analyzer/AmritaConstants.html#DATA_ITEMS_ELEMENTARY_FIELDS">DATA_ITEMS_ELEMENTARY_FIELDS</A>, <A HREF="../analyzer/AmritaConstants.html#DATA_ITEMS_GROUP_FIELDS">DATA_ITEMS_GROUP_FIELDS</A>, <A HREF="../analyzer/AmritaConstants.html#DEFAULT_SUB_SYS">DEFAULT_SUB_SYS</A>, <A HREF="../analyzer/AmritaConstants.html#DEFAULT_SYS">DEFAULT_SYS</A>, <A HREF="../analyzer/AmritaConstants.html#ENTRY_PGM_TYPE_DEF_COPY_DATA">ENTRY_PGM_TYPE_DEF_COPY_DATA</A>, <A HREF="../analyzer/AmritaConstants.html#ENTRY_PGM_TYPE_DEF_COPY_PROC">ENTRY_PGM_TYPE_DEF_COPY_PROC</A>, <A HREF="../analyzer/AmritaConstants.html#ENTRY_PGM_TYPE_DEF_DATA_ITEM">ENTRY_PGM_TYPE_DEF_DATA_ITEM</A>, <A HREF="../analyzer/AmritaConstants.html#ENTRY_PGM_TYPE_DEF_LABEL">ENTRY_PGM_TYPE_DEF_LABEL</A>, <A HREF="../analyzer/AmritaConstants.html#ENTRY_PGM_TYPE_DEF_PROC_INTERNAL">ENTRY_PGM_TYPE_DEF_PROC_INTERNAL</A>, <A HREF="../analyzer/AmritaConstants.html#FUNCTION_LOOKUP_RULE_TABLE">FUNCTION_LOOKUP_RULE_TABLE</A>, <A HREF="../analyzer/AmritaConstants.html#FUNCTION_SHOW_EXCEPTION_FAILURE">FUNCTION_SHOW_EXCEPTION_FAILURE</A>, <A HREF="../analyzer/AmritaConstants.html#FUNCTION_SHOW_LDV_ACCESS">FUNCTION_SHOW_LDV_ACCESS</A>, <A HREF="../analyzer/AmritaConstants.html#FUNCTION_SHOW_MESSAGES">FUNCTION_SHOW_MESSAGES</A>, <A HREF="../analyzer/AmritaConstants.html#ID_SUBGRAPH_MAINLINE">ID_SUBGRAPH_MAINLINE</A>, <A HREF="../analyzer/AmritaConstants.html#INSTR_USE_DATA_ITEM_INPUT">INSTR_USE_DATA_ITEM_INPUT</A>, <A HREF="../analyzer/AmritaConstants.html#INSTR_USE_DATA_ITEM_OUTPUT">INSTR_USE_DATA_ITEM_OUTPUT</A>, <A HREF="../analyzer/AmritaConstants.html#LAUNCH_METHOD_BY_THREAD">LAUNCH_METHOD_BY_THREAD</A>, <A HREF="../analyzer/AmritaConstants.html#LAUNCH_METHOD_INVOKE">LAUNCH_METHOD_INVOKE</A>, <A HREF="../analyzer/AmritaConstants.html#LAUNCH_METHOD_STATIC">LAUNCH_METHOD_STATIC</A>, <A HREF="../analyzer/AmritaConstants.html#LDV_RULE_TABLE_READ_ITEM_DEFAULT">LDV_RULE_TABLE_READ_ITEM_DEFAULT</A>, <A HREF="../analyzer/AmritaConstants.html#LDV_RULE_TABLE_READ_SET_DEFAULT">LDV_RULE_TABLE_READ_SET_DEFAULT</A>, <A HREF="../analyzer/AmritaConstants.html#LDV_RULE_TABLE_READ_SET_DEFAULT_COL_BOUND">LDV_RULE_TABLE_READ_SET_DEFAULT_COL_BOUND</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_BOTH_STATIC_AND_DYNAMIC_SAME_PGM">LOGIC_BOTH_STATIC_AND_DYNAMIC_SAME_PGM</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_DYNAMIC_SAME_PGM">LOGIC_DYNAMIC_SAME_PGM</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_DYNAMIC_SPREADED_PGM">LOGIC_DYNAMIC_SPREADED_PGM</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_EXEC_CICS_READ_TD">LOGIC_EXEC_CICS_READ_TD</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_EXEC_CICS_READ_TS">LOGIC_EXEC_CICS_READ_TS</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_EXEC_CICS_READ_VSAM">LOGIC_EXEC_CICS_READ_VSAM</A>, <A HREF="../analyzer/AmritaConstants.html#LOGIC_ONLY_STATIC">LOGIC_ONLY_STATIC</A>, <A HREF="../analyzer/AmritaConstants.html#MAX_PATHS_GRAPH_SIZE">MAX_PATHS_GRAPH_SIZE</A>, <A HREF="../analyzer/AmritaConstants.html#PARM_NUMERIC">PARM_NUMERIC</A>, <A HREF="../analyzer/AmritaConstants.html#PARM_TEXT">PARM_TEXT</A>, <A HREF="../analyzer/AmritaConstants.html#SQL_SCRIPT_PREFETCH_PARSING_ROWS">SQL_SCRIPT_PREFETCH_PARSING_ROWS</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_COPY">SUFFIX_SERIALIZED_COPY</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_GRAPH">SUFFIX_SERIALIZED_GRAPH</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_JCL_INCLUDE">SUFFIX_SERIALIZED_JCL_INCLUDE</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_JCL_JOB">SUFFIX_SERIALIZED_JCL_JOB</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_JCL_PROC">SUFFIX_SERIALIZED_JCL_PROC</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_PGM">SUFFIX_SERIALIZED_PGM</A>, <A HREF="../analyzer/AmritaConstants.html#SUFFIX_SERIALIZED_SCRIPT_SQL">SUFFIX_SERIALIZED_SCRIPT_SQL</A>, <A HREF="../analyzer/AmritaConstants.html#TAG_COMMENT">TAG_COMMENT</A>, <A HREF="../analyzer/AmritaConstants.html#TYPE_OBJECT_ALL">TYPE_OBJECT_ALL</A>, <A HREF="../analyzer/AmritaConstants.html#TYPE_OBJECT_SINGLE">TYPE_OBJECT_SINGLE</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#ProgramCobol(analyzer.SystemDefaults)">ProgramCobol</A></B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Costruttore 1</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#ProgramCobol(analyzer.SystemDefaults, java.lang.String)">ProgramCobol</A></B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
             java.lang.String&nbsp;programName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Costruttore 2</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#addEntryData(analyzer.ProgramCobolEntry)">addEntryData</A></B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;dataDefinitionEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserisce un entry di definizione dati del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#addEntryEnvironment(analyzer.ProgramCobolEntry)">addEntryEnvironment</A></B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;environmentEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserisce un entry di environment division del proframma<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#addEntryIdentification(analyzer.ProgramCobolEntry)">addEntryIdentification</A></B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;identificationEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserisce un entry di identificastion division del programma<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#addEntryProcedure(analyzer.ProgramCobolEntry)">addEntryProcedure</A></B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;instructionEntry)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserisce un entry di definizione istruzione del programma<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#calledStackInfo(analyzer.ProgramCallsStack)">calledStackInfo</A></B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Aggiorna il call entry specifico dello stack di chiamanti con le informazioni su
 tutte le procedure interne <b>chiamate</b> fra l'inizio della procedura interna
 e l'istruzione perform chiamante.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#callersStackInfo(int)">callersStackInfo</A></B>(int&nbsp;numInstrTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fornisce informazioni sulle procedure interne chiamanti ricorsivamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemDefinition(int)">dataItemDefinition</A></B>(int&nbsp;numInstrDef)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'istruzione di definizione del data item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemDefinition(java.lang.String)">dataItemDefinition</A></B>(java.lang.String&nbsp;dataItemName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il primo data item definito con il nome fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemName(int)">dataItemName</A></B>(int&nbsp;numDefinition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nome del data item, fornito il suo numero di definizione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Integer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemPointer(java.lang.String, java.lang.String)">dataItemPointer</A></B>(java.lang.String&nbsp;dataName,
                java.lang.String&nbsp;underGroup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il puntatore alla definizione dati del data item qualificato<br> 
 
 Viene cercato il data item che è definito sotto il campo di gruppo fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemPointers(java.lang.String)">dataItemPointers</A></B>(java.lang.String&nbsp;dataName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alla definizione dati nel programma, di data item con il nome fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/DataItemQualifier.html" title="class in analyzer">DataItemQualifier</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemQualifier(int, java.lang.String, java.lang.String)">dataItemQualifier</A></B>(int&nbsp;numInstruction,
                  java.lang.String&nbsp;dataName,
                  java.lang.String&nbsp;typeUseDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il qualificatote di utilizzo in input o in output del data item utilizzato dall'istruzione<br> 
 
 Se il numero di istruzione è errato viene restituito null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.util.ArrayList&lt;java.lang.Integer&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsImplicit(int)">dataItemsImplicit</A></B>(int&nbsp;pointerDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alla definizione dati nel programma, per il data item fornito in input,
 di tutti i data item redefines, renames e di gruppo che possono riferirsi implicitamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsLvl88(analyzer.InstructionCobolDataItem)">dataItemsLvl88</A></B>(<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&nbsp;dataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le definizioni dati a livello 88 codificate dopo il data item fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsNamesUsed(int, java.lang.String)">dataItemsNamesUsed</A></B>(int&nbsp;numInstruction,
                   java.lang.String&nbsp;useDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei data item utilizzati in input o in output dall'istruzione<br> 
 
 Se il numero di istruzione è errato viene restituito null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsNamesUsedBoth(int)">dataItemsNamesUsedBoth</A></B>(int&nbsp;numInstruction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei data item utilizzati sia in input sia in output dall'istruzione<br> 
 
 Se il numero di istruzione è errato viene restituito null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsRedefinePointers(int)">dataItemsRedefinePointers</A></B>(int&nbsp;numInstrDataNameRedefined)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni dei data item, che ridefiniscono quello fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsUnderGroup(int, int)">dataItemsUnderGroup</A></B>(int&nbsp;dataNameGroupPointer,
                    int&nbsp;typeDataItemsToExtract)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le definizioni dei data item elementari e/o di gruppo, 
 definiti sotto  il gruppo fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsUnderGroupNames(int, int)">dataItemsUnderGroupNames</A></B>(int&nbsp;dataNameGroupPointer,
                         int&nbsp;typeDataItemsToExtract)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei data item elementari, non di gruppo, definiti sotto il campo gruppo fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsUnderGroupPointers(int, int)">dataItemsUnderGroupPointers</A></B>(int&nbsp;dataNameGroupPointer,
                            int&nbsp;typeDataItemsToExtract)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni dei data item elementari e/o di gruppo, 
 definiti sotto  il gruppo fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/Instruction.InnerSymbolEntry.html" title="class in analyzer">Instruction.InnerSymbolEntry</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#dataItemsUsed(int, java.lang.String)">dataItemsUsed</A></B>(int&nbsp;numInstruction,
              java.lang.String&nbsp;typeUseDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce array con le coppie nome item/qualificatori dei data item utilizzati dall'istruzione<br> 
 
 Se il numero di istruzione è errato viene restituito null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeCopyData()">deadCodeCopyData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco dei copy non utilizzati in data Division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeCopyProc()">deadCodeCopyProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco dei copy non utilizzati in Procedure Division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeDataItemNumbers()">deadCodeDataItemNumbers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco dei numeri di definizione dati dead code in Data Division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeInstrNumbers()">deadCodeInstrNumbers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di istruzione di codice morto.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeLabels()">deadCodeLabels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco delle label di Procedure Division definite e non referenziate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeParagraphs()">deadCodeParagraphs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco dei paragraphi di Procedure Division definiti e non richiamati.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeSections()">deadCodeSections</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'elenco delle section di Procedure Division definite e non richiamate,<br>
 oppure richiamate da anche indirettamente da una section dead code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#deadCodeUnreachable()">deadCodeUnreachable</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di istruzione di codice morto, non raggiungibile fisicamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entriesData()">entriesData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le definizioni di data division del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entriesEnvironment()">entriesEnvironment</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le istruzioni di environment division del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entriesIdentification()">entriesIdentification</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le istruzioni di identification division del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entriesProcedure()">entriesProcedure</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le istruzioni di procedure division del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entryDataDivision(int)">entryDataDivision</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la definizione completa dell' entry di data division<br>
  
 Coincide coincide con il numero della definizione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entryEnvironmentDivision(int)">entryEnvironmentDivision</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la definizione completa dell' entry di environment division<br> 
 
 Coincide coincide con il numero della definizione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entryIdentificationDivision(int)">entryIdentificationDivision</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la definizione completa dell' entry di identification division<br> 
  
 Coincide coincide con il numero della definizione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#entryProcedure(int)">entryProcedure</A></B>(int&nbsp;instructionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la definizione completa dell' entry di procedure division<br> 
 
 Coincide on il numero dell'istruzione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.Integer,java.lang.Object[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getAnalysisMapGoTo()">getAnalysisMapGoTo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la map di servizio GoTo generata in fase di analisi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Map&lt;java.lang.String,java.lang.Object[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getAnalysisMapLabelSection()">getAnalysisMapLabelSection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la map di servizio Label/Section generata in fase di analisi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCopyNamesData()">getCopyNamesData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei copy definiti in data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCopyNamesEnv()">getCopyNamesEnv</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei copy definiti in environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCopyNamesId()">getCopyNamesId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei copy definiti in identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCopyNamesProc()">getCopyNamesProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei copy definiti in procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.Set&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCopyNested()">getCopyNested</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i copy nested presenti nel programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCountParagraphs()">getCountParagraphs</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di paragrafi (richiamati con perform) definiti nel programma;
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getCountSections()">getCountSections</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di section definite nel programma;
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getIfFalseEntries(int)">getIfFalseEntries</A></B>(int&nbsp;numInstrIf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le istruzioni del ramo ELSE di una istruzione IF ovvero per condizione FALSE.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getIfNestingLevel(int)">getIfNestingLevel</A></B>(int&nbsp;numInstrIf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di IF annidate, a partire dall'istruzione IF origine<br>
 
 Le ELSE interrompono il livello di annidamento.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getIfTrueEntries(int)">getIfTrueEntries</A></B>(int&nbsp;numInstrIf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le istruzioni del ramo TRUE di una istruzione IF.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/LogicInfoDynamic.html" title="class in analyzer">LogicInfoDynamic</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getLogicInfoDynamic()">getLogicInfoDynamic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'oggetto LogicInfoDynamic con le informazioni 
 sulle istruzioni dinamiche, le trasformazioni dei campi, i valori rilevati
 e le eventuali ultime assegnazioni ancora da risolvere.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getMetricsProgram()">getMetricsProgram</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le metriche associate  al programma completo
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getMetricsProgramMainline()">getMetricsProgramMainline</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le metriche associate  alla mainline del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getMetricsProgramSectionParagraph(java.lang.String)">getMetricsProgramSectionParagraph</A></B>(java.lang.String&nbsp;idSectionParagraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le metriche associate  a una specifica section/paragrafo del programma come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A><br>
 
 Se sectio/paragrafo non trovato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getMetricsProgramSections()">getMetricsProgramSections</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce le metriche associate  alle section/paragrafi del programma come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A><br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumInstrInDivision(int)">getNumInstrInDivision</A></B>(int&nbsp;numRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzione, nella divisione cobol di appartenenza,
 del numero di riga sorgente fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumInstrLinkageSection()">getNumInstrLinkageSection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzione, in Data Division, <br>
 dello statement Linkage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumInstrWsStorageSection()">getNumInstrWsStorageSection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzione, in Data Division, <br>
 dello statement Working-Storage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumLastInstrMainline()">getNumLastInstrMainline</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'ultimo numero di istruzione della mainline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowEndData()">getNumRowEndData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di fine di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowEndEnvironment()">getNumRowEndEnvironment</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di fine di environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowEndIdentification()">getNumRowEndIdentification</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di fine di identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowEndProc()">getNumRowEndProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di fine di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsShiftedLeft()">getNumRowsShiftedLeft</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente shiftate a sinistra.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsShiftedRight()">getNumRowsShiftedRight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente shiftate a destra.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowStartData()">getNumRowStartData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di inizio di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowStartEnvironment()">getNumRowStartEnvironment</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di inizio di environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowStartIdentification()">getNumRowStartIdentification</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di inizio di identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowStartProc()">getNumRowStartProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero riga sorgente di inizio di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsWithBadChar()">getNumRowsWithBadChar</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente con caratteri speciali e tabulazioni.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsWithBadCoding()">getNumRowsWithBadCoding</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente con codifiche deprecate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsWithBadCodingSql()">getNumRowsWithBadCodingSql</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente con codifiche deprecate in statements Sql.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getNumRowsWithDataUnclosed()">getNumRowsWithDataUnclosed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di riga sorgente di definizione dati non chiusi da un punto finale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getProgramId()">getProgramId</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nome del programma codificato in PROGRAM-ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../enums/EnumCobolReservedWords.html" title="enum in enums">EnumCobolReservedWords</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getRowDivision(int)">getRowDivision</A></B>(int&nbsp;numRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce la divisione cobol del numero di riga sorgente fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSelectStatement(java.lang.String)">getSelectStatement</A></B>(java.lang.String&nbsp;fileName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'istruzione Select di environment division relativa <br>
 al nome interno del file fornito in input;
 
 Se non viene trovata una select per il file fornito restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeComm()">getSizeComm</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di righe commento di tutto il programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeCommData()">getSizeCommData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di righe commento di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeCommProc()">getSizeCommProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di righe commento di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeInstrData()">getSizeInstrData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni di definizione dati in data division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeInstrDataFile()">getSizeInstrDataFile</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni di definizione dati in data division, File section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeInstrDataLinkage()">getSizeInstrDataLinkage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni di definizione dati in data division, Linkage section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeInstrDataWorking()">getSizeInstrDataWorking</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni di definizione dati in data division, Working-storage section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeInstrProc()">getSizeInstrProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni in procedure division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSource()">getSizeSource</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente, con i copy non esplosi<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSourceBlank()">getSizeSourceBlank</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente vuote<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSourceData()">getSizeSourceData</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente di di data division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSourceDataBlank()">getSizeSourceDataBlank</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente vuote di data division<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSourceProc()">getSizeSourceProc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente di procedure division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSizeSourceProcBlank()">getSizeSourceProcBlank</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero totale di righe sorgente vuote di procedure division<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#getSpecialNamesInfo()">getSpecialNamesInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'istruzione completa di environment division che descrive
 il paragrafo special-names, con informazioni punto decimale, alfabeto,
 currency etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#groupOwnerDefinition(int)">groupOwnerDefinition</A></B>(int&nbsp;dataNamePointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il puntatore al campo di gruppo sotto il quale il data item è immediatamente definito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#groupOwnerName(int)">groupOwnerName</A></B>(int&nbsp;dataNamePointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nome del campo di gruppo sotto il quale il data item è immediatamente definito<br> 
 
 Il numero di livello del gruppo deve essere inferiore a quello del data item
 Se il data item fornito è errato restituisce null <br>
 Se il data item non è definito sotto un gruppo, in quanto livello 01, restituisce stringa vuota<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#groupOwnerNames(int)">groupOwnerNames</A></B>(int&nbsp;dataNamePointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nomi dei campi di gruppo sotto i quali il data item è definito<br> 
 
 La funzione restituisce tutti i campi di gruppo sotto il quale il data item fornito è definito<br>
 L'array restituito ha come ultimo elemento il campo di gruppo più generale, con il numero di livello<br>
 più basso, come il livello 01.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#groupOwnerPointers(int)">groupOwnerPointers</A></B>(int&nbsp;dataNamePointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori ai campi di gruppo 
 sotto il quale il data item fornito è definito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionConditionOwnerMain(int)">instructionConditionOwnerMain</A></B>(int&nbsp;instructionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero dell'istruzione condizionale di più alto livello
 sotto la quale l'istruzione fornita in input è definita.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobol.html" title="class in analyzer">InstructionCobol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionCopyData(int)">instructionCopyData</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'struzione statement Cobol di data division, memorizzata nell'entry del quale è fornito il numero<br> 
 
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobol.html" title="class in analyzer">InstructionCobol</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionCopyProc(int)">instructionCopyProc</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'struzione statement Cobol di procedure division, memorizzata nell'entry del quale è fornito il numero<br>
  
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionDataItem(int)">instructionDataItem</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce un oggetto InstructionCobolDataItem, memorizzato nell'entry del quale è fornito il numero<br> 
 
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCics.html" title="class in analyzer">InstructionCics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionPrecompilerData(int)">instructionPrecompilerData</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'struzione di precompilatore, memorizzata nell'entry del quale è fornito il numero<br> 
 
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/InstructionCics.html" title="class in analyzer">InstructionCics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionPrecompilerProc(int)">instructionPrecompilerProc</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'struzione di precompilatore, memorizzata nell'entry del quale è fornito il numero<br> 
 
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#instructionProcedure(int)">instructionProcedure</A></B>(int&nbsp;instructionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce l'istruzione in procedure division, memorizzata nell'entry del quale è fornito il numero<br>
  
 Il chiamante deve effettuare il casting all'oggetto istruzione corretto
 Se il pointer fornito è errato restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isAlphabetEbcdic()">isAlphabetEbcdic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se se il programma, negli Special-Names,
 ha la clausola ALPHABET diversa da EBCDIC.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isAnySectionCobol()">isAnySectionCobol</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se presente almeno una section cobol nel programma
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isCicsProgram()">isCicsProgram</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se il programma contiene istruzioni Cics.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemGroupWithBynaryFields(int)">isDataItemGroupWithBynaryFields</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item, di gruppo, contiene dei sottocampi binari.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemInputForAnyData(java.lang.String)">isDataItemInputForAnyData</A></B>(java.lang.String&nbsp;dataName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è referenziato da qualche altro data item.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemTableElement(int)">isDataItemTableElement</A></B>(int&nbsp;definitionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è un elemento di una tabella definita con occurs.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemUnderGroupName(int, java.lang.String)">isDataItemUnderGroupName</A></B>(int&nbsp;definitionPointer,
                         java.lang.String&nbsp;underGroup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è definito immediatamente sotto il campo di gruppo fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemUnderGroupNameAnyLevel(int, java.lang.String)">isDataItemUnderGroupNameAnyLevel</A></B>(int&nbsp;definitionPointer,
                                 java.lang.String&nbsp;underGroup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è definito sotto il campo di gruppo fornito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemUsedByAnyProcInstr(java.lang.String, java.lang.String)">isDataItemUsedByAnyProcInstr</A></B>(java.lang.String&nbsp;dataName,
                             java.lang.String&nbsp;typeUseDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è referenziato in input o in output da qualche istruzione<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDataItemUsedByAnyProcInstrImplicit(int, java.lang.String)">isDataItemUsedByAnyProcInstrImplicit</A></B>(int&nbsp;pointerDataName,
                                     java.lang.String&nbsp;typeUseDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il data item è referenziato direttamente o indirettamente 
 in input o in output da qualche istruzione<br> 
 
 Si considerano i riferimenti al data item, alle sue ridefinizioni ai suoi campi
 rinominati e a tutti i gruppi sotto il quale il data item è definito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDecimalPointComma()">isDecimalPointComma</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il programma, negli Special-Names,
 ha la clausola Decimal Point Is Comma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isDl1Program()">isDl1Program</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se il programma contiene istruzioni Dl1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isEntryDataItem(int)">isEntryDataItem</A></B>(int&nbsp;entryPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se l'entry rappresenta una definizione dati<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isEntryLabel(int)">isEntryLabel</A></B>(int&nbsp;entryPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se l'entry rappresenta una label di procedure division<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isEntrySection(int)">isEntrySection</A></B>(int&nbsp;entryPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se l'entry rappresenta una Section di procedure division<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isIfWithElse(int)">isIfWithElse</A></B>(int&nbsp;numInstrIf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se presente il ramo ELSE di una istruzione IF, ovvero per condizione FALSE.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isInstructionUnderCondition(int)">isInstructionUnderCondition</A></B>(int&nbsp;instructionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se l'istruzione è definita in un ramo di una istruzione condizionale<br> 
 
 Se il pointer all'istruzione è errato oppure l'istruzione non è
 definita al suo interno, si restituisce false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isInstructionUnderSection(int, int)">isInstructionUnderSection</A></B>(int&nbsp;instructionPointer,
                          int&nbsp;underSectionPointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se l'istruzione è definita all'interno della Section fornita in input<br> 
 
 Se il pointer all'istruzione è errato o la Section non è definita oppure l'istruzione non è
 definita al suo interno, si restituisce false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isLabel(java.lang.String)">isLabel</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se il nome fornito in input è quello di una label<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isLabelReferenced(java.lang.String)">isLabelReferenced</A></B>(java.lang.String&nbsp;labelName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se la label è referenziata in qualche istruzione di procedure division<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isParagraph(java.lang.String)">isParagraph</A></B>(java.lang.String&nbsp;idParagraph)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il nome fornito in input è quello di un paragrafo cobol<br> 
 
 Un paragrafo è una label oggetto di uno statement perform<br>
 oppure dichuarata nella sezione DECLARATIVES oppure semplicemente<br>
 seguita da altri statement, una label di chiusura e terminato con exit<br>
 
 L'indicazione se una label sia o meno un paragrafo viene imnposta a fine<br>
 analisi sorgente e viene aggiornata l'istruzione label con le informazioni<br>
 del paragrafo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isParagraphDeadCode(java.lang.String)">isParagraphDeadCode</A></B>(java.lang.String&nbsp;paragraphName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il paragrafo fornito è dead code<br>
 
 Si verifica semplicemente se la label del paragrafo è referenziata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isParagraphReferenced(java.lang.String)">isParagraphReferenced</A></B>(java.lang.String&nbsp;paragraphName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se il paragrafo fornito è referenziato<br>
 
 Il paragrafo può essere referenziato con perform o con goto.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isProcInternalDeadCode(java.lang.String)">isProcInternalDeadCode</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se la procedura interna fornito è dead code<br>
 
 La procedura interna è dead code se non è mai referenziata o se seguendo la
 catena di section o paragrafi chiamanti si arriva a una non più referenziata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isProcInternalLoopPerformed(java.lang.String)">isProcInternalLoopPerformed</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se la procedura interna è richiamata a fronte di un loop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isProcInternalNameRecursiveCalled(java.lang.String)">isProcInternalNameRecursiveCalled</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se la procedura interna fornita richiama ricorsivamente se stessa.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isSection(java.lang.String)">isSection</A></B>(java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se il nome fornito in input è quello di una section cobol<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isSectionDeadCode(java.lang.String)">isSectionDeadCode</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce true se la section fornita è dead code<br>
 
 La section è dead code se non è mai referenziata o se seguendo la
 catena di section chiamanti si arriva a una non più referenziata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isSectionReferenced(java.lang.String)">isSectionReferenced</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restiuisce true se la Section è in input in qualche istruzione di procedure division<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isSqlProgram()">isSqlProgram</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se il programma contiene istruzioni Sql.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isThereLinkageSection()">isThereLinkageSection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se presente, in Data Division, <br>
 lo statement Working-Storage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#isThereWsStorageSection()">isThereWsStorageSection</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce se presente, in Data Division, <br>
 lo statement Linkage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#labelNames()">labelNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le label definite nel programma<br> 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#labelNames(java.lang.String)">labelNames</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le label definite in una section del programma <br> 
 
 Se la section non è definita restituisce null</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#labelNames(java.lang.String, java.lang.String)">labelNames</A></B>(java.lang.String&nbsp;labelFrom,
           java.lang.String&nbsp;labelTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le label definite fra due label di un programma <br> 
 
 Se labelFrom o labelTo non è definita restituisce null</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#labelPointer(java.lang.String)">labelPointer</A></B>(java.lang.String&nbsp;labelName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il puntatore alla definizione della label<br> 
 
 Coincide coincide con il numero dell'istruzione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#labelPointers(java.lang.String)">labelPointers</A></B>(java.lang.String&nbsp;labelName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizione della label<br> 
 
 Normalmente una label è definito una sola volta ma<br> 
 può essere definita con lo stesso nome in section Cobol<br> 
 differenti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#optimize()">optimize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Operazioni finali di consolidamento delle strutture interne.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#paragraphNames()">paragraphNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutti i paragrafi definiti nel programma<br> 
 
 Si tratta di paragrafi dichiarati nella sezione DECLARATIVES, <br>
 eseguiti con perform o codificati e chiusi formalmente da EXIT e <br>
 non richiamati.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#pathsComplete(analyzer.ProgramCallsStack)">pathsComplete</A></B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Produzione paths definitivi come moltiplicazione dei path intermedi, generati
 ai vari livelli di di stack chiamanti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#pathsIntermediate(analyzer.ProgramCallsStack)">pathsIntermediate</A></B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 Produzione paths parziali per ogni call stack entry di ogni stack entry
 originato da perform chiamanti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.Integer&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalInstructionsCaller(java.lang.String)">procInternalInstructionsCaller</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri di istruzione chiamanti, anche indirettamente, la procedura fornita.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNameOwner(int)">procInternalNameOwner</A></B>(int&nbsp;numInstr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il nome della section o del paragrafo sotto la quale è collocato il numero di istruzione<br> 
 
 In caso di istruzione nella mainline del programma restituisce <br>
 la stringa "== MAINLINE =="<br>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNames()">procInternalNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutte le procedure interne definite nel programma <br> 
 
 Si tratta di Section e paragrafi richiamati con perform o eventualmente solo definiti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNamesCalledAll(java.lang.String)">procInternalNamesCalledAll</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutte le procedure interne richiamate dalla procedura fornita direttamente o ricorsivamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNamesCalledDirect(java.lang.String)">procInternalNamesCalledDirect</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutte le procedure interne richiamate dalla procedura fornita direttamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNamesCalledPopulateMap()">procInternalNamesCalledPopulateMap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Per ogni procedura interna, ovvero section o paragrafo, si aggiorna l'elenco delle procedure chiamate direttamente.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNamesCaller(java.lang.String)">procInternalNamesCaller</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi delle procedure interne chiamanti, anche indirettamente, la procedura fornita.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalNumInstrFirst(java.lang.String)">procInternalNumInstrFirst</A></B>(java.lang.String&nbsp;procInternalName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il primo numero di istruzione della procedura interna.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#procInternalPointer(java.lang.String)">procInternalPointer</A></B>(java.lang.String&nbsp;idProcInternal)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il puntatore alla definizione della section o del paragrafo<br> 
 
 Coincide coincide con il numero dell'istruzione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionCaller(java.lang.String)">sectionCaller</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le section chiamanti, senza discriminare se dead code o meno<br>
 
 Viene analizzato qualsiasi livello di annidamento delle section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionCallerDeadCode(java.lang.String)">sectionCallerDeadCode</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le section chiamanti dead code, senza ulteriori chiamanti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionCallerNoDeadCode(java.lang.String)">sectionCallerNoDeadCode</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce tutte le section chiamanti no dead code, richiamate direttamente dalla mainline<br>
 
 Viene analizzato qualsiasi livello di annidamento delle section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionCountNoLabelInstr(java.lang.String)">sectionCountNoLabelInstr</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il numero di istruzioni non LABEL presenti nella section fornita<br>
 
 Se il nome della section è errato restituisce -1<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.util.ArrayList&lt;java.lang.String&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionLabels(java.lang.String)">sectionLabels</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutte le label presenti nella section fornita<br>
 
 Se il nome della section è errato restituisce un array vuoto<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionNames()">sectionNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutte le section definite nel programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#sectionPointer(java.lang.String)">sectionPointer</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce il puntatore alla definizione della section<br> 
 
 Coincide coincide con il numero dell'istruzione.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setAlphabetEbcdic(boolean)">setAlphabetEbcdic</A></B>(boolean&nbsp;isAlphabetEbcdic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se il programma, negli Special-Names,
 ha la clausola ALPHABET diversa da EBCDIC.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setAnalysisMapGoTo(java.util.Map)">setAnalysisMapGoTo</A></B>(java.util.Map&lt;java.lang.Integer,java.lang.Object[]&gt;&nbsp;mapGoTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta la map di servizio GoTo generata in fase di analisi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setAnalysisMapLabelSection(java.util.Map)">setAnalysisMapLabelSection</A></B>(java.util.Map&lt;java.lang.String,java.lang.Object[]&gt;&nbsp;mapLabelSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta la map di servizio Label/Section generata in fase di analisi.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCicsProgram(boolean)">setCicsProgram</A></B>(boolean&nbsp;isCicsProgram)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se il programma contiene istruzioni Cics.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCopyNamesData(java.util.Set)">setCopyNamesData</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i nomi dei copy definiti in data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCopyNamesEnv(java.util.Set)">setCopyNamesEnv</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyEnv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i nomi dei copy definiti in environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCopyNamesId(java.util.Set)">setCopyNamesId</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i nomi dei copy definiti in identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCopyNamesProc(java.util.Set)">setCopyNamesProc</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i nomi dei copy definiti in procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setCopyNested(java.util.Set)">setCopyNested</A></B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyNested)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i copy nested presenti nel programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setDecimalPointComma(boolean)">setDecimalPointComma</A></B>(boolean&nbsp;isDecimalPointComma)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se se il programma, negli Special-Names,
 ha la clausola Decimal Point Is Comma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setDl1Program(boolean)">setDl1Program</A></B>(boolean&nbsp;isDl1Program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se il programma contiene istruzioni Dl1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setLinkageSection(boolean)">setLinkageSection</A></B>(boolean&nbsp;isThereLinkageSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se presente, in Data Division, <br>
 lo statement Working-Storage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setLogicInfoDynamic(analyzer.LogicInfoDynamic)">setLogicInfoDynamic</A></B>(<A HREF="../analyzer/LogicInfoDynamic.html" title="class in analyzer">LogicInfoDynamic</A>&nbsp;logicInfoDynamic)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta l'oggetto LogicInfoDynamic con le informazioni 
 sulle istruzioni dinamiche, le trasformazioni dei campi, i valori rilevati
 e le eventuali ultime assegnazioni ancora da risolvere.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setMetricsProgram(analyzer.Metrics)">setMetricsProgram</A></B>(<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&nbsp;metricsProgram)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta le metriche associate  al programma completo
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setMetricsProgramMainline(analyzer.Metrics)">setMetricsProgramMainline</A></B>(<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&nbsp;metricsProgramMainline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta le metriche associate  alla mainline del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setMetricsProgramSection(java.util.ArrayList)">setMetricsProgramSection</A></B>(java.util.ArrayList&lt;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&gt;&nbsp;al_metricsProgramSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta le metriche associate  alle section/paragrafi del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumInstrLinkageSection(int)">setNumInstrLinkageSection</A></B>(int&nbsp;numInstrLinkageSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzione, in Data Division, <br>
 dello statement Linkage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumInstrWsStorageSection(int)">setNumInstrWsStorageSection</A></B>(int&nbsp;numInstrWsStorageSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzione, in Data Division, <br>
 dello statement Working-Storage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumLastInstrMainline(int)">setNumLastInstrMainline</A></B>(int&nbsp;numLastInstrMainline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta l'ultimo numero di istruzione della mainline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowEndData(int)">setNumRowEndData</A></B>(int&nbsp;numRowEndData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di fine di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowEndEnvironment(int)">setNumRowEndEnvironment</A></B>(int&nbsp;numRowEndEnvironment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di fine di environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowEndIdentification(int)">setNumRowEndIdentification</A></B>(int&nbsp;numRowEndIdentification)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di fine di identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowEndProc(int)">setNumRowEndProc</A></B>(int&nbsp;numRowEndProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imòposta il numero riga sorgente di fine di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsShiftedLeft(java.util.ArrayList)">setNumRowsShiftedLeft</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowShiftedLeft)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente shiftate a sinistra.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsShiftedRight(java.util.ArrayList)">setNumRowsShiftedRight</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowShiftedRight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente shiftate a destra.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowStartData(int)">setNumRowStartData</A></B>(int&nbsp;numRowStartData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di inizio di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowStartEnvironment(int)">setNumRowStartEnvironment</A></B>(int&nbsp;numRowStartEnvironment)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di inizio di environment division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowStartIdentification(int)">setNumRowStartIdentification</A></B>(int&nbsp;numRowStartIdentification)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di inizio di identification division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowStartProc(int)">setNumRowStartProc</A></B>(int&nbsp;numRowStartProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero riga sorgente di inizio di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsWithBadChar(java.util.ArrayList)">setNumRowsWithBadChar</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadChar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente con caratteri speciali e tabulazioni.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsWithBadCoding(java.util.ArrayList)">setNumRowsWithBadCoding</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadCoding)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente con codifiche deprecate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsWithBadCodingSql(java.util.ArrayList)">setNumRowsWithBadCodingSql</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadCodingSql)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente con codifiche deprecate in statements Sql.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setNumRowsWithDataUnclosed(java.util.ArrayList)">setNumRowsWithDataUnclosed</A></B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithDataUnclosed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta i numeri di riga sorgente di definizione dati non chiusi da un punto finale.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setProgramId(java.lang.String)">setProgramId</A></B>(java.lang.String&nbsp;programId)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il nome del programma codificato in PROGRAM-ID.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeComm(int)">setSizeComm</A></B>(int&nbsp;sizeComm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di righe commento di tutto il programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeCommData(int)">setSizeCommData</A></B>(int&nbsp;sizeCommData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di righe commento di data division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeCommProc(int)">setSizeCommProc</A></B>(int&nbsp;sizeCommProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di righe commento di procedure division.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeInstrData(int)">setSizeInstrData</A></B>(int&nbsp;sizeInstrData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzioni di definizione dati in data division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeInstrDataFile(int)">setSizeInstrDataFile</A></B>(int&nbsp;sizeInstrDataFile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzioni di definizione dati in data division, File section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeInstrDataLinkage(int)">setSizeInstrDataLinkage</A></B>(int&nbsp;sizeInstrDataLinkage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzioni di definizione dati in data division, Linkage section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeInstrDataWorking(int)">setSizeInstrDataWorking</A></B>(int&nbsp;sizeInstrDataWorking)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzioni di definizione dati in data division, Working-storage section<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeInstrProc(int)">setSizeInstrProc</A></B>(int&nbsp;sizeInstrProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero di istruzioni in procedure division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSource(int)">setSizeSource</A></B>(int&nbsp;sizeSource)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente, con i copy non esplosi<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSourceBlank(int)">setSizeSourceBlank</A></B>(int&nbsp;sizeSourceBlank)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente vuote<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSourceData(int)">setSizeSourceData</A></B>(int&nbsp;sizeSourceData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente di data division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSourceDataBlank(int)">setSizeSourceDataBlank</A></B>(int&nbsp;sizeSourceDataBlank)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente vuote di data division<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSourceProc(int)">setSizeSourceProc</A></B>(int&nbsp;sizeSourceProc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente di procedure division<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSizeSourceProcBlank(int)">setSizeSourceProcBlank</A></B>(int&nbsp;sizeSourceProcBlank)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta il numero totale di righe sorgente vuote di procedure division<br>
 
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSpecialNamesInfo(analyzer.InstructionCobolEnvironment)">setSpecialNamesInfo</A></B>(<A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A>&nbsp;specialNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta l'istruzione completa di environment division che descrive
 il paragrafo special-names, con informazioni punto decimale, alfabeto,
 currency etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setSqlProgram(boolean)">setSqlProgram</A></B>(boolean&nbsp;isSqlProgram)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imèpsta se il programma contiene istruzioni Sql.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#setWsStorageSection(boolean)">setWsStorageSection</A></B>(boolean&nbsp;isThereWsStorageSection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Imposta se presente, in Data Division, <br>
 lo statement Linkage Section.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#subGraphsWithArcSet(analyzer.ProgramCallsStack, analyzer.GraphArc[])">subGraphsWithArcSet</A></B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack,
                    <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]&nbsp;ar_ArcInSetChains)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Individuazione, dati gli archi interessati, dei sottografi corrispondenti.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#symbolNames()">symbolNames</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi dei simboli non section e non label definiti nel programma <br> 
 
 Si tratta di nomi di campi, literal, costanti figurative etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#unXrefSymbols(enums.EnumSymbolType)">unXrefSymbols</A></B>(<A HREF="../enums/EnumSymbolType.html" title="enum in enums">EnumSymbolType</A>&nbsp;symbolTypeParm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i nomi di tutti i simboli di un certo tipo non referenziati da nessuna istruzione di procedure division<br> 
 
 Il tipo di simbolo può essere Label, Section o Data Item come speccificato in <A HREF="../analyzer/AmritaConstants.html" title="interface in analyzer"><CODE>AmritaConstants</CODE></A>
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemInDataDivision(java.lang.String)">xrefToDataItemInDataDivision</A></B>(java.lang.String&nbsp;dataName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni che referenziano il data item, in data division<br> 
 
 Per esempio vengono restituiti tutti i data item che ridefiniscono un campo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemInDataDivisionOf(java.lang.String, java.lang.String)">xrefToDataItemInDataDivisionOf</A></B>(java.lang.String&nbsp;dataName,
                               java.lang.String&nbsp;underGroupName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni che referenziano il data item, in data division 
 con la clausola OF group-name<br>
 
 Viene fornito anche il nome del data item di gruppo sotto il quale è definito il data item
 Se il data item non è referenziata restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemInProcedure(int, java.lang.String)">xrefToDataItemInProcedure</A></B>(int&nbsp;pointerDataItem,
                          java.lang.String&nbsp;typeXref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni che referenziano il data item in procedure division<br> 
 
 Se il data item non è definito restituisce null.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemInProcedureImplicit(int, java.lang.String)">xrefToDataItemInProcedureImplicit</A></B>(int&nbsp;pointerDataItemOrigin,
                                  java.lang.String&nbsp;typeXref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni che implicitamente referenziano 
 il data item in procedure division, attraverso assegnazioni a campi redefines,
 renames e di gruppo.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemInProcedureOf(java.lang.String, java.lang.String, java.lang.String)">xrefToDataItemInProcedureOf</A></B>(java.lang.String&nbsp;dataName,
                            java.lang.String&nbsp;underGroupName,
                            java.lang.String&nbsp;typeXref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni di procedure che referenziano il data item
 qualificato dalla clausola OF.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemsUsedByInstr(int, java.lang.String)">xrefToDataItemsUsedByInstr</A></B>(int&nbsp;numInstruction,
                           java.lang.String&nbsp;useDataItem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i numeri delle definizioni dei data item utilizzati in input o in output dall'istruzione<br> 
 
 Per ogni simbolo qualificato viene cercato il numero di definizione dove questo è definito.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToDataItemsUsedByInstrBoth(int)">xrefToDataItemsUsedByInstrBoth</A></B>(int&nbsp;numInstruction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i pointer alle definizioni dei campi utilizzati in input insieme a quelli utilizzati in output<br> 
 dell'istruzione il cui numero è fornito in input.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToLabel(java.lang.String)">xrefToLabel</A></B>(java.lang.String&nbsp;labelName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni che referenziano una label Cobol<br> 
 
 Coincide con il numeri delle istruzioni di programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToProcedureInternal(java.lang.String)">xrefToProcedureInternal</A></B>(java.lang.String&nbsp;procedureName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni Cobol Perform a section o procedure<br> 
 
 Coincide con il numeri delle istruzioni di programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToSection(java.lang.String)">xrefToSection</A></B>(java.lang.String&nbsp;sectionName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni che referenziano una Section Cobol<br> 
 
 Coincide con i numeri delle istruzioni del programma.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToSymbolInDataDivision(java.lang.String)">xrefToSymbolInDataDivision</A></B>(java.lang.String&nbsp;symbolName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni che referenziano il simbolo, in data division<br> 
 
 Per esempio vengono restituiti tutti i data item che referenziano una costante figurativa.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToSymbolInEnvDivision(java.lang.String)">xrefToSymbolInEnvDivision</A></B>(java.lang.String&nbsp;symbolName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle definizioni che referenziano il simbolo, in environment division<br> 
 
 Per esempio vengono restituiti tutti gli statement di environment dove una literal è utilizzata
 o un data  item referenziato.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../analyzer/ProgramCobol.html#xrefToSymbolInProcedure(java.lang.String, java.lang.String)">xrefToSymbolInProcedure</A></B>(java.lang.String&nbsp;symbolName,
                        java.lang.String&nbsp;typeXref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Restituisce i puntatori alle istruzioni che referenziano il simbolo in procedure division<br> 
 
 Se il simbolo non è definito restituisce null.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_analyzer.Program"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class analyzer.<A HREF="../analyzer/Program.html" title="class in analyzer">Program</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../analyzer/Program.html#addOptionProgram(enums.EnumObjectOption)">addOptionProgram</A>, <A HREF="../analyzer/Program.html#getMapSymbols()">getMapSymbols</A>, <A HREF="../analyzer/Program.html#getOptionsProgram()">getOptionsProgram</A>, <A HREF="../analyzer/Program.html#getProgramGraph()">getProgramGraph</A>, <A HREF="../analyzer/Program.html#getProgramSectionGraphs()">getProgramSectionGraphs</A>, <A HREF="../analyzer/Program.html#getProgramSectionUnreferencedGraphs()">getProgramSectionUnreferencedGraphs</A>, <A HREF="../analyzer/Program.html#isSymbolDataItem(java.lang.String)">isSymbolDataItem</A>, <A HREF="../analyzer/Program.html#isSymbolDefined(java.lang.String)">isSymbolDefined</A>, <A HREF="../analyzer/Program.html#isSymbolLabel(java.lang.String)">isSymbolLabel</A>, <A HREF="../analyzer/Program.html#isSymbolProcedureInternal(java.lang.String)">isSymbolProcedureInternal</A>, <A HREF="../analyzer/Program.html#isSymbolUnXref(java.lang.String)">isSymbolUnXref</A>, <A HREF="../analyzer/Program.html#pointersToDefinitionsData(java.lang.String)">pointersToDefinitionsData</A>, <A HREF="../analyzer/Program.html#pointersToDefinitionsEnv(java.lang.String)">pointersToDefinitionsEnv</A>, <A HREF="../analyzer/Program.html#pointersToDefinitionsProc(java.lang.String)">pointersToDefinitionsProc</A>, <A HREF="../analyzer/Program.html#setOptionsProgram(java.util.ArrayList)">setOptionsProgram</A>, <A HREF="../analyzer/Program.html#setProgramGraph(analyzer.GraphManager)">setProgramGraph</A>, <A HREF="../analyzer/Program.html#setProgramSectionGraphs(java.util.ArrayList)">setProgramSectionGraphs</A>, <A HREF="../analyzer/Program.html#setProgramSectionUnreferencedGraphs(java.util.ArrayList)">setProgramSectionUnreferencedGraphs</A>, <A HREF="../analyzer/Program.html#symbolAddXrefDataInput(java.lang.String, int, enums.EnumSymbolType)">symbolAddXrefDataInput</A>, <A HREF="../analyzer/Program.html#symbolAddXrefEnvInput(java.lang.String, int, enums.EnumSymbolType)">symbolAddXrefEnvInput</A>, <A HREF="../analyzer/Program.html#symbolAddXrefProcInput(java.lang.String, int, enums.EnumSymbolType)">symbolAddXrefProcInput</A>, <A HREF="../analyzer/Program.html#symbolAddXrefProcOutput(java.lang.String, int, enums.EnumSymbolType)">symbolAddXrefProcOutput</A>, <A HREF="../analyzer/Program.html#symbolCreate(java.lang.String, enums.EnumSymbolType)">symbolCreate</A>, <A HREF="../analyzer/Program.html#symbolDefinitionAddData(java.lang.String, int, enums.EnumSymbolType)">symbolDefinitionAddData</A>, <A HREF="../analyzer/Program.html#symbolDefinitionAddEnv(java.lang.String, int, enums.EnumSymbolType)">symbolDefinitionAddEnv</A>, <A HREF="../analyzer/Program.html#symbolDefinitionAddProc(java.lang.String, int, enums.EnumSymbolType)">symbolDefinitionAddProc</A>, <A HREF="../analyzer/Program.html#symbolType(java.lang.String)">symbolType</A>, <A HREF="../analyzer/Program.html#symbolTypes(java.lang.String)">symbolTypes</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ProgramCobol(analyzer.SystemDefaults)"><!-- --></A><H3>
ProgramCobol</H3>
<PRE>
public <B>ProgramCobol</B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd)</PRE>
<DL>
<DD>Costruttore 1
<P>
</DL>
<HR>

<A NAME="ProgramCobol(analyzer.SystemDefaults, java.lang.String)"><!-- --></A><H3>
ProgramCobol</H3>
<PRE>
public <B>ProgramCobol</B>(<A HREF="../analyzer/SystemDefaults.html" title="class in analyzer">SystemDefaults</A>&nbsp;sd,
                    java.lang.String&nbsp;programName)</PRE>
<DL>
<DD>Costruttore 2
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getLogicInfoDynamic()"><!-- --></A><H3>
getLogicInfoDynamic</H3>
<PRE>
public <A HREF="../analyzer/LogicInfoDynamic.html" title="class in analyzer">LogicInfoDynamic</A> <B>getLogicInfoDynamic</B>()</PRE>
<DL>
<DD>Restituisce l'oggetto LogicInfoDynamic con le informazioni 
 sulle istruzioni dinamiche, le trasformazioni dei campi, i valori rilevati
 e le eventuali ultime assegnazioni ancora da risolvere.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the logicInfoDynamic</DL>
</DD>
</DL>
<HR>

<A NAME="setLogicInfoDynamic(analyzer.LogicInfoDynamic)"><!-- --></A><H3>
setLogicInfoDynamic</H3>
<PRE>
public void <B>setLogicInfoDynamic</B>(<A HREF="../analyzer/LogicInfoDynamic.html" title="class in analyzer">LogicInfoDynamic</A>&nbsp;logicInfoDynamic)</PRE>
<DL>
<DD>Imposta l'oggetto LogicInfoDynamic con le informazioni 
 sulle istruzioni dinamiche, le trasformazioni dei campi, i valori rilevati
 e le eventuali ultime assegnazioni ancora da risolvere.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>logicInfoDynamic</CODE> - the logicInfoDynamic to set</DL>
</DD>
</DL>
<HR>

<A NAME="addEntryIdentification(analyzer.ProgramCobolEntry)"><!-- --></A><H3>
addEntryIdentification</H3>
<PRE>
public int <B>addEntryIdentification</B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;identificationEntry)</PRE>
<DL>
<DD>Inserisce un entry di identificastion division del programma<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ProgramCobolEntry</CODE> - dataInstructionEntry
<DT><B>Returns:</B><DD>Int pointer a elemento inserito</DL>
</DD>
</DL>
<HR>

<A NAME="addEntryEnvironment(analyzer.ProgramCobolEntry)"><!-- --></A><H3>
addEntryEnvironment</H3>
<PRE>
public int <B>addEntryEnvironment</B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;environmentEntry)</PRE>
<DL>
<DD>Inserisce un entry di environment division del proframma<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ProgramCobolEntry</CODE> - dataInstructionEntry
<DT><B>Returns:</B><DD>Int pointer a elemento inserito</DL>
</DD>
</DL>
<HR>

<A NAME="addEntryData(analyzer.ProgramCobolEntry)"><!-- --></A><H3>
addEntryData</H3>
<PRE>
public int <B>addEntryData</B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;dataDefinitionEntry)</PRE>
<DL>
<DD>Inserisce un entry di definizione dati del programma.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ProgramCobolEntry</CODE> - dataDefinitionEntry
<DT><B>Returns:</B><DD>Int pointer a elemento inserito</DL>
</DD>
</DL>
<HR>

<A NAME="addEntryProcedure(analyzer.ProgramCobolEntry)"><!-- --></A><H3>
addEntryProcedure</H3>
<PRE>
public int <B>addEntryProcedure</B>(<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&nbsp;instructionEntry)</PRE>
<DL>
<DD>Inserisce un entry di definizione istruzione del programma<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ProgramCobolEntry</CODE> - dataInstructionEntry
<DT><B>Returns:</B><DD>Int pointer a elemento inserito</DL>
</DD>
</DL>
<HR>

<A NAME="getCopyNested()"><!-- --></A><H3>
getCopyNested</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getCopyNested</B>()</PRE>
<DL>
<DD>Restituisce i copy nested presenti nel programma.<br>
 <p>
 Si tratta sia dei copy chiamanti sia dei copy chiamati.<br>
 <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the set_CopyNested</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyNested(java.util.Set)"><!-- --></A><H3>
setCopyNested</H3>
<PRE>
public void <B>setCopyNested</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyNested)</PRE>
<DL>
<DD>Restituisce i copy nested presenti nel programma.<br>
 <p>
 Si tratta sia dei copy chiamanti sia dei copy chiamati.<br>
 <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set_CopyNested</CODE> - the set_CopyNested to set</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeCopyData()"><!-- --></A><H3>
deadCodeCopyData</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>deadCodeCopyData</B>()</PRE>
<DL>
<DD>Restituisce l'elenco dei copy non utilizzati in data Division.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> con i nomi dei copy</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeCopyProc()"><!-- --></A><H3>
deadCodeCopyProc</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>deadCodeCopyProc</B>()</PRE>
<DL>
<DD>Restituisce l'elenco dei copy non utilizzati in Procedure Division.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> con i nomi dei copy</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeSections()"><!-- --></A><H3>
deadCodeSections</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>deadCodeSections</B>()</PRE>
<DL>
<DD>Restituisce l'elenco delle section di Procedure Division definite e non richiamate,<br>
 oppure richiamate da anche indirettamente da una section dead code.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> con i nomi delle section</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeParagraphs()"><!-- --></A><H3>
deadCodeParagraphs</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>deadCodeParagraphs</B>()</PRE>
<DL>
<DD>Restituisce l'elenco dei paragraphi di Procedure Division definiti e non richiamati.<br>
 <p>
 Amrita identifica un paragrafo come tale a fronte di una perform o di una perform thru.<br>
 La fine del paragrafo viene delimitata dalla label di <tt>thru</tt> esplicita o dalla <br>
 prima label dopo quella oggetto di perform.<br>
 Formalmente la label di uscita dovrebbe essere seguita dallo statement <tt>EXIT</tt><br>
 <p>
 Pertanto NON dovrebbero esserci paragrafi dead code in quanto rientrano nella categoria 
 di label non referenziate.<br>
 <p>
 Tuttavia paragrafi formalmente definiti e terminati da <tt>EXIT</t> possono essere definiti
 e non più richiamati a fronte di successive manutenzioni.<br>
 <p>
 Questo metodo individua i paragrafi formali terminati da <tt>EXIT</tt> e verifica se vengono
 richiamati da qualche perform. Se non sono richiamati li restituisce come dead paragraphs.<br>
 <p>
 Vengono presi in considerazione solo i paragrafi definiti fuori dalle section.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> con i nomi dei paragrafi</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeDataItemNumbers()"><!-- --></A><H3>
deadCodeDataItemNumbers</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>deadCodeDataItemNumbers</B>()</PRE>
<DL>
<DD>Restituisce l'elenco dei numeri di definizione dati dead code in Data Division.<br> 
 <p>
 Si tratta di definizioni dati non referenziate nemmeno indirettamente, attraverso campi<br>
 redefines o di gruppo.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<Integer> con i numeri delle definizioni dei campi dead code in data division</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeLabels()"><!-- --></A><H3>
deadCodeLabels</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>deadCodeLabels</B>()</PRE>
<DL>
<DD>Restituisce l'elenco delle label di Procedure Division definite e non referenziate.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<String> con i nomi delle section</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeUnreachable()"><!-- --></A><H3>
deadCodeUnreachable</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>deadCodeUnreachable</B>()</PRE>
<DL>
<DD>Restituisce i numeri di istruzione di codice morto, non raggiungibile fisicamente.<br> 
 <p>
 Non vengono restituite le istruzioni dentro section che sono già dead code<br>
 ma solo quelle non raggiungibili, collocate dopo istruzioni goTo o Xctl o comunque<br>
 istruzioni di interruzione del flusso di esecuzione, non precedute da label referenziate<br>
 <p>
 L'individuazione del codice morto e del codice morto non raggiungibile viene effettuata<br>
 nelle operazioni finali di analisi del programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<Integer> con i numeri delle istruzioni dead code NON raggiumgibili</DL>
</DD>
</DL>
<HR>

<A NAME="deadCodeInstrNumbers()"><!-- --></A><H3>
deadCodeInstrNumbers</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>deadCodeInstrNumbers</B>()</PRE>
<DL>
<DD>Restituisce i numeri di istruzione di codice morto.<br> 
 <p>
 Vengono restituite anche le istruzioni dead code non raggiungibili ottenibili con il metodo <br>
 <tt>deadCodeUnreachable()</tt><br>
 <p>
 L'individuazione del codice morto e del codice morto non raggiungibile viene effettuata<br>
 nelle operazioni finali di analisi del programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<Integer> con i numeri delle istruzioni dead code</DL>
</DD>
</DL>
<HR>

<A NAME="entriesIdentification()"><!-- --></A><H3>
entriesIdentification</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[] <B>entriesIdentification</B>()</PRE>
<DL>
<DD>Restituisce tutte le istruzioni di identification division del programma.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ProgramCobolEntry<?>[]</DL>
</DD>
</DL>
<HR>

<A NAME="entriesEnvironment()"><!-- --></A><H3>
entriesEnvironment</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[] <B>entriesEnvironment</B>()</PRE>
<DL>
<DD>Restituisce tutte le istruzioni di environment division del programma.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ProgramCobolEntry<?>[]</DL>
</DD>
</DL>
<HR>

<A NAME="entriesData()"><!-- --></A><H3>
entriesData</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[] <B>entriesData</B>()</PRE>
<DL>
<DD>Restituisce tutte le definizioni di data division del programma.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ProgramCobolEntry<?>[]</DL>
</DD>
</DL>
<HR>

<A NAME="entriesProcedure()"><!-- --></A><H3>
entriesProcedure</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;[] <B>entriesProcedure</B>()</PRE>
<DL>
<DD>Restituisce tutte le istruzioni di procedure division del programma.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ProgramCobolEntry<?>[]</DL>
</DD>
</DL>
<HR>

<A NAME="optimize()"><!-- --></A><H3>
optimize</H3>
<PRE>
public void <B>optimize</B>()</PRE>
<DL>
<DD>Operazioni finali di consolidamento delle strutture interne.<br> 
 Gli ArrayList con le definizioni dati e istruzioni vengono trimmati alle dimensioni effettive<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="callersStackInfo(int)"><!-- --></A><H3>
callersStackInfo</H3>
<PRE>
public <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A> <B>callersStackInfo</B>(int&nbsp;numInstrTo)</PRE>
<DL>
<DD>Fornisce informazioni sulle procedure interne chiamanti ricorsivamente.<br>
 <p>
 A partire da un numero di istruzione, situata in una procedura interna
 codificata in un sottografo, restituisce un array list di oggetti descriventi
 la procedura chiamante, con il numero di istruzione di perform e di
 inizio procedura.<br>
 L'ultimo oggetto dell'ArrayList deve fare riferimento a una istruzione di
 richiamo situata nella mainline.<br>
 Con questo metodo si individuano tutte le procedure interne implicate
 direttamente nel processo ricorsivo di richiamo ma NON quelle indirette.<br>
 Le procedure richiamate fra inizio procedura e l'istruzione di perform,
 non vengono prese in considerazione.<br>
 In questa fase interessa esclusivamente la catena di chiamanti diretta.<br>
 <p>
 Questo metodo viene utilizzato da <A HREF="../analyzer/LogicManager.html" title="class in analyzer"><CODE>LogicManager</CODE></A> per determinare tutti
 i sottografi chiamanti, per la disabilitazione degli archi di grafo ininfluenti.<br>
 <p>
 Vengono restituiti oggetti <CODE>InnerInfoSubGraphCaller</CODE> con le informazioni
 richieste.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numero</CODE> - istruzione
<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="calledStackInfo(analyzer.ProgramCallsStack)"><!-- --></A><H3>
calledStackInfo</H3>
<PRE>
public <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A> <B>calledStackInfo</B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)</PRE>
<DL>
<DD><h3>
 Aggiorna il call entry specifico dello stack di chiamanti con le informazioni su
 tutte le procedure interne <b>chiamate</b> fra l'inizio della procedura interna
 e l'istruzione perform chiamante.<br>
 </h3>
 <p>
 Vengono presi in considerazione tutti i call stack entry chiamanti, ovvero i possibili
 percorsi di richiamo delle procedure interne, fino all'istruzione target.<br>
 Tali informazioni sono state estratte analizzando le possibili procedure chiamanti, 
 a partire dall'istruzione dinamica.<br>
 <p>
 Si tratta di analizzare tutte le perform a procedure interne, poste fra l'istruzione
 di inizio procedura e l'istruzione target e di analizzare ricorsivamente tutte
 le procedure interne richiamate fino al livello di annidamento massimo.<br>
 <p>
 Per ogni procedura richiamata vengono memorizzate l' istruzione di richiamo, il
 sottografo di richiamo, il sottografo richiamato oltre al livello di annidamento.<br>
 
 <p>
 Il processo si effettua per ogni specifico stack di chiamanti, ovvero uno specifico
 percorso di esecuzione che inizia con l'istruzione dinamica e termina con la
 perform chiamante origine, nella mainline.<br>
 <p>
 Il primo entry identifica l'struzione dinamica origine.<br>
 L'ultimo entry identifica la prima istruzione chiamante (perform) nella mainline.<br>
 <p>
 Per ogni entry identificante un chiamante si esaminano le istruzioni precedenti,
 dalla prima istruzione nella procedura fino all'istruzione perform chiamante.<br>
 Se si tratta di una perform si memorizzano gli estremi nella catena dei chiamanti
 e si procede ricorsivamente a livello più annidato.<br>
 <p>
 Al termimne di tutto il processo, per ogni entry chiamante, è disponibile un elenco
 di procedure chiamate, anche ricorsivamente, indicanti il numero di istruzione
 di perform e il livello di anndidamento.<br>
 <p>
 E' quindi possibile ricostruire, con una analisi sequenziali tutti i riferimenti delle
 istruzione chiamate, ai fini della disabilitazione dei path ininfluenti e della
 generazione dei path effettivi, tutti i path din esecuzione effettivi.<br>
 <p>
 I path effettivi vengono quindi sempre generati come come la concatenazione,
 o meglio la moltiplicazione dei singoli path parziali, generati dall'analisi dei 
 chiamanti, che hanno portato all'istruzione dinamica.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>descrittore</CODE> - call stack di programma</DL>
</DD>
</DL>
<HR>

<A NAME="subGraphsWithArcSet(analyzer.ProgramCallsStack, analyzer.GraphArc[])"><!-- --></A><H3>
subGraphsWithArcSet</H3>
<PRE>
public <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A> <B>subGraphsWithArcSet</B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack,
                                             <A HREF="../analyzer/GraphArc.html" title="class in analyzer">GraphArc</A>[]&nbsp;ar_ArcInSetChains)</PRE>
<DL>
<DD>Individuazione, dati gli archi interessati, dei sottografi corrispondenti.<br>
 <p>
 Viene aggiornato l'oggetto  <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer"><CODE>ProgramCallsStack</CODE></A> e restituito al chiamante
 con gli archi in oggetto e con i numeri di istruzione in essi contenuti.
 <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>programCallsStack</CODE> - <DD><CODE>arArcInSetChains</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="pathsIntermediate(analyzer.ProgramCallsStack)"><!-- --></A><H3>
pathsIntermediate</H3>
<PRE>
public <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A> <B>pathsIntermediate</B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)
                                    throws <A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></PRE>
<DL>
<DD><h3>
 Produzione paths parziali per ogni call stack entry di ogni stack entry
 originato da perform chiamanti.<br>
 </h3>
 <p>
 Vengono esaminati tutti i possibili call stack con sequenze di richiamo
 di procedure interne, fino all'istruzione origine nella mainline.<br>
 Per ogni call stack si esaminano tutti i call stack entry.<br>
 Per ogni call stack entry si disabilitano gli archi ininfluenti nella
 procedura chiamante e in quelle chiamate, a qualsiasi livello.<br>
 <p>
 Si generano i path, a questo punto ridotti, fra l'istruzione target e
 la prima istruzione della procedura interna.<br>
 <p>
 Si genera un ulteriore insieme di paths, a partire dai precedenti,
 con tutte le perform espanse.<br>
 <p>
 Si riabilitano nuovamente tutti gli archi per il successivo call stack entry.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../exception/ExceptionAmrita.html" title="class in exception">ExceptionAmrita</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="pathsComplete(analyzer.ProgramCallsStack)"><!-- --></A><H3>
pathsComplete</H3>
<PRE>
public <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A> <B>pathsComplete</B>(<A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer">ProgramCallsStack</A>&nbsp;programCallsStack)</PRE>
<DL>
<DD><h3>
 Produzione paths definitivi come moltiplicazione dei path intermedi, generati
 ai vari livelli di di stack chiamanti.<br>
 </h3>
 <p>
 Vengono esaminati tutti i possibili call stack con sequenze di richiamo
 di procedure interne, fino all'istruzione origine nella mainline.<br>
 <p>
 Un call path rappresenta un possibile percorso di esecuzione dalla mainline
 fino all'istruzione target.<br>
 <p>
 Per ogni call stack si moltiplicano i vari path memorizzati nei singoli
 call path entry, generando un insieme di possibili path di esecuzione.<br>
 <P>
 Si inseriscono i path generati da tutti i call path in una struttura e si restituiscono al chiamante.<br>
 <p>
 Il processo lavora con i path presenti nell'oggetto <A HREF="../analyzer/ProgramCallsStack.html" title="class in analyzer"><CODE>ProgramCallsStack</CODE></A> e pertanto
 sono già stati filtrati dai path ininfluenti al momento della generazione dei path di
 ogni singol call stack entry, per ogni procedura interna incontrata.<br>
 <p>
 Pertanto l'insieme di path restituiti è quello minimale che comunque contiene gli archi
 contenenti istruzioni utili per la soluzione dell'istruzione dinamica o, in generale,
 dell'istruzione target.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNumInstrFirst(java.lang.String)"><!-- --></A><H3>
procInternalNumInstrFirst</H3>
<PRE>
public int <B>procInternalNumInstrFirst</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce il primo numero di istruzione della procedura interna.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero una section o un paragrafo.<br>
 Si restituisce il numero di istruzione di definizione della section o del paragrafo.<br>
 Se la procedura interna non è definita restituisce -1.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nome</CODE> - section/paragrafo</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalInstructionsCaller(java.lang.String)"><!-- --></A><H3>
procInternalInstructionsCaller</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>procInternalInstructionsCaller</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce i numeri di istruzione chiamanti, anche indirettamente, la procedura fornita.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero di una section o un paragrafo.<br>
 Se la procedura interna non è definita restituisce null.<br>
 Si individuano e si accumulano i numeri delle istruzioni chiamanti (perform/goTo).<br>
 Se dentro section/paragrafo si ripete ricorsivamente il processo sulla procedura chiamante.<br>
 Il processo di accumulo termina quando le perform/goTo sono nella mainline.<br>
 <p>
 Al termine del processo sono disponibili un insieme di numeri di istruzione,<br>
 tipicamente perform o goTo, in section o paragrafi anche diversi, che direttamente o <br>
 indirettamente richiamano la procedura interna fornita in input<br>
 <br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nome</CODE> - section/paragrafo
<DT><B>Returns:</B><DD>ArrayList<Integer> instruction caller</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNamesCaller(java.lang.String)"><!-- --></A><H3>
procInternalNamesCaller</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>procInternalNamesCaller</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce i nomi delle procedure interne chiamanti, anche indirettamente, la procedura fornita.<br>
 <p>
 Si tratta di tutte le section o paragrafi che direttamente o indirettamene, a qualsiasi livllo,<br>
 richiamano la procedura fornita in input.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero di una section o un paragrafo.<br>
 Se la procedura interna non è definita restituisce null.<br>
 Si individuano i numeri delle istruzioni chiamanti (perform/goTo).<br>
 Se in section/paragrafo di accumulano i nomi e si ripete ricorsivamente il processo sulla procedura chiamante.<br>
 Il processo di accumulo termina quando le perform/goTo sono nella mainline.<br>
 <p>
 Al termine del processo sono disponibili un insieme di nomi di section e/o paragrafi,<br>
 che direttamente o indirettamente richiamano la procedura interna fornita in input<br>
 <br>
 Se richiamo dalla mainline viene restituito come nome procedura == MAINLINE ==<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nome</CODE> - section/paragrafo
<DT><B>Returns:</B><DD>ArrayList<String> proc internal caller</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNamesCalledDirect(java.lang.String)"><!-- --></A><H3>
procInternalNamesCalledDirect</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>procInternalNamesCalledDirect</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce i nomi di tutte le procedure interne richiamate dalla procedura fornita direttamente.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero una section o un paragrafo.<br>
 Vengono esaminate tutte le istruzioni e per ogni perform si intabella la procedura interna richiamata.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section/paragrafo</CODE> - di partenza</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNamesCalledAll(java.lang.String)"><!-- --></A><H3>
procInternalNamesCalledAll</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>procInternalNamesCalledAll</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce i nomi di tutte le procedure interne richiamate dalla procedura fornita direttamente o ricorsivamente.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero una section o un paragrafo.<br>
 Vengono esaminate tutte le istruzioni e per ogni perform si intabella la procedura interna richiamata e
 si procede ricorsivamente.<br>
 Nel caso di richiamo ricorsivo della stessa procedura interna, si intabella se la procedura interna
 è la stessa di quella di partenza e si torna backward nel processo ricorsivo.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section/paragrafo</CODE> - di partenza</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNamesCalledPopulateMap()"><!-- --></A><H3>
procInternalNamesCalledPopulateMap</H3>
<PRE>
public void <B>procInternalNamesCalledPopulateMap</B>()</PRE>
<DL>
<DD>Per ogni procedura interna, ovvero section o paragrafo, si aggiorna l'elenco delle procedure chiamate direttamente.<br>
 <p>
 Questo metodo viene richiamato a fine analisi sorgente prima del calcolo delle violazioni delle metriche.<br>
 Si recuperano tutte le procedure interne definite, ovvero tuute le section e tutti i paragrafi richiamati con perform.<br>
 Si esamina ogni istruzione e in particolare ogni perform.
 Si estrae il nome della section/paragrafo performato e si accoda nell'ArrayList di lavoro.<br>
 Si aggiorna la map delle procedure interne con l'elenco delle procedure richiamate.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section/paragrafo</CODE> - di partenza</DL>
</DD>
</DL>
<HR>

<A NAME="isProcInternalNameRecursiveCalled(java.lang.String)"><!-- --></A><H3>
isProcInternalNameRecursiveCalled</H3>
<PRE>
public boolean <B>isProcInternalNameRecursiveCalled</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce se la procedura interna fornita richiama ricorsivamente se stessa.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero una section o un paragrafo.<br>
 Si verifica se la procedura interna richiama ricorsivamente se stessa.<br>
 Si tratta di una anomalia<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section/paragrafo</CODE> - di partenza</DL>
</DD>
</DL>
<HR>

<A NAME="isProcInternalLoopPerformed(java.lang.String)"><!-- --></A><H3>
isProcInternalLoopPerformed</H3>
<PRE>
public boolean <B>isProcInternalLoopPerformed</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce se la procedura interna è richiamata a fronte di un loop.<br>
 <p>
 Viene fornito il nome di una procedura interna, ovvero una section o un paragrafo.<br>
 Se la procedura interna non è definita restituisce false<br>
 Si verifica se la procedura interna viene richiamata esplicitamente con perform varying until<br>
 Si verifica se la procedura interna viene richiamata indirettamente con perform varying until,<br>
 -  per esempio da section o paragrafi a loro volta richiamati con perform varying until<br>
 Si verifica se la procedura è richiamata, anche indirettamente, da una perform inner<br>
 <p>
 In caso affermativo si restituisce true<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section/paragrafo</CODE> - di partenza
<DT><B>Returns:</B><DD>Boolean loopPerformed</DL>
</DD>
</DL>
<HR>

<A NAME="isEntryDataItem(int)"><!-- --></A><H3>
isEntryDataItem</H3>
<PRE>
public boolean <B>isEntryDataItem</B>(int&nbsp;entryPointer)</PRE>
<DL>
<DD>Restiuisce true se l'entry rappresenta una definizione dati<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - int entryPointer
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è una definizione dati</DL>
</DD>
</DL>
<HR>

<A NAME="isEntryLabel(int)"><!-- --></A><H3>
isEntryLabel</H3>
<PRE>
public boolean <B>isEntryLabel</B>(int&nbsp;entryPointer)</PRE>
<DL>
<DD>Restiuisce true se l'entry rappresenta una label di procedure division<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - int symbolPointer
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è una label</DL>
</DD>
</DL>
<HR>

<A NAME="isEntrySection(int)"><!-- --></A><H3>
isEntrySection</H3>
<PRE>
public boolean <B>isEntrySection</B>(int&nbsp;entryPointer)</PRE>
<DL>
<DD>Restiuisce true se l'entry rappresenta una Section di procedure division<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - entryPointer
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è una label</DL>
</DD>
</DL>
<HR>

<A NAME="isInstructionUnderSection(int, int)"><!-- --></A><H3>
isInstructionUnderSection</H3>
<PRE>
public boolean <B>isInstructionUnderSection</B>(int&nbsp;instructionPointer,
                                         int&nbsp;underSectionPointer)</PRE>
<DL>
<DD>Restituisce true se l'istruzione è definita all'interno della Section fornita in input<br> 
 <p>
 Se il pointer all'istruzione è errato o la Section non è definita oppure l'istruzione non è
 definita al suo interno, si restituisce false.<br>
 Il pointer alla definizione della section nel programma si può ottenere con il metodo<b> int sectionDefinition()</b>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - instructionPointer<DD><CODE>int</CODE> - underSectionPointer
<DT><B>Returns:</B><DD>boolean true se l'istruzione è definita all'interno della section</DL>
</DD>
</DL>
<HR>

<A NAME="isInstructionUnderCondition(int)"><!-- --></A><H3>
isInstructionUnderCondition</H3>
<PRE>
public boolean <B>isInstructionUnderCondition</B>(int&nbsp;instructionPointer)</PRE>
<DL>
<DD>Restituisce true se l'istruzione è definita in un ramo di una istruzione condizionale<br> 
 <p>
 Se il pointer all'istruzione è errato oppure l'istruzione non è
 definita al suo interno, si restituisce false.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - instructionPointer
<DT><B>Returns:</B><DD>boolean true se l'istruzione è definita sotto condizione</DL>
</DD>
</DL>
<HR>

<A NAME="isSectionReferenced(java.lang.String)"><!-- --></A><H3>
isSectionReferenced</H3>
<PRE>
public boolean <B>isSectionReferenced</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restiuisce true se la Section è in input in qualche istruzione di procedure division<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è in input a qualche istruzione</DL>
</DD>
</DL>
<HR>

<A NAME="isLabel(java.lang.String)"><!-- --></A><H3>
isLabel</H3>
<PRE>
public boolean <B>isLabel</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Restiuisce true se il nome fornito in input è quello di una label<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - labelname
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è in input a qualche istruzione</DL>
</DD>
</DL>
<HR>

<A NAME="isParagraph(java.lang.String)"><!-- --></A><H3>
isParagraph</H3>
<PRE>
public boolean <B>isParagraph</B>(java.lang.String&nbsp;idParagraph)</PRE>
<DL>
<DD>Restituisce true se il nome fornito in input è quello di un paragrafo cobol<br> 
 <p>
 Un paragrafo è una label oggetto di uno statement perform<br>
 oppure dichuarata nella sezione DECLARATIVES oppure semplicemente<br>
 seguita da altri statement, una label di chiusura e terminato con exit<br>
 <p>
 L'indicazione se una label sia o meno un paragrafo viene imnposta a fine<br>
 analisi sorgente e viene aggiornata l'istruzione label con le informazioni<br>
 del paragrafo.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - paragraphName
<DT><B>Returns:</B><DD>boolean true se il simbolo è il nome di un paragrafo</DL>
</DD>
</DL>
<HR>

<A NAME="isSection(java.lang.String)"><!-- --></A><H3>
isSection</H3>
<PRE>
public boolean <B>isSection</B>(java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Restiuisce true se il nome fornito in input è quello di una section cobol<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>boolean true se il simbolo è il nome di una section</DL>
</DD>
</DL>
<HR>

<A NAME="isLabelReferenced(java.lang.String)"><!-- --></A><H3>
isLabelReferenced</H3>
<PRE>
public boolean <B>isLabelReferenced</B>(java.lang.String&nbsp;labelName)</PRE>
<DL>
<DD>Restiuisce true se la label è referenziata in qualche istruzione di procedure division<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name
<DT><B>Returns:</B><DD>boolean true se il simbolo esiste ed è in input a qualche istruzione</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemInputForAnyData(java.lang.String)"><!-- --></A><H3>
isDataItemInputForAnyData</H3>
<PRE>
public boolean <B>isDataItemInputForAnyData</B>(java.lang.String&nbsp;dataName)</PRE>
<DL>
<DD>Restituisce true se il data item è referenziato da qualche altro data item.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name
<DT><B>Returns:</B><DD>boolean true se il simbolo è referenziato da qualche altro data item</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemUsedByAnyProcInstr(java.lang.String, java.lang.String)"><!-- --></A><H3>
isDataItemUsedByAnyProcInstr</H3>
<PRE>
public boolean <B>isDataItemUsedByAnyProcInstr</B>(java.lang.String&nbsp;dataName,
                                            java.lang.String&nbsp;typeUseDataItem)</PRE>
<DL>
<DD>Restituisce true se il data item è referenziato in input o in output da qualche istruzione<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name<DD><CODE>String</CODE> - typeUseDataItem che può valere INSTR_USE_DATA_ITEM_INPUT/INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>boolean true se il simbolo è referenziato in input da qualche istruzione</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemUsedByAnyProcInstrImplicit(int, java.lang.String)"><!-- --></A><H3>
isDataItemUsedByAnyProcInstrImplicit</H3>
<PRE>
public boolean <B>isDataItemUsedByAnyProcInstrImplicit</B>(int&nbsp;pointerDataName,
                                                    java.lang.String&nbsp;typeUseDataItem)</PRE>
<DL>
<DD>Restituisce true se il data item è referenziato direttamente o indirettamente 
 in input o in output da qualche istruzione<br> 
 <p>
 Si considerano i riferimenti al data item, alle sue ridefinizioni ai suoi campi
 rinominati e a tutti i gruppi sotto il quale il data item è definito.<br>
 Nel caso dei gruppi si considerano tutte le assegnazioni di move con reference
 modification alla posizione che aggiorna il data item.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - pointer data name<DD><CODE>String</CODE> - typeUseDataItem che può valere INSTR_USE_DATA_ITEM_INPUT/INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>boolean true se il simbolo è referenziato in input da qualche istruzione</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemUnderGroupName(int, java.lang.String)"><!-- --></A><H3>
isDataItemUnderGroupName</H3>
<PRE>
public boolean <B>isDataItemUnderGroupName</B>(int&nbsp;definitionPointer,
                                        java.lang.String&nbsp;underGroup)</PRE>
<DL>
<DD>Restituisce true se il data item è definito immediatamente sotto il campo di gruppo fornito.<br> 
 In pratica il gruppo fornito è owner diretto per il data item.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer<DD><CODE>String</CODE> - group name
<DT><B>Returns:</B><DD>boolean true se il data item è definito sotto il gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemUnderGroupNameAnyLevel(int, java.lang.String)"><!-- --></A><H3>
isDataItemUnderGroupNameAnyLevel</H3>
<PRE>
public boolean <B>isDataItemUnderGroupNameAnyLevel</B>(int&nbsp;definitionPointer,
                                                java.lang.String&nbsp;underGroup)</PRE>
<DL>
<DD>Restituisce true se il data item è definito sotto il campo di gruppo fornito.<br> 
 <p>
 Il gruppo fornito potrebbe essere non già quello sotto il quale il data item è definito,<br>
 ma anche a un livello più alto, con numero di livello inferiore, sotto il quale
 il campoo è definito.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer<DD><CODE>String</CODE> - group name
<DT><B>Returns:</B><DD>boolean true se il data item è definito sotto il gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemGroupWithBynaryFields(int)"><!-- --></A><H3>
isDataItemGroupWithBynaryFields</H3>
<PRE>
public boolean <B>isDataItemGroupWithBynaryFields</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce true se il data item, di gruppo, contiene dei sottocampi binari.<br> 
 <p>
 Questa funzione è utile in particolare nei servizi di re-hosting per individuare
 i campi binari dei files utilizzati.<br>
 Per binario si intende un campo <b>binario</b>, <b>packed</b> o <b>floating point</b>.
 <p>
 Se il pointer del campo fornito è out of range , restituisce false.<br>
 Se il pointer del campo fornito non è di un campo cobol, restituisce false.<br>
 Se il pointer del campo fornito è di un campo cobol elementare, restituisce false.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>the</CODE> - definitionPointer<DD><CODE>the</CODE> - group name<br>
<DT><B>Returns:</B><DD>true se il data item è definito sotto il gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="isDataItemTableElement(int)"><!-- --></A><H3>
isDataItemTableElement</H3>
<PRE>
public boolean <B>isDataItemTableElement</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce true se il data item è un elemento di una tabella definita con occurs.<br> 
 <p>
 Il data item potrebbe essere un campo elementare con picture e occurs dichiarate,<br>
 oppure puo' essere un campo di un elemento di gruppo occursato.<br>
 L'elemento di gruppo può essere direttamente occursato o fare parte di un gruppo di
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>boolean true se il data item appartiene a un elemento di tabella.</DL>
</DD>
</DL>
<HR>

<A NAME="isDecimalPointComma()"><!-- --></A><H3>
isDecimalPointComma</H3>
<PRE>
public boolean <B>isDecimalPointComma</B>()</PRE>
<DL>
<DD>Restituisce true se il programma, negli Special-Names,
 ha la clausola Decimal Point Is Comma.<br>
 In questo caso i valori numerici utilizzano la virgola
 per indicare il punto decimale e il punto per le migliaia.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isDecimalPointComma</DL>
</DD>
</DL>
<HR>

<A NAME="setDecimalPointComma(boolean)"><!-- --></A><H3>
setDecimalPointComma</H3>
<PRE>
public void <B>setDecimalPointComma</B>(boolean&nbsp;isDecimalPointComma)</PRE>
<DL>
<DD>Imposta se se il programma, negli Special-Names,
 ha la clausola Decimal Point Is Comma.<br>
 In questo caso i valori numerici utilizzano la virgola
 per indicare il punto decimale e il punto per le migliaia.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isDecimalPointComma</CODE> - the isDecimalPointComma to set</DL>
</DD>
</DL>
<HR>

<A NAME="isAlphabetEbcdic()"><!-- --></A><H3>
isAlphabetEbcdic</H3>
<PRE>
public boolean <B>isAlphabetEbcdic</B>()</PRE>
<DL>
<DD>Restituisce true se se il programma, negli Special-Names,
 ha la clausola ALPHABET diversa da EBCDIC.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isAlphabetEbcdic</DL>
</DD>
</DL>
<HR>

<A NAME="setAlphabetEbcdic(boolean)"><!-- --></A><H3>
setAlphabetEbcdic</H3>
<PRE>
public void <B>setAlphabetEbcdic</B>(boolean&nbsp;isAlphabetEbcdic)</PRE>
<DL>
<DD>Imposta se il programma, negli Special-Names,
 ha la clausola ALPHABET diversa da EBCDIC.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isAlphabetEbcdic</CODE> - the isAlphabetEbcdic to set</DL>
</DD>
</DL>
<HR>

<A NAME="getProgramId()"><!-- --></A><H3>
getProgramId</H3>
<PRE>
public java.lang.String <B>getProgramId</B>()</PRE>
<DL>
<DD>Restituisce il nome del programma codificato in PROGRAM-ID.<br>
 Può essere diverso dal nome del programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the programId</DL>
</DD>
</DL>
<HR>

<A NAME="setProgramId(java.lang.String)"><!-- --></A><H3>
setProgramId</H3>
<PRE>
public void <B>setProgramId</B>(java.lang.String&nbsp;programId)</PRE>
<DL>
<DD>Imposta il nome del programma codificato in PROGRAM-ID.<br>
 Può essere diverso dal nome del programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>programId</CODE> - the programId to set</DL>
</DD>
</DL>
<HR>

<A NAME="isCicsProgram()"><!-- --></A><H3>
isCicsProgram</H3>
<PRE>
public boolean <B>isCicsProgram</B>()</PRE>
<DL>
<DD>Restituisce se il programma contiene istruzioni Cics.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isCicsProgram</DL>
</DD>
</DL>
<HR>

<A NAME="setCicsProgram(boolean)"><!-- --></A><H3>
setCicsProgram</H3>
<PRE>
public void <B>setCicsProgram</B>(boolean&nbsp;isCicsProgram)</PRE>
<DL>
<DD>Imposta se il programma contiene istruzioni Cics.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isCicsProgram</CODE> - the isCicsProgram to set</DL>
</DD>
</DL>
<HR>

<A NAME="isSqlProgram()"><!-- --></A><H3>
isSqlProgram</H3>
<PRE>
public boolean <B>isSqlProgram</B>()</PRE>
<DL>
<DD>Restituisce se il programma contiene istruzioni Sql.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isSqlProgram</DL>
</DD>
</DL>
<HR>

<A NAME="setSqlProgram(boolean)"><!-- --></A><H3>
setSqlProgram</H3>
<PRE>
public void <B>setSqlProgram</B>(boolean&nbsp;isSqlProgram)</PRE>
<DL>
<DD>Imèpsta se il programma contiene istruzioni Sql.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isSqlProgram</CODE> - the isSqlProgram to set</DL>
</DD>
</DL>
<HR>

<A NAME="isDl1Program()"><!-- --></A><H3>
isDl1Program</H3>
<PRE>
public boolean <B>isDl1Program</B>()</PRE>
<DL>
<DD>Restituisce se il programma contiene istruzioni Dl1.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isDl1Program</DL>
</DD>
</DL>
<HR>

<A NAME="setDl1Program(boolean)"><!-- --></A><H3>
setDl1Program</H3>
<PRE>
public void <B>setDl1Program</B>(boolean&nbsp;isDl1Program)</PRE>
<DL>
<DD>Imposta se il programma contiene istruzioni Dl1.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isDl1Program</CODE> - the isDl1Program to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSpecialNamesInfo()"><!-- --></A><H3>
getSpecialNamesInfo</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A> <B>getSpecialNamesInfo</B>()</PRE>
<DL>
<DD>Restituisce l'istruzione completa di environment division che descrive
 il paragrafo special-names, con informazioni punto decimale, alfabeto,
 currency etc.<br>
 Se il paragrafo non è presente resrtituisce null.<br>
 L'istruzione fornisce tutti i metodi per recuperare le informazioni.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>InstructionCobolEnvironment the specialNames</DL>
</DD>
</DL>
<HR>

<A NAME="setSpecialNamesInfo(analyzer.InstructionCobolEnvironment)"><!-- --></A><H3>
setSpecialNamesInfo</H3>
<PRE>
public void <B>setSpecialNamesInfo</B>(<A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A>&nbsp;specialNames)</PRE>
<DL>
<DD>Imposta l'istruzione completa di environment division che descrive
 il paragrafo special-names, con informazioni punto decimale, alfabeto,
 currency etc.<br>
 L'istruzione fornisce tutti i metodi per recuperare le informazioni.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>InstructionCobolEnvironment</CODE> - specialNames the specialNames to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectStatement(java.lang.String)"><!-- --></A><H3>
getSelectStatement</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobolEnvironment.html" title="class in analyzer">InstructionCobolEnvironment</A> <B>getSelectStatement</B>(java.lang.String&nbsp;fileName)</PRE>
<DL>
<DD>Restituisce l'istruzione Select di environment division relativa <br>
 al nome interno del file fornito in input;
 <p>
 Se non viene trovata una select per il file fornito restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>InstructionCobolEnvironment the specialNames</DL>
</DD>
</DL>
<HR>

<A NAME="sectionPointer(java.lang.String)"><!-- --></A><H3>
sectionPointer</H3>
<PRE>
public int <B>sectionPointer</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce il puntatore alla definizione della section<br> 
 <p>
 Coincide coincide con il numero dell'istruzione.
 Se la Section non è definita restituisce -1.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - Section name
<DT><B>Returns:</B><DD>int con la posizione della section nelle istruzioni del programma</DL>
</DD>
</DL>
<HR>

<A NAME="labelPointer(java.lang.String)"><!-- --></A><H3>
labelPointer</H3>
<PRE>
public int <B>labelPointer</B>(java.lang.String&nbsp;labelName)</PRE>
<DL>
<DD>Restituisce il puntatore alla definizione della label<br> 
 <p>
 Coincide coincide con il numero dell'istruzione.
 Se la Label non è definita restituisce -1.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - Label name
<DT><B>Returns:</B><DD>int con la posizione della Label nelle istruzioni del programma</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalPointer(java.lang.String)"><!-- --></A><H3>
procInternalPointer</H3>
<PRE>
public int <B>procInternalPointer</B>(java.lang.String&nbsp;idProcInternal)</PRE>
<DL>
<DD>Restituisce il puntatore alla definizione della section o del paragrafo<br> 
 <p>
 Coincide coincide con il numero dell'istruzione.
 Se la procedura interna  non è definita restituisce -1.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - proc internal name
<DT><B>Returns:</B><DD>int con il numero di definizione della procedura interna</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNameOwner(int)"><!-- --></A><H3>
procInternalNameOwner</H3>
<PRE>
public java.lang.String <B>procInternalNameOwner</B>(int&nbsp;numInstr)</PRE>
<DL>
<DD>Restituisce il nome della section o del paragrafo sotto la quale è collocato il numero di istruzione<br> 
 <p>
 In caso di istruzione nella mainline del programma restituisce <br>
 la stringa "== MAINLINE =="<br>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numInstr
<DT><B>Returns:</B><DD>String con nome section o paragrafo</DL>
</DD>
</DL>
<HR>

<A NAME="labelPointers(java.lang.String)"><!-- --></A><H3>
labelPointers</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>labelPointers</B>(java.lang.String&nbsp;labelName)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizione della label<br> 
 <p>
 Normalmente una label è definito una sola volta ma<br> 
 può essere definita con lo stesso nome in section Cobol<br> 
 differenti.<br> 
 Si restituiscono i numeri delle istruzioni di definizione<br> 
 <p>
 Se la Label non è definita restituisce un array list vuoto.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - Label name
<DT><B>Returns:</B><DD>int con la posizione della Label nelle istruzioni del programma</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemDefinition(int)"><!-- --></A><H3>
dataItemDefinition</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A> <B>dataItemDefinition</B>(int&nbsp;numInstrDef)</PRE>
<DL>
<DD>Restituisce l'istruzione di definizione del data item.<br> 
 <p>
 Viene fornito il numero di entry di programma di Data Division.<br>
 Viene recuperato l'entry di programma con tale numero e restituita
 l'istruzione di definizione il cui reference è memorizzato all'interno.<br>
 Il numero dell'entry coincide con il numero dell'istruzione.<br>
 In caso di chiamata errata, a causa di numero istruzione out of range o
 entry di programma NON contenente una istruzione di definizione dati,
 viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numInstrDef
<DT><B>Returns:</B><DD>InstructionCobolDataItem con istruzione di definizione dati</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemPointer(java.lang.String, java.lang.String)"><!-- --></A><H3>
dataItemPointer</H3>
<PRE>
public java.lang.Integer <B>dataItemPointer</B>(java.lang.String&nbsp;dataName,
                                         java.lang.String&nbsp;underGroup)</PRE>
<DL>
<DD>Restituisce il puntatore alla definizione dati del data item qualificato<br> 
 <p>
 Viene cercato il data item che è definito sotto il campo di gruppo fornito.<br> 
 Se non esiste il gruppo viene restituito null.<br> 
 Se il campo di gruppo fornito non è un gruppo viene restituito -1.<br> 
 Se non esiste la definizione sotto il gruppo viene restituito -1.<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name<DD><CODE>String</CODE> - group name
<DT><B>Returns:</B><DD>int con il numeri di definizione del data itemqualificato</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemPointers(java.lang.String)"><!-- --></A><H3>
dataItemPointers</H3>
<PRE>
public int[] <B>dataItemPointers</B>(java.lang.String&nbsp;dataName)</PRE>
<DL>
<DD>Restituisce i puntatori alla definizione dati nel programma, di data item con il nome fornito in input.<br> 
 <p>
 Un data item con lo stesso nome potrebbe essere definito in strutture Cobol
 diverse. Per questo motivo viene restituito un array di puntatori.
 I pointer coincidono  con i numeri di definizione dei data item nel programma.
 Se il data item non è definito come simbolo restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name
<DT><B>Returns:</B><DD>int[] con i numeri di definizione del data item nel programma</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemDefinition(java.lang.String)"><!-- --></A><H3>
dataItemDefinition</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A> <B>dataItemDefinition</B>(java.lang.String&nbsp;dataItemName)</PRE>
<DL>
<DD>Restituisce il primo data item definito con il nome fornito.<br> 
 <p>
 Potrebbero essere definiti più campi con lo stesso nome in strutture diverse,<b>
 referenziati normalminte utilizzando l'attributo OF.<br>.
 Nella maggior parte dei casi la definizione è univoca e, in ogni caso, questo <br>
 metodo restituisce il primo data item definito.<br>
 <p>
 Se nessun data item è definito con il nome fornito, viene restituito null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data item name
<DT><B>Returns:</B><DD>InstructionCobolDataItem with the name supplied</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsImplicit(int)"><!-- --></A><H3>
dataItemsImplicit</H3>
<PRE>
public java.util.ArrayList&lt;java.util.ArrayList&lt;java.lang.Integer&gt;&gt; <B>dataItemsImplicit</B>(int&nbsp;pointerDataItem)</PRE>
<DL>
<DD>Restituisce i puntatori alla definizione dati nel programma, per il data item fornito in input,
 di tutti i data item redefines, renames e di gruppo che possono riferirsi implicitamente.<br>
 <p>
 Viene restituita una ArrayList di ArrayList di interi.<br>
 La prima ArrayList contiene i numeri di definizione dei data item impliciti.<br>
 La seconda ArrayList contiene la posizione utile di inizio dei data item impliciti.<br>
 La terza ArrayList contiene la lunghezza utile a copertura di tutto il data item fornito.<br>
 <p>
 La posizione è 1-based e relativa al livello del data item implicito, se un gruppo, oppure
 relativa al livello 01 di appartenenza, negli altri casi (redefines e renames.<br>
 <p>
 Tutti i data item impliciti restituiti sono definiti sotto lo stesso livello 01.<br>
 <p>
 Applicativamente è possibile trovare nel programma assegnazioni valide con esplicitazione
 di reference modification (pos e lunghezza), che modificano implicitamente il data item
 in oggetto.<br>
 <p>
 In caso di pointer fornito errato, si restituisce null.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - pointerDataItem
<DT><B>Returns:</B><DD>ArrayList bidimensionale con i numeri di definizione dei data item, posizione e lunghezza.</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsUnderGroupPointers(int, int)"><!-- --></A><H3>
dataItemsUnderGroupPointers</H3>
<PRE>
public int[] <B>dataItemsUnderGroupPointers</B>(int&nbsp;dataNameGroupPointer,
                                         int&nbsp;typeDataItemsToExtract)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni dei data item elementari e/o di gruppo, 
 definiti sotto  il gruppo fornito in input.<br> 
 <p>
 Se il campo non è di gruppo o la richiesta è errata restituisce un array vuoto.<br>
 <p>
 Il primo parametro è il numero di definizione del data item di gruppo da esaminare.<br>
 <p>
 Il secondo parametro indica il tipo di data items definiti sotto il gruppo da restituire:<br>
 <p>
 <b>DATA_ITEMS_GROUP_FIELDS </b> <br>            
    Restituiti solo i campi di gruppo del gruppo<br>
 <p>
 <b>DATA_ITEMS_ELEMENTARY_FIELDS</b> <br>  
    Restituiti solo i campi elementari del gruppo 
 <p> 
 <b>DATA_ITEMS_ALL</b> <br>                  
    Restituiti tutti i campi del gruppo (altri gruppi e dati elementari)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int[] con i numeri di definizione dei data item elementari defini nel gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsUnderGroup(int, int)"><!-- --></A><H3>
dataItemsUnderGroup</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&gt; <B>dataItemsUnderGroup</B>(int&nbsp;dataNameGroupPointer,
                                                                         int&nbsp;typeDataItemsToExtract)</PRE>
<DL>
<DD>Restituisce le definizioni dei data item elementari e/o di gruppo, 
 definiti sotto  il gruppo fornito in input.<br> 
 <p>
 Se il campo non è di gruppo o la richiesta è errata restituisce un array vuoto.<br>
 <p>
 Il primo parametro è il numero di definizione del data item di gruppo da esaminare.<br>
 <p>
 Il secondo parametro indica il tipo di data items definiti sotto il gruppo da restituire:<br>
 <p>
 <b>DATA_ITEMS_GROUP_FIELDS </b> <br>            
    Restituiti solo i campi di gruppo del gruppo<br>
 <p>
 <b>DATA_ITEMS_ELEMENTARY_FIELDS</b> <br>  
    Restituiti solo i campi elementari del gruppo 
 <p> 
 <b>DATA_ITEMS_ALL</b> <br>                  
    Restituiti tutti i campi del gruppo (altri gruppi e dati elementari)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>ArrayList<InstructionCobolDataItem> con i data item defini nel gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsUnderGroupNames(int, int)"><!-- --></A><H3>
dataItemsUnderGroupNames</H3>
<PRE>
public java.lang.String[] <B>dataItemsUnderGroupNames</B>(int&nbsp;dataNameGroupPointer,
                                                   int&nbsp;typeDataItemsToExtract)</PRE>
<DL>
<DD>Restituisce i nomi dei data item elementari, non di gruppo, definiti sotto il campo gruppo fornito in input.
 <p>
 Il primo parametro è il numero di definizione del data item di gruppo da esaminare.<br>
 Il secondo parametro indica il tipo di data items definiti sotto il gruppo da restituire:<br>
 <p>
 <b>DATA_ITEMS_GROUP_FIELDS </b> <br>            
    Restituiti solo i campi di gruppo del gruppo<br>
 <p>
 <b>DATA_ITEMS_ELEMENTARY_FIELDS</b> <br>  
    Restituiti solo i campi elementari del gruppo 
 <p> 
 <b>DATA_ITEMS_ALL</b> <br>                  
    Restituiti tutti i campi del gruppo (altri gruppi e dati elementari)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi dei data item elementari defini nel gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsRedefinePointers(int)"><!-- --></A><H3>
dataItemsRedefinePointers</H3>
<PRE>
public int[] <B>dataItemsRedefinePointers</B>(int&nbsp;numInstrDataNameRedefined)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni dei data item, che ridefiniscono quello fornito in input.<br> 
 <p>
 In caso di richiesta non valida o nessun valore in output, viene restituito un array vuoto.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>int[] con i numeri di definizione dei data item elementari defini nel gruppo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemName(int)"><!-- --></A><H3>
dataItemName</H3>
<PRE>
public java.lang.String <B>dataItemName</B>(int&nbsp;numDefinition)</PRE>
<DL>
<DD>Restituisce il nome del data item, fornito il suo numero di definizione.<br> 
 <p>
 E' una scorciatoia per non richiamare <b>entryDataDivision(int)</b> e
 successivamente recuperare il nome del campo dall'istruzione DataItem.
 Se non si riesce a determinare il nome viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numDefinition
<DT><B>Returns:</B><DD>String con il nome del campo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemQualifier(int, java.lang.String, java.lang.String)"><!-- --></A><H3>
dataItemQualifier</H3>
<PRE>
public <A HREF="../analyzer/DataItemQualifier.html" title="class in analyzer">DataItemQualifier</A> <B>dataItemQualifier</B>(int&nbsp;numInstruction,
                                           java.lang.String&nbsp;dataName,
                                           java.lang.String&nbsp;typeUseDataItem)</PRE>
<DL>
<DD>Restituisce il qualificatote di utilizzo in input o in output del data item utilizzato dall'istruzione<br> 
 <p>
 Se il numero di istruzione è errato viene restituito null.<br>
 Se il numero di definizione è errato viene restituito null.<br>
 Se il data item non ha utilizzi in input restituisce null<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numInstruction<DD><CODE>String</CODE> - dataName<DD><CODE>String</CODE> - typeUseDataItem che può valere INSTR_USE_DATA_ITEM_INPUT/INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>DataItemQualifier con le qualificazioni di utilizzo</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsUsed(int, java.lang.String)"><!-- --></A><H3>
dataItemsUsed</H3>
<PRE>
public <A HREF="../analyzer/Instruction.InnerSymbolEntry.html" title="class in analyzer">Instruction.InnerSymbolEntry</A>[] <B>dataItemsUsed</B>(int&nbsp;numInstruction,
                                                    java.lang.String&nbsp;typeUseDataItem)</PRE>
<DL>
<DD>Restituisce array con le coppie nome item/qualificatori dei data item utilizzati dall'istruzione<br> 
 <p>
 Se il numero di istruzione è errato viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numDefinition<DD><CODE>String</CODE> - typeUseDataItem che può valere INSTR_USE_DATA_ITEM_INPUT/INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>   <code> Set<Entry><String, DataItemQualifier>></code>             con i data items in input</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsLvl88(analyzer.InstructionCobolDataItem)"><!-- --></A><H3>
dataItemsLvl88</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&gt; <B>dataItemsLvl88</B>(<A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A>&nbsp;dataItem)</PRE>
<DL>
<DD>Restituisce le definizioni dati a livello 88 codificate dopo il data item fornito.<br>
 <p>
 Se il data item non ha livelli 88 viene restituito un insieme vuoto.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>InstructionCobolDataItem</CODE> - dataItem to ebvaluate
<DT><B>Returns:</B><DD>ArrayList<InstructionCobolDataItem> 88 level data item</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsNamesUsed(int, java.lang.String)"><!-- --></A><H3>
dataItemsNamesUsed</H3>
<PRE>
public java.lang.String[] <B>dataItemsNamesUsed</B>(int&nbsp;numInstruction,
                                             java.lang.String&nbsp;useDataItem)</PRE>
<DL>
<DD>Restituisce i nomi dei data item utilizzati in input o in output dall'istruzione<br> 
 <p>
 Se il numero di istruzione è errato viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numDefinition<DD><CODE>String</CODE> - useDataItem INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>String[] con il nome dei campi</DL>
</DD>
</DL>
<HR>

<A NAME="dataItemsNamesUsedBoth(int)"><!-- --></A><H3>
dataItemsNamesUsedBoth</H3>
<PRE>
public java.lang.String[] <B>dataItemsNamesUsedBoth</B>(int&nbsp;numInstruction)</PRE>
<DL>
<DD>Restituisce i nomi dei data item utilizzati sia in input sia in output dall'istruzione<br> 
 <p>
 Se il numero di istruzione è errato viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numDefinition
<DT><B>Returns:</B><DD>String[] con il nome dei campi</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemsUsedByInstr(int, java.lang.String)"><!-- --></A><H3>
xrefToDataItemsUsedByInstr</H3>
<PRE>
public int[] <B>xrefToDataItemsUsedByInstr</B>(int&nbsp;numInstruction,
                                        java.lang.String&nbsp;useDataItem)</PRE>
<DL>
<DD>Restituisce i numeri delle definizioni dei data item utilizzati in input o in output dall'istruzione<br> 
 <p>
 Per ogni simbolo qualificato viene cercato il numero di definizione dove questo è definito.
 Se il numero di istruzione è errato viene restituito null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numInstruction<DD><CODE>Strin</CODE> - useDataItem (INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT)
<DT><B>Returns:</B><DD>int[] con i pointers alle definizioni dei campi</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemsUsedByInstrBoth(int)"><!-- --></A><H3>
xrefToDataItemsUsedByInstrBoth</H3>
<PRE>
public int[] <B>xrefToDataItemsUsedByInstrBoth</B>(int&nbsp;numInstruction)</PRE>
<DL>
<DD>Restituisce i pointer alle definizioni dei campi utilizzati in input insieme a quelli utilizzati in output<br> 
 dell'istruzione il cui numero è fornito in input.
 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - numInstruction
<DT><B>Returns:</B><DD>int[] con  pointer alle definizioni</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToSection(java.lang.String)"><!-- --></A><H3>
xrefToSection</H3>
<PRE>
public int[] <B>xrefToSection</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni che referenziano una Section Cobol<br> 
 <p>
 Coincide con i numeri delle istruzioni del programma.<br>
 Se la section non è referenziata restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - section name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che richiama la Section</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToLabel(java.lang.String)"><!-- --></A><H3>
xrefToLabel</H3>
<PRE>
public int[] <B>xrefToLabel</B>(java.lang.String&nbsp;labelName)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni che referenziano una label Cobol<br> 
 <p>
 Coincide con il numeri delle istruzioni di programma.<br>
 Se la section non è referenziata restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - label name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che richiama la label</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToProcedureInternal(java.lang.String)"><!-- --></A><H3>
xrefToProcedureInternal</H3>
<PRE>
public int[] <B>xrefToProcedureInternal</B>(java.lang.String&nbsp;procedureName)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni Cobol Perform a section o procedure<br> 
 <p>
 Coincide con il numeri delle istruzioni di programma.<br>
 La procedura può essere una section Cobol oppure un paragrafo.
 In entrambi i casi la procedura è richiamata con Perform o Perform Thru.<br>
 Si tenta inizialmente considerando come paragrafo.<br>
 Se non si trovano riferimenti si tenta allora come section.<br>
 Se la procedura non è referenziata restituisce un array vuoto.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - procedure name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che richiama la procedure</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemInProcedure(int, java.lang.String)"><!-- --></A><H3>
xrefToDataItemInProcedure</H3>
<PRE>
public int[] <B>xrefToDataItemInProcedure</B>(int&nbsp;pointerDataItem,
                                       java.lang.String&nbsp;typeXref)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni che referenziano il data item in procedure division<br> 
 <p>
 Se il data item non è definito restituisce null.
 Se il data item non è referenziato restituisce null.
 Viene fornito un parametro per restituire i riferimenti in input o in output
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - pointer definizione data item<DD><CODE>String</CODE> - INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemInProcedureImplicit(int, java.lang.String)"><!-- --></A><H3>
xrefToDataItemInProcedureImplicit</H3>
<PRE>
public int[] <B>xrefToDataItemInProcedureImplicit</B>(int&nbsp;pointerDataItemOrigin,
                                               java.lang.String&nbsp;typeXref)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni che implicitamente referenziano 
 il data item in procedure division, attraverso assegnazioni a campi redefines,
 renames e di gruppo.<br> 
 <p>
 Se il data item non è definito restituisce null.
 Se il data item non è referenziato implicitamente restituisce un insieme vuoto.
 Viene fornito un parametro per restituire i riferimenti in input o in output
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name<DD><CODE>String</CODE> - INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemInProcedureOf(java.lang.String, java.lang.String, java.lang.String)"><!-- --></A><H3>
xrefToDataItemInProcedureOf</H3>
<PRE>
public int[] <B>xrefToDataItemInProcedureOf</B>(java.lang.String&nbsp;dataName,
                                         java.lang.String&nbsp;underGroupName,
                                         java.lang.String&nbsp;typeXref)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni di procedure che referenziano il data item
 qualificato dalla clausola OF.<br> 
 <p>
 Viene fornito in input anche il nome del data item di gruppo sotto il quale è definito il data item.
 Campi definiti con lo stesso nome in gruppi diversi sono a tutti gli effetti campi diversi.
 Se il data item non è referenziato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name<DD><CODE>String</CODE> - underGroupName<DD><CODE>String</CODE> - INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemInDataDivision(java.lang.String)"><!-- --></A><H3>
xrefToDataItemInDataDivision</H3>
<PRE>
public int[] <B>xrefToDataItemInDataDivision</B>(java.lang.String&nbsp;dataName)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni che referenziano il data item, in data division<br> 
 <p>
 Per esempio vengono restituiti tutti i data item che ridefiniscono un campo.
 Se il data item non è referenziata restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToDataItemInDataDivisionOf(java.lang.String, java.lang.String)"><!-- --></A><H3>
xrefToDataItemInDataDivisionOf</H3>
<PRE>
public int[] <B>xrefToDataItemInDataDivisionOf</B>(java.lang.String&nbsp;dataName,
                                            java.lang.String&nbsp;underGroupName)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni che referenziano il data item, in data division 
 con la clausola OF group-name<br>
 <p>
 Viene fornito anche il nome del data item di gruppo sotto il quale è definito il data item
 Se il data item non è referenziata restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - data name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToSymbolInEnvDivision(java.lang.String)"><!-- --></A><H3>
xrefToSymbolInEnvDivision</H3>
<PRE>
public int[] <B>xrefToSymbolInEnvDivision</B>(java.lang.String&nbsp;symbolName)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni che referenziano il simbolo, in environment division<br> 
 <p>
 Per esempio vengono restituiti tutti gli statement di environment dove una literal è utilizzata
 o un data  item referenziato.
 Se il simbolo non è referenziata restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il simbolo</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToSymbolInDataDivision(java.lang.String)"><!-- --></A><H3>
xrefToSymbolInDataDivision</H3>
<PRE>
public int[] <B>xrefToSymbolInDataDivision</B>(java.lang.String&nbsp;symbolName)</PRE>
<DL>
<DD>Restituisce i puntatori alle definizioni che referenziano il simbolo, in data division<br> 
 <p>
 Per esempio vengono restituiti tutti i data item che referenziano una costante figurativa.
 Se il simbolo non è referenziata restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol name
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il simbolo</DL>
</DD>
</DL>
<HR>

<A NAME="xrefToSymbolInProcedure(java.lang.String, java.lang.String)"><!-- --></A><H3>
xrefToSymbolInProcedure</H3>
<PRE>
public int[] <B>xrefToSymbolInProcedure</B>(java.lang.String&nbsp;symbolName,
                                     java.lang.String&nbsp;typeXref)</PRE>
<DL>
<DD>Restituisce i puntatori alle istruzioni che referenziano il simbolo in procedure division<br> 
 <p>
 Se il simbolo non è definito restituisce null.<br>
 Se il simbolo non è referenziato restituisce null.<br>
 Viene fornito un parametro per restituire i riferimenti in input o in output<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - symbol<DD><CODE>String</CODE> - INSTR_USE_DATA_ITEM_INPUT o INSTR_USE_DATA_ITEM_OUTPUT
<DT><B>Returns:</B><DD>int[] con il numero di istruzione che referenziano il data name</DL>
</DD>
</DL>
<HR>

<A NAME="unXrefSymbols(enums.EnumSymbolType)"><!-- --></A><H3>
unXrefSymbols</H3>
<PRE>
public java.lang.String[] <B>unXrefSymbols</B>(<A HREF="../enums/EnumSymbolType.html" title="enum in enums">EnumSymbolType</A>&nbsp;symbolTypeParm)</PRE>
<DL>
<DD>Restituisce i nomi di tutti i simboli di un certo tipo non referenziati da nessuna istruzione di procedure division<br> 
 <p>
 Il tipo di simbolo può essere Label, Section o Data Item come speccificato in <A HREF="../analyzer/AmritaConstants.html" title="interface in analyzer"><CODE>AmritaConstants</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi dei data item non referenziate</DL>
</DD>
</DL>
<HR>

<A NAME="labelNames()"><!-- --></A><H3>
labelNames</H3>
<PRE>
public java.lang.String[] <B>labelNames</B>()</PRE>
<DL>
<DD>Restituisce tutte le label definite nel programma<br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi delle label definite</DL>
</DD>
</DL>
<HR>

<A NAME="labelNames(java.lang.String)"><!-- --></A><H3>
labelNames</H3>
<PRE>
public java.lang.String[] <B>labelNames</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce tutte le label definite in una section del programma <br> 
 <p>
 Se la section non è definita restituisce null
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>String[] con i nomi delle label definite</DL>
</DD>
</DL>
<HR>

<A NAME="labelNames(java.lang.String, java.lang.String)"><!-- --></A><H3>
labelNames</H3>
<PRE>
public java.lang.String[] <B>labelNames</B>(java.lang.String&nbsp;labelFrom,
                                     java.lang.String&nbsp;labelTo)</PRE>
<DL>
<DD>Restituisce tutte le label definite fra due label di un programma <br> 
 <p>
 Se labelFrom o labelTo non è definita restituisce null
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi delle label definite</DL>
</DD>
</DL>
<HR>

<A NAME="procInternalNames()"><!-- --></A><H3>
procInternalNames</H3>
<PRE>
public java.lang.String[] <B>procInternalNames</B>()</PRE>
<DL>
<DD>Restituisce i nomi di tutte le procedure interne definite nel programma <br> 
 <p>
 Si tratta di Section e paragrafi richiamati con perform o eventualmente solo definiti.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi delle section/paragrafi definite nel programma</DL>
</DD>
</DL>
<HR>

<A NAME="sectionNames()"><!-- --></A><H3>
sectionNames</H3>
<PRE>
public java.lang.String[] <B>sectionNames</B>()</PRE>
<DL>
<DD>Restituisce i nomi di tutte le section definite nel programma. <br> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi delle section definite nel programma</DL>
</DD>
</DL>
<HR>

<A NAME="paragraphNames()"><!-- --></A><H3>
paragraphNames</H3>
<PRE>
public java.lang.String[] <B>paragraphNames</B>()</PRE>
<DL>
<DD>Restituisce i nomi di tutti i paragrafi definiti nel programma<br> 
 <p>
 Si tratta di paragrafi dichiarati nella sezione DECLARATIVES, <br>
 eseguiti con perform o codificati e chiusi formalmente da EXIT e <br>
 non richiamati.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi dei paragrafi definiti nel programma</DL>
</DD>
</DL>
<HR>

<A NAME="sectionCallerDeadCode(java.lang.String)"><!-- --></A><H3>
sectionCallerDeadCode</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>sectionCallerDeadCode</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce tutte le section chiamanti dead code, senza ulteriori chiamanti.<br>
 <p>
 Viene analizzato qualsiasi livello di annidamento delle section.<br>
 Della section fornita si individuano i punti dove è performata.<br>
 Di ogni punto si individua la section di appartenenza e se si trova una section
 non + performata si restituisce in output
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>ArrayList<String> al_numSectionDeadCodeCaller</DL>
</DD>
</DL>
<HR>

<A NAME="sectionCallerNoDeadCode(java.lang.String)"><!-- --></A><H3>
sectionCallerNoDeadCode</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>sectionCallerNoDeadCode</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce tutte le section chiamanti no dead code, richiamate direttamente dalla mainline<br>
 <p>
 Viene analizzato qualsiasi livello di annidamento delle section.<br>
 Della section fornita si individuano i punti dove è performata.<br>
 Di ogni punto si individua la section di appartenenza e se si prosegue
 fino a trivare una attivazione dalla mainline del programma.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>ArrayList<String> al_numSectionDeadCodeCaller</DL>
</DD>
</DL>
<HR>

<A NAME="sectionCaller(java.lang.String)"><!-- --></A><H3>
sectionCaller</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>sectionCaller</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce tutte le section chiamanti, senza discriminare se dead code o meno<br>
 <p>
 Viene analizzato qualsiasi livello di annidamento delle section.<br>
 Della section fornita si individuano i punti dove è performata.<br>
 Di ogni punto si individua la section di appartenenza e se si trova una section
 non + performata si restituisce in output
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>ArrayList<String> al_numSectionDeadCodeCaller</DL>
</DD>
</DL>
<HR>

<A NAME="sectionLabels(java.lang.String)"><!-- --></A><H3>
sectionLabels</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.String&gt; <B>sectionLabels</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce i nomi di tutte le label presenti nella section fornita<br>
 <p>
 Se il nome della section è errato restituisce un array vuoto<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>ArrayList<String> al_label</DL>
</DD>
</DL>
<HR>

<A NAME="sectionCountNoLabelInstr(java.lang.String)"><!-- --></A><H3>
sectionCountNoLabelInstr</H3>
<PRE>
public int <B>sectionCountNoLabelInstr</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce il numero di istruzioni non LABEL presenti nella section fornita<br>
 <p>
 Se il nome della section è errato restituisce -1<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>int count instructions no label</DL>
</DD>
</DL>
<HR>

<A NAME="isSectionDeadCode(java.lang.String)"><!-- --></A><H3>
isSectionDeadCode</H3>
<PRE>
public boolean <B>isSectionDeadCode</B>(java.lang.String&nbsp;sectionName)</PRE>
<DL>
<DD>Restituisce true se la section fornita è dead code<br>
 <p>
 La section è dead code se non è mai referenziata o se seguendo la
 catena di section chiamanti si arriva a una non più referenziata.<br>
 Se tutte le section chiamanti di primo livello non sono referenziate
 viene restituito true<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - sectionName
<DT><B>Returns:</B><DD>boolean true se dead code</DL>
</DD>
</DL>
<HR>

<A NAME="isParagraphDeadCode(java.lang.String)"><!-- --></A><H3>
isParagraphDeadCode</H3>
<PRE>
public boolean <B>isParagraphDeadCode</B>(java.lang.String&nbsp;paragraphName)</PRE>
<DL>
<DD>Restituisce true se il paragrafo fornito è dead code<br>
 <p>
 Si verifica semplicemente se la label del paragrafo è referenziata.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - paragraphName
<DT><B>Returns:</B><DD>boolean true se dead code</DL>
</DD>
</DL>
<HR>

<A NAME="isProcInternalDeadCode(java.lang.String)"><!-- --></A><H3>
isProcInternalDeadCode</H3>
<PRE>
public boolean <B>isProcInternalDeadCode</B>(java.lang.String&nbsp;procInternalName)</PRE>
<DL>
<DD>Restituisce true se la procedura interna fornito è dead code<br>
 <p>
 La procedura interna è dead code se non è mai referenziata o se seguendo la
 catena di section o paragrafi chiamanti si arriva a una non più referenziata.<br>
 Se tutte le section o paragrafi chiamanti di primo livello non sono referenziati
 viene restituito true<br>
 <p>
 Se il nome fornito non è quello di una section o di un paragrafo,
 restituisce false.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - procInternalName
<DT><B>Returns:</B><DD>boolean true se dead code</DL>
</DD>
</DL>
<HR>

<A NAME="isParagraphReferenced(java.lang.String)"><!-- --></A><H3>
isParagraphReferenced</H3>
<PRE>
public boolean <B>isParagraphReferenced</B>(java.lang.String&nbsp;paragraphName)</PRE>
<DL>
<DD>Restituisce true se il paragrafo fornito è referenziato<br>
 <p>
 Il paragrafo può essere referenziato con perform o con goto.<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>String</CODE> - paragraphName
<DT><B>Returns:</B><DD>boolean true se dead code</DL>
</DD>
</DL>
<HR>

<A NAME="symbolNames()"><!-- --></A><H3>
symbolNames</H3>
<PRE>
public java.lang.String[] <B>symbolNames</B>()</PRE>
<DL>
<DD>Restituisce i nomi dei simboli non section e non label definiti nel programma <br> 
 <p>
 Si tratta di nomi di campi, literal, costanti figurative etc.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>String[] con i nomi delle section definite nel programma</DL>
</DD>
</DL>
<HR>

<A NAME="entryProcedure(int)"><!-- --></A><H3>
entryProcedure</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt; <B>entryProcedure</B>(int&nbsp;instructionPointer)</PRE>
<DL>
<DD>Restituisce la definizione completa dell' entry di procedure division<br> 
 <p>
 Coincide on il numero dell'istruzione.<br>
 Se il pointer fornito è errato restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - instructionPointer
<DT><B>Returns:</B><DD>ProgramCobolEntry con la definizione completa dell'entry</DL>
</DD>
</DL>
<HR>

<A NAME="entryDataDivision(int)"><!-- --></A><H3>
entryDataDivision</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt; <B>entryDataDivision</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce la definizione completa dell' entry di data division<br>
 <p> 
 Coincide coincide con il numero della definizione.<br>
 Se il pointer fornito è errato restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>ProgramCobolEntry con la definizione completa dell'entry</DL>
</DD>
</DL>
<HR>

<A NAME="entryIdentificationDivision(int)"><!-- --></A><H3>
entryIdentificationDivision</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt; <B>entryIdentificationDivision</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce la definizione completa dell' entry di identification division<br> 
 <p> 
 Coincide coincide con il numero della definizione.<br>
 Se il pointer fornito è errato restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>ProgramCobolEntry con la definizione completa dell'entry</DL>
</DD>
</DL>
<HR>

<A NAME="entryEnvironmentDivision(int)"><!-- --></A><H3>
entryEnvironmentDivision</H3>
<PRE>
public <A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt; <B>entryEnvironmentDivision</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce la definizione completa dell' entry di environment division<br> 
 <p>
 Coincide coincide con il numero della definizione.<br>
 Se il pointer fornito è errato restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>ProgramCobolEntry con la definizione completa dell'entry</DL>
</DD>
</DL>
<HR>

<A NAME="instructionDataItem(int)"><!-- --></A><H3>
instructionDataItem</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobolDataItem.html" title="class in analyzer">InstructionCobolDataItem</A> <B>instructionDataItem</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce un oggetto InstructionCobolDataItem, memorizzato nell'entry del quale è fornito il numero<br> 
 <p>
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>InstructionCobolDataItem con la definizione completa del data item</DL>
</DD>
</DL>
<HR>

<A NAME="instructionCopyData(int)"><!-- --></A><H3>
instructionCopyData</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobol.html" title="class in analyzer">InstructionCobol</A> <B>instructionCopyData</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce l'struzione statement Cobol di data division, memorizzata nell'entry del quale è fornito il numero<br> 
 <p>
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>InstructionCobolCopy con la definizione completa dello statement copy</DL>
</DD>
</DL>
<HR>

<A NAME="instructionCopyProc(int)"><!-- --></A><H3>
instructionCopyProc</H3>
<PRE>
public <A HREF="../analyzer/InstructionCobol.html" title="class in analyzer">InstructionCobol</A> <B>instructionCopyProc</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce l'struzione statement Cobol di procedure division, memorizzata nell'entry del quale è fornito il numero<br>
 <p> 
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>InstructionCobolCopy con la definizione completa dello statement copy</DL>
</DD>
</DL>
<HR>

<A NAME="instructionProcedure(int)"><!-- --></A><H3>
instructionProcedure</H3>
<PRE>
public java.lang.Object <B>instructionProcedure</B>(int&nbsp;instructionPointer)</PRE>
<DL>
<DD>Restituisce l'istruzione in procedure division, memorizzata nell'entry del quale è fornito il numero<br>
 <p> 
 Il chiamante deve effettuare il casting all'oggetto istruzione corretto
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>Object con istruzione di procedure division memorizzata nell'entry</DL>
</DD>
</DL>
<HR>

<A NAME="instructionPrecompilerData(int)"><!-- --></A><H3>
instructionPrecompilerData</H3>
<PRE>
public <A HREF="../analyzer/InstructionCics.html" title="class in analyzer">InstructionCics</A> <B>instructionPrecompilerData</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce l'struzione di precompilatore, memorizzata nell'entry del quale è fornito il numero<br> 
 <p>
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>InstructionPrecompiler con l'istruzione diretta al precompilatore</DL>
</DD>
</DL>
<HR>

<A NAME="instructionPrecompilerProc(int)"><!-- --></A><H3>
instructionPrecompilerProc</H3>
<PRE>
public <A HREF="../analyzer/InstructionCics.html" title="class in analyzer">InstructionCics</A> <B>instructionPrecompilerProc</B>(int&nbsp;definitionPointer)</PRE>
<DL>
<DD>Restituisce l'struzione di precompilatore, memorizzata nell'entry del quale è fornito il numero<br> 
 <p>
 Se il pointer fornito è errato restituisce null.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - definitionPointer
<DT><B>Returns:</B><DD>InstructionPrecompiler con l'istruzione diretta al precompilatore</DL>
</DD>
</DL>
<HR>

<A NAME="instructionConditionOwnerMain(int)"><!-- --></A><H3>
instructionConditionOwnerMain</H3>
<PRE>
public int <B>instructionConditionOwnerMain</B>(int&nbsp;instructionPointer)</PRE>
<DL>
<DD>Restituisce il numero dell'istruzione condizionale di più alto livello
 sotto la quale l'istruzione fornita in input è definita.<br> 
 <p>
 Se il pointer all'istruzione è errato si restituisce -1.<br>
 Se l'istruzione fornita non è sotto condizione si restituisce lo stesso numero di
 istruzione fornito in input.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - instructionPointer
<DT><B>Returns:</B><DD>int con numero istruzione condizionale proprietaria</DL>
</DD>
</DL>
<HR>

<A NAME="groupOwnerNames(int)"><!-- --></A><H3>
groupOwnerNames</H3>
<PRE>
public java.lang.String[] <B>groupOwnerNames</B>(int&nbsp;dataNamePointer)</PRE>
<DL>
<DD>Restituisce il nomi dei campi di gruppo sotto i quali il data item è definito<br> 
 <p>
 La funzione restituisce tutti i campi di gruppo sotto il quale il data item fornito è definito<br>
 L'array restituito ha come ultimo elemento il campo di gruppo più generale, con il numero di livello<br>
 più basso, come il livello 01. Il primo elemento contiene invece il campo di gruppo immediatamente <br>
 sotto il quale il data item è definito.<br>
 In Cobol, di fatto, le strutture devono iniziare con livelli 01 e, pertanto, l'ultimo numero di <br>
 livello nell'array dovrebbe essere 01.<br>
 Se il data item fornito è errato restituisce un array vuoto<br>
 Se il data item è a livello 1 o 77, restituisce un array vuoto<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - dataNamePointer
<DT><B>Returns:</B><DD>String dataName owner</DL>
</DD>
</DL>
<HR>

<A NAME="groupOwnerName(int)"><!-- --></A><H3>
groupOwnerName</H3>
<PRE>
public java.lang.String <B>groupOwnerName</B>(int&nbsp;dataNamePointer)</PRE>
<DL>
<DD>Restituisce il nome del campo di gruppo sotto il quale il data item è immediatamente definito<br> 
 <p>
 Il numero di livello del gruppo deve essere inferiore a quello del data item
 Se il data item fornito è errato restituisce null <br>
 Se il data item non è definito sotto un gruppo, in quanto livello 01, restituisce stringa vuota<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - dataNamePointer
<DT><B>Returns:</B><DD>String dataName owner</DL>
</DD>
</DL>
<HR>

<A NAME="groupOwnerDefinition(int)"><!-- --></A><H3>
groupOwnerDefinition</H3>
<PRE>
public int <B>groupOwnerDefinition</B>(int&nbsp;dataNamePointer)</PRE>
<DL>
<DD>Restituisce il puntatore al campo di gruppo sotto il quale il data item è immediatamente definito.<br> 
 <p>
 Vengono analizzate all'indietro le definizioni prima del data item e, se sono relative a una definizione
 di gruppo che include il data item fornito, vengono restituite in output. <br>
 Il numero di livello del gruppo deve essere inferiore a quello del data item.
 Se il data item fornito è errato restituisce -1
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - dataNamePointer
<DT><B>Returns:</B><DD>int dataName owner pointer</DL>
</DD>
</DL>
<HR>

<A NAME="groupOwnerPointers(int)"><!-- --></A><H3>
groupOwnerPointers</H3>
<PRE>
public int[] <B>groupOwnerPointers</B>(int&nbsp;dataNamePointer)</PRE>
<DL>
<DD>Restituisce i puntatori ai campi di gruppo 
 sotto il quale il data item fornito è definito.<br> 
 <p>
 La funzione restituisce tutti i pointer campi di gruppo sotto il quale il data item fornito è definito<br>
 L'array restituito ha come ultimo elemento il campo di gruppo più generale, con il numero di livello<br>
 più basso, come il livello 01. Il primo elemento contiene invece il campo di gruppo immediatamente <br>
 sotto il quale il data item è definito.<br>
 In Cobol, di fatto, le strutture devono iniziare con livelli 01 e, pertanto, l'ultimo numero di <br>
 livello nell'array dovrebbe essere 01.<br>
 Se il data item fornito è errato restituisce un array vuoto<br>
 Se il data item è a livello 1 o 77, restituisce un array vuoto<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>int</CODE> - dataNamePointer
<DT><B>Returns:</B><DD>int dataName owner pointer</DL>
</DD>
</DL>
<HR>

<A NAME="getMetricsProgram()"><!-- --></A><H3>
getMetricsProgram</H3>
<PRE>
public <A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A> <B>getMetricsProgram</B>()</PRE>
<DL>
<DD>Restituisce le metriche associate  al programma completo
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the metricsProgram</DL>
</DD>
</DL>
<HR>

<A NAME="setMetricsProgram(analyzer.Metrics)"><!-- --></A><H3>
setMetricsProgram</H3>
<PRE>
public void <B>setMetricsProgram</B>(<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&nbsp;metricsProgram)</PRE>
<DL>
<DD>Imposta le metriche associate  al programma completo
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>metricsProgram</CODE> - the metricsProgram to set</DL>
</DD>
</DL>
<HR>

<A NAME="getMetricsProgramMainline()"><!-- --></A><H3>
getMetricsProgramMainline</H3>
<PRE>
public <A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A> <B>getMetricsProgramMainline</B>()</PRE>
<DL>
<DD>Restituisce le metriche associate  alla mainline del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the metricsProgramMainline</DL>
</DD>
</DL>
<HR>

<A NAME="setMetricsProgramMainline(analyzer.Metrics)"><!-- --></A><H3>
setMetricsProgramMainline</H3>
<PRE>
public void <B>setMetricsProgramMainline</B>(<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&nbsp;metricsProgramMainline)</PRE>
<DL>
<DD>Imposta le metriche associate  alla mainline del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>metricsProgramMainline</CODE> - the metricsProgramMainline to set</DL>
</DD>
</DL>
<HR>

<A NAME="getMetricsProgramSections()"><!-- --></A><H3>
getMetricsProgramSections</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&gt; <B>getMetricsProgramSections</B>()</PRE>
<DL>
<DD>Restituisce le metriche associate  alle section/paragrafi del programma come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A><br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_metricsProgramSection</DL>
</DD>
</DL>
<HR>

<A NAME="getMetricsProgramSectionParagraph(java.lang.String)"><!-- --></A><H3>
getMetricsProgramSectionParagraph</H3>
<PRE>
public <A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A> <B>getMetricsProgramSectionParagraph</B>(java.lang.String&nbsp;idSectionParagraph)</PRE>
<DL>
<DD>Restituisce le metriche associate  a una specifica section/paragrafo del programma come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A><br>
 <p>
 Se sectio/paragrafo non trovato restituisce null.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the metricsProgramSection</DL>
</DD>
</DL>
<HR>

<A NAME="setMetricsProgramSection(java.util.ArrayList)"><!-- --></A><H3>
setMetricsProgramSection</H3>
<PRE>
public void <B>setMetricsProgramSection</B>(java.util.ArrayList&lt;<A HREF="../analyzer/Metrics.html" title="class in analyzer">Metrics</A>&gt;&nbsp;al_metricsProgramSection)</PRE>
<DL>
<DD>Imposta le metriche associate  alle section/paragrafi del programma
 come istanza dell'oggetto <A HREF="../analyzer/Metrics.html" title="class in analyzer"><CODE>Metrics</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_metricsProgramSection</CODE> - the al_metricsProgramSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumLastInstrMainline()"><!-- --></A><H3>
getNumLastInstrMainline</H3>
<PRE>
public int <B>getNumLastInstrMainline</B>()</PRE>
<DL>
<DD>Restituisce l'ultimo numero di istruzione della mainline.<br>
 <p>
 Dopo questa istruzione c'è la fine del programma o iniziano
 le section o i paragrafi richiamati.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numInstrEndMainline</DL>
</DD>
</DL>
<HR>

<A NAME="setNumLastInstrMainline(int)"><!-- --></A><H3>
setNumLastInstrMainline</H3>
<PRE>
public void <B>setNumLastInstrMainline</B>(int&nbsp;numLastInstrMainline)</PRE>
<DL>
<DD>Imposta l'ultimo numero di istruzione della mainline.<br>
 <p>
 Dopo questa istruzione c'è la fine del programma o iniziano
 le section o i paragrafi richiamati.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numLastInstrMainline</CODE> - the numLastInstrMainline to set</DL>
</DD>
</DL>
<HR>

<A NAME="getCountSections()"><!-- --></A><H3>
getCountSections</H3>
<PRE>
public int <B>getCountSections</B>()</PRE>
<DL>
<DD>Restituisce il numero di section definite nel programma;
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the countSections</DL>
</DD>
</DL>
<HR>

<A NAME="getCountParagraphs()"><!-- --></A><H3>
getCountParagraphs</H3>
<PRE>
public int <B>getCountParagraphs</B>()</PRE>
<DL>
<DD>Restituisce il numero di paragrafi (richiamati con perform) definiti nel programma;
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the countParagraphs</DL>
</DD>
</DL>
<HR>

<A NAME="isAnySectionCobol()"><!-- --></A><H3>
isAnySectionCobol</H3>
<PRE>
public boolean <B>isAnySectionCobol</B>()</PRE>
<DL>
<DD>Restituisce se presente almeno una section cobol nel programma
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isAnySectionCobol</DL>
</DD>
</DL>
<HR>

<A NAME="getCopyNamesId()"><!-- --></A><H3>
getCopyNamesId</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getCopyNamesId</B>()</PRE>
<DL>
<DD>Restituisce i nomi dei copy definiti in identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the set_CopyId</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyNamesId(java.util.Set)"><!-- --></A><H3>
setCopyNamesId</H3>
<PRE>
public void <B>setCopyNamesId</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyId)</PRE>
<DL>
<DD>Imposta i nomi dei copy definiti in identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set_CopyId</CODE> - the set_CopyId to set</DL>
</DD>
</DL>
<HR>

<A NAME="getCopyNamesEnv()"><!-- --></A><H3>
getCopyNamesEnv</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getCopyNamesEnv</B>()</PRE>
<DL>
<DD>Restituisce i nomi dei copy definiti in environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the set_CopyEnv</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyNamesEnv(java.util.Set)"><!-- --></A><H3>
setCopyNamesEnv</H3>
<PRE>
public void <B>setCopyNamesEnv</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyEnv)</PRE>
<DL>
<DD>Imposta i nomi dei copy definiti in environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set_CopyEnv</CODE> - the set_CopyEnv to set</DL>
</DD>
</DL>
<HR>

<A NAME="getCopyNamesProc()"><!-- --></A><H3>
getCopyNamesProc</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getCopyNamesProc</B>()</PRE>
<DL>
<DD>Restituisce i nomi dei copy definiti in procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the set_CopyProc</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyNamesProc(java.util.Set)"><!-- --></A><H3>
setCopyNamesProc</H3>
<PRE>
public void <B>setCopyNamesProc</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyProc)</PRE>
<DL>
<DD>Imposta i nomi dei copy definiti in procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set_CopyProc</CODE> - the set_CopyProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getCopyNamesData()"><!-- --></A><H3>
getCopyNamesData</H3>
<PRE>
public java.util.Set&lt;java.lang.String&gt; <B>getCopyNamesData</B>()</PRE>
<DL>
<DD>Restituisce i nomi dei copy definiti in data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the set_CopyData</DL>
</DD>
</DL>
<HR>

<A NAME="setCopyNamesData(java.util.Set)"><!-- --></A><H3>
setCopyNamesData</H3>
<PRE>
public void <B>setCopyNamesData</B>(java.util.Set&lt;java.lang.String&gt;&nbsp;set_CopyData)</PRE>
<DL>
<DD>Imposta i nomi dei copy definiti in data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set_CopyData</CODE> - the set_CopyData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeInstrProc()"><!-- --></A><H3>
getSizeInstrProc</H3>
<PRE>
public int <B>getSizeInstrProc</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzioni in procedure division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeInstrProc</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeInstrProc(int)"><!-- --></A><H3>
setSizeInstrProc</H3>
<PRE>
public void <B>setSizeInstrProc</B>(int&nbsp;sizeInstrProc)</PRE>
<DL>
<DD>Imposta il numero di istruzioni in procedure division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeInstrProc</CODE> - the sizeInstrProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeInstrData()"><!-- --></A><H3>
getSizeInstrData</H3>
<PRE>
public int <B>getSizeInstrData</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzioni di definizione dati in data division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeInstrData</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeInstrData(int)"><!-- --></A><H3>
setSizeInstrData</H3>
<PRE>
public void <B>setSizeInstrData</B>(int&nbsp;sizeInstrData)</PRE>
<DL>
<DD>Imposta il numero di istruzioni di definizione dati in data division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeInstrData</CODE> - the sizeInstrData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeInstrDataFile()"><!-- --></A><H3>
getSizeInstrDataFile</H3>
<PRE>
public int <B>getSizeInstrDataFile</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzioni di definizione dati in data division, File section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeInstrDataFile</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeInstrDataFile(int)"><!-- --></A><H3>
setSizeInstrDataFile</H3>
<PRE>
public void <B>setSizeInstrDataFile</B>(int&nbsp;sizeInstrDataFile)</PRE>
<DL>
<DD>Imposta il numero di istruzioni di definizione dati in data division, File section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeInstrDataFile</CODE> - the sizeInstrDataFile to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeInstrDataWorking()"><!-- --></A><H3>
getSizeInstrDataWorking</H3>
<PRE>
public int <B>getSizeInstrDataWorking</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzioni di definizione dati in data division, Working-storage section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeInstrDataWorking</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeInstrDataWorking(int)"><!-- --></A><H3>
setSizeInstrDataWorking</H3>
<PRE>
public void <B>setSizeInstrDataWorking</B>(int&nbsp;sizeInstrDataWorking)</PRE>
<DL>
<DD>Imposta il numero di istruzioni di definizione dati in data division, Working-storage section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeInstrDataWorking</CODE> - the sizeInstrDataWorking to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeInstrDataLinkage()"><!-- --></A><H3>
getSizeInstrDataLinkage</H3>
<PRE>
public int <B>getSizeInstrDataLinkage</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzioni di definizione dati in data division, Linkage section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeInstrDataLinkage</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeInstrDataLinkage(int)"><!-- --></A><H3>
setSizeInstrDataLinkage</H3>
<PRE>
public void <B>setSizeInstrDataLinkage</B>(int&nbsp;sizeInstrDataLinkage)</PRE>
<DL>
<DD>Imposta il numero di istruzioni di definizione dati in data division, Linkage section<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeInstrDataLinkage</CODE> - the sizeInstrDataLinkage to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSource()"><!-- --></A><H3>
getSizeSource</H3>
<PRE>
public int <B>getSizeSource</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente, con i copy non esplosi<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSource</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSource(int)"><!-- --></A><H3>
setSizeSource</H3>
<PRE>
public void <B>setSizeSource</B>(int&nbsp;sizeSource)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente, con i copy non esplosi<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSource</CODE> - the sizeSource to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSourceProc()"><!-- --></A><H3>
getSizeSourceProc</H3>
<PRE>
public int <B>getSizeSourceProc</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente di procedure division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSourceProc</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSourceProc(int)"><!-- --></A><H3>
setSizeSourceProc</H3>
<PRE>
public void <B>setSizeSourceProc</B>(int&nbsp;sizeSourceProc)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente di procedure division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSourceProc</CODE> - the sizeSourceProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSourceData()"><!-- --></A><H3>
getSizeSourceData</H3>
<PRE>
public int <B>getSizeSourceData</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente di di data division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSourceData</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSourceData(int)"><!-- --></A><H3>
setSizeSourceData</H3>
<PRE>
public void <B>setSizeSourceData</B>(int&nbsp;sizeSourceData)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente di data division<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSourceData</CODE> - the sizeSourceData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSourceBlank()"><!-- --></A><H3>
getSizeSourceBlank</H3>
<PRE>
public int <B>getSizeSourceBlank</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente vuote<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSourceBlank</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSourceBlank(int)"><!-- --></A><H3>
setSizeSourceBlank</H3>
<PRE>
public void <B>setSizeSourceBlank</B>(int&nbsp;sizeSourceBlank)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente vuote<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSourceBlank</CODE> - the sizeSourceBlank to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSourceProcBlank()"><!-- --></A><H3>
getSizeSourceProcBlank</H3>
<PRE>
public int <B>getSizeSourceProcBlank</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente vuote di procedure division<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSourceProcBlank</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSourceProcBlank(int)"><!-- --></A><H3>
setSizeSourceProcBlank</H3>
<PRE>
public void <B>setSizeSourceProcBlank</B>(int&nbsp;sizeSourceProcBlank)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente vuote di procedure division<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSourceProcBlank</CODE> - the sizeSourceProcBlank to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeSourceDataBlank()"><!-- --></A><H3>
getSizeSourceDataBlank</H3>
<PRE>
public int <B>getSizeSourceDataBlank</B>()</PRE>
<DL>
<DD>Restituisce il numero totale di righe sorgente vuote di data division<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeSourceDataBlank</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeSourceDataBlank(int)"><!-- --></A><H3>
setSizeSourceDataBlank</H3>
<PRE>
public void <B>setSizeSourceDataBlank</B>(int&nbsp;sizeSourceDataBlank)</PRE>
<DL>
<DD>Imposta il numero totale di righe sorgente vuote di data division<br>
 <p>
 Si considerano le righe nulle o quelle con spazi da colonna 7 a 72-<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeSourceDataBlank</CODE> - the sizeSourceDataBlank to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeCommProc()"><!-- --></A><H3>
getSizeCommProc</H3>
<PRE>
public int <B>getSizeCommProc</B>()</PRE>
<DL>
<DD>Restituisce il numero di righe commento di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeCommProc</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeCommProc(int)"><!-- --></A><H3>
setSizeCommProc</H3>
<PRE>
public void <B>setSizeCommProc</B>(int&nbsp;sizeCommProc)</PRE>
<DL>
<DD>Imposta il numero di righe commento di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeCommProc</CODE> - the sizeCommProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeCommData()"><!-- --></A><H3>
getSizeCommData</H3>
<PRE>
public int <B>getSizeCommData</B>()</PRE>
<DL>
<DD>Restituisce il numero di righe commento di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeCommData</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeCommData(int)"><!-- --></A><H3>
setSizeCommData</H3>
<PRE>
public void <B>setSizeCommData</B>(int&nbsp;sizeCommData)</PRE>
<DL>
<DD>Imposta il numero di righe commento di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeCommData</CODE> - the sizeCommData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getSizeComm()"><!-- --></A><H3>
getSizeComm</H3>
<PRE>
public int <B>getSizeComm</B>()</PRE>
<DL>
<DD>Restituisce il numero di righe commento di tutto il programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the sizeComm</DL>
</DD>
</DL>
<HR>

<A NAME="setSizeComm(int)"><!-- --></A><H3>
setSizeComm</H3>
<PRE>
public void <B>setSizeComm</B>(int&nbsp;sizeComm)</PRE>
<DL>
<DD>Imposta il numero di righe commento di tutto il programma.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sizeComm</CODE> - the sizeComm to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsShiftedRight()"><!-- --></A><H3>
getNumRowsShiftedRight</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsShiftedRight</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente shiftate a destra.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta istruzioni prima di col 8<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowShiftedRight</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsShiftedRight(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsShiftedRight</H3>
<PRE>
public void <B>setNumRowsShiftedRight</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowShiftedRight)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente shiftate a destra.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta istruzioni prima di col 8<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowShiftedRight</CODE> - the al_numRowShiftedRight to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsShiftedLeft()"><!-- --></A><H3>
getNumRowsShiftedLeft</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsShiftedLeft</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente shiftate a sinistra.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta label dopo col 8<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowShiftedLeft</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsShiftedLeft(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsShiftedLeft</H3>
<PRE>
public void <B>setNumRowsShiftedLeft</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowShiftedLeft)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente shiftate a sinistra.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta label dopo col 8<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowShiftedLeft</CODE> - the al_numRowShiftedLeft to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsWithBadChar()"><!-- --></A><H3>
getNumRowsWithBadChar</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsWithBadChar</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente con caratteri speciali e tabulazioni.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta sorgenti di questo tipo<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowWithBadChar</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsWithBadChar(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsWithBadChar</H3>
<PRE>
public void <B>setNumRowsWithBadChar</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadChar)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente con caratteri speciali e tabulazioni.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta sorgenti di questo tipo<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowWithBadChar</CODE> - the al_numRowWithBadChar to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsWithDataUnclosed()"><!-- --></A><H3>
getNumRowsWithDataUnclosed</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsWithDataUnclosed</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente di definizione dati non chiusi da un punto finale.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta definizioni dati non chiuse da un punto.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowWithDataUnclosed</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsWithDataUnclosed(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsWithDataUnclosed</H3>
<PRE>
public void <B>setNumRowsWithDataUnclosed</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithDataUnclosed)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente di definizione dati non chiusi da un punto finale.<br>
 <p>
 Ciò a causa anomalia Cobol MF che accetta definizioni dati non chiuse da un punto.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowWithDataUnclosed</CODE> - the al_numRowWithDataUnclosed to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsWithBadCoding()"><!-- --></A><H3>
getNumRowsWithBadCoding</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsWithBadCoding</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente con codifiche deprecate.<br>
 <p>
 Per esempio literal con dentro gli stessi delimiter come "AA""BBB"<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowWithBadCoding</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsWithBadCoding(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsWithBadCoding</H3>
<PRE>
public void <B>setNumRowsWithBadCoding</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadCoding)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente con codifiche deprecate.<br>
 <p>
 Per esempio literal con dentro gli stessi delimiter come "AA""BBB"<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowWithBadCoding</CODE> - the al_numRowWithBadCoding to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowsWithBadCodingSql()"><!-- --></A><H3>
getNumRowsWithBadCodingSql</H3>
<PRE>
public java.util.ArrayList&lt;java.lang.Integer&gt; <B>getNumRowsWithBadCodingSql</B>()</PRE>
<DL>
<DD>Restituisce i numeri di riga sorgente con codifiche deprecate in statements Sql.<br>
 <p>
 Per esempio stmt sql con INTO:var o INTO : var<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the al_numRowWithBadCodingSql</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowsWithBadCodingSql(java.util.ArrayList)"><!-- --></A><H3>
setNumRowsWithBadCodingSql</H3>
<PRE>
public void <B>setNumRowsWithBadCodingSql</B>(java.util.ArrayList&lt;java.lang.Integer&gt;&nbsp;al_numRowWithBadCodingSql)</PRE>
<DL>
<DD>Imposta i numeri di riga sorgente con codifiche deprecate in statements Sql.<br>
 <p>
 Per esempio stmt sql con INTO:var o INTO : var<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>al_numRowWithBadCodingSql</CODE> - the al_numRowWithBadCodingSql to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowStartIdentification()"><!-- --></A><H3>
getNumRowStartIdentification</H3>
<PRE>
public int <B>getNumRowStartIdentification</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di inizio di identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowStartIdentification</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowStartIdentification(int)"><!-- --></A><H3>
setNumRowStartIdentification</H3>
<PRE>
public void <B>setNumRowStartIdentification</B>(int&nbsp;numRowStartIdentification)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di inizio di identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowStartIdentification</CODE> - the numRowStartIdentification to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowEndIdentification()"><!-- --></A><H3>
getNumRowEndIdentification</H3>
<PRE>
public int <B>getNumRowEndIdentification</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di fine di identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowEndIdentification</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowEndIdentification(int)"><!-- --></A><H3>
setNumRowEndIdentification</H3>
<PRE>
public void <B>setNumRowEndIdentification</B>(int&nbsp;numRowEndIdentification)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di fine di identification division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowEndIdentification</CODE> - the numRowEndIdentification to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowStartEnvironment()"><!-- --></A><H3>
getNumRowStartEnvironment</H3>
<PRE>
public int <B>getNumRowStartEnvironment</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di inizio di environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowStartEnvironment</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowStartEnvironment(int)"><!-- --></A><H3>
setNumRowStartEnvironment</H3>
<PRE>
public void <B>setNumRowStartEnvironment</B>(int&nbsp;numRowStartEnvironment)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di inizio di environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowStartEnvironment</CODE> - the numRowStartEnvironment to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowEndEnvironment()"><!-- --></A><H3>
getNumRowEndEnvironment</H3>
<PRE>
public int <B>getNumRowEndEnvironment</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di fine di environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowEndEnvironment</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowEndEnvironment(int)"><!-- --></A><H3>
setNumRowEndEnvironment</H3>
<PRE>
public void <B>setNumRowEndEnvironment</B>(int&nbsp;numRowEndEnvironment)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di fine di environment division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowEndEnvironment</CODE> - the numRowEndEnvironment to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowStartData()"><!-- --></A><H3>
getNumRowStartData</H3>
<PRE>
public int <B>getNumRowStartData</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di inizio di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowStartData</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowStartData(int)"><!-- --></A><H3>
setNumRowStartData</H3>
<PRE>
public void <B>setNumRowStartData</B>(int&nbsp;numRowStartData)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di inizio di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowStartData</CODE> - the numRowStartData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowEndData()"><!-- --></A><H3>
getNumRowEndData</H3>
<PRE>
public int <B>getNumRowEndData</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di fine di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowEndData</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowEndData(int)"><!-- --></A><H3>
setNumRowEndData</H3>
<PRE>
public void <B>setNumRowEndData</B>(int&nbsp;numRowEndData)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di fine di data division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowEndData</CODE> - the numRowEndData to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowStartProc()"><!-- --></A><H3>
getNumRowStartProc</H3>
<PRE>
public int <B>getNumRowStartProc</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di inizio di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowStartProc</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowStartProc(int)"><!-- --></A><H3>
setNumRowStartProc</H3>
<PRE>
public void <B>setNumRowStartProc</B>(int&nbsp;numRowStartProc)</PRE>
<DL>
<DD>Imposta il numero riga sorgente di inizio di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowStartProc</CODE> - the numRowStartProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumRowEndProc()"><!-- --></A><H3>
getNumRowEndProc</H3>
<PRE>
public int <B>getNumRowEndProc</B>()</PRE>
<DL>
<DD>Restituisce il numero riga sorgente di fine di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numRowEndProc</DL>
</DD>
</DL>
<HR>

<A NAME="setNumRowEndProc(int)"><!-- --></A><H3>
setNumRowEndProc</H3>
<PRE>
public void <B>setNumRowEndProc</B>(int&nbsp;numRowEndProc)</PRE>
<DL>
<DD>Imòposta il numero riga sorgente di fine di procedure division.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numRowEndProc</CODE> - the numRowEndProc to set</DL>
</DD>
</DL>
<HR>

<A NAME="getRowDivision(int)"><!-- --></A><H3>
getRowDivision</H3>
<PRE>
public <A HREF="../enums/EnumCobolReservedWords.html" title="enum in enums">EnumCobolReservedWords</A> <B>getRowDivision</B>(int&nbsp;numRow)</PRE>
<DL>
<DD>Restituisce la divisione cobol del numero di riga sorgente fornito.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the EnumCobolReservedWords division</DL>
</DD>
</DL>
<HR>

<A NAME="getNumInstrInDivision(int)"><!-- --></A><H3>
getNumInstrInDivision</H3>
<PRE>
public int <B>getNumInstrInDivision</B>(int&nbsp;numRow)</PRE>
<DL>
<DD>Restituisce il numero di istruzione, nella divisione cobol di appartenenza,
 del numero di riga sorgente fornito.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the EnumCobolReservedWords division</DL>
</DD>
</DL>
<HR>

<A NAME="getIfNestingLevel(int)"><!-- --></A><H3>
getIfNestingLevel</H3>
<PRE>
public int <B>getIfNestingLevel</B>(int&nbsp;numInstrIf)</PRE>
<DL>
<DD>Restituisce il numero di IF annidate, a partire dall'istruzione IF origine<br>
 <p>
 Le ELSE interrompono il livello di annidamento.<br>
 <p>
 Per esempio la seguente struttura restituisce 2<br>
 <p>
 IF A<br>
   IF B<br>
      IF C<br>
      ..<br>
      ..<br>
 <p>
 La seguente struttura restituisce invece 1<br>
 <p>
 IF A<br>
   IF B<br>
   ...
   ELSE
      IF C<br>
        IF D<br>
          ..<br>
           ..<br>
 <p>
 Se il numero istruzione fornito non corrisponde a una istruzione IF<br>
 restituisce 0.<br>
 <p>
 Se non ci sono IF annidate restituisce 0.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the nesting level number</DL>
</DD>
</DL>
<HR>

<A NAME="getIfTrueEntries(int)"><!-- --></A><H3>
getIfTrueEntries</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&gt; <B>getIfTrueEntries</B>(int&nbsp;numInstrIf)</PRE>
<DL>
<DD>Restituisce le istruzioni del ramo TRUE di una istruzione IF.<br>
 <p>
 Nel caso di una IF senzza ELSE e IF nidificate restituisce semplicemente
 tutte le istruzioni sotto condizione.<br>
 Nel caso di IF con ELSE restituisce tutte le istruzioni fino a ELSE esclusa.<br>
 <br>
 Le istruzioni restituite possono contenere a loro volta altre strutture IF/THEN/ELSE.<br>
 In caso di nessuna istruzione presente, ovvero di ELSE immediatamente dopo la IF,<br>
 restituisce un array vuoto.<br>
 <p>
 Per esempio la seguente struttura restituisce IF A, IF B e le istruzioni successive<br>
 <p>
 IF A<br>
   IF B<br>
      IF C<br>
      ..<br>
      ..<br>
 <p>
 La seguente struttura restituisce invece MOVE ..<br>
 <p>
 IF A<br>
   MOVE <br>
   ...
 ELSE
      IF C<br>
        IF D<br>
          ..<br>
           ..<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>al instructions in TRUE branch</DL>
</DD>
</DL>
<HR>

<A NAME="getIfFalseEntries(int)"><!-- --></A><H3>
getIfFalseEntries</H3>
<PRE>
public java.util.ArrayList&lt;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer">ProgramCobolEntry</A>&lt;? extends <A HREF="../analyzer/Instruction.html" title="class in analyzer">Instruction</A>&gt;&gt; <B>getIfFalseEntries</B>(int&nbsp;numInstrIf)</PRE>
<DL>
<DD>Restituisce le istruzioni del ramo ELSE di una istruzione IF ovvero per condizione FALSE.<br>
 <p>
 Nel caso di una IF senza ELSE restituisce un insieme vuoto.<br>
 Nel caso di END-IF immediatamente dopo la ELSE restituisce un insieme vuoto.<br>
 Nel caso di IF con ELSE restituisce tutte le istruzioni successive alla ELSE fino<br>
 all'istruzione precedente alla END-IF o all'ultima istruzione, se chiusa da un puno.<br>
 Le istruzioni restituite possono contenere a loro volta altre strutture IF/THEN/ELSE.<br>
 <p>
 Per esempio la seguente struttura restituisce IF A, IF B e le istruzioni successive<br>
 restituiscono MOVE ... <br>
 <p>
 IF A<br>
   IF B<br>
      IF C<br>
      ..<br>
      ELSE<br>
      ... <br>
      END-IF<br>
   END-IF<br>
 ELSE<br>
   MOVE ..<br>
   ....<br>
 END-IF<br>
 <p>
 Consideruiamo La seguente struttura:<br>
 <p>
 IF A<br>
   IF B<br>
     IF C<br>
       ,,,<br>
     ELSE<br>
       MOVE D<br>
   ELSE<br>
 ELSE<br>
   MOVE E.<br>
 <p>
 Applicata a IF A restituisce MOVE E<br>
 Applicata a IF B restituisce insieme vuoto<br>
 Applicata a IF C restituisce MOVE D<br>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>al instructions in TRUE branch</DL>
</DD>
</DL>
<HR>

<A NAME="isIfWithElse(int)"><!-- --></A><H3>
isIfWithElse</H3>
<PRE>
public boolean <B>isIfWithElse</B>(int&nbsp;numInstrIf)</PRE>
<DL>
<DD>Restituisce se presente il ramo ELSE di una istruzione IF, ovvero per condizione FALSE.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>if is there Else statement</DL>
</DD>
</DL>
<HR>

<A NAME="getNumInstrLinkageSection()"><!-- --></A><H3>
getNumInstrLinkageSection</H3>
<PRE>
public int <B>getNumInstrLinkageSection</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzione, in Data Division, <br>
 dello statement Linkage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numInstrLinkageSection</DL>
</DD>
</DL>
<HR>

<A NAME="setNumInstrLinkageSection(int)"><!-- --></A><H3>
setNumInstrLinkageSection</H3>
<PRE>
public void <B>setNumInstrLinkageSection</B>(int&nbsp;numInstrLinkageSection)</PRE>
<DL>
<DD>Imposta il numero di istruzione, in Data Division, <br>
 dello statement Linkage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numInstrLinkageSection</CODE> - the numInstrLinkageSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="getNumInstrWsStorageSection()"><!-- --></A><H3>
getNumInstrWsStorageSection</H3>
<PRE>
public int <B>getNumInstrWsStorageSection</B>()</PRE>
<DL>
<DD>Restituisce il numero di istruzione, in Data Division, <br>
 dello statement Working-Storage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the numInstrWsStorageSection</DL>
</DD>
</DL>
<HR>

<A NAME="setNumInstrWsStorageSection(int)"><!-- --></A><H3>
setNumInstrWsStorageSection</H3>
<PRE>
public void <B>setNumInstrWsStorageSection</B>(int&nbsp;numInstrWsStorageSection)</PRE>
<DL>
<DD>Imposta il numero di istruzione, in Data Division, <br>
 dello statement Working-Storage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>numInstrWsStorageSection</CODE> - the numInstrWsStorageSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="isThereLinkageSection()"><!-- --></A><H3>
isThereLinkageSection</H3>
<PRE>
public boolean <B>isThereLinkageSection</B>()</PRE>
<DL>
<DD>Restituisce se presente, in Data Division, <br>
 lo statement Working-Storage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isThereLinkageSection</DL>
</DD>
</DL>
<HR>

<A NAME="setLinkageSection(boolean)"><!-- --></A><H3>
setLinkageSection</H3>
<PRE>
public void <B>setLinkageSection</B>(boolean&nbsp;isThereLinkageSection)</PRE>
<DL>
<DD>Imposta se presente, in Data Division, <br>
 lo statement Working-Storage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isThereLinkageSection</CODE> - the isThereLinkageSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="isThereWsStorageSection()"><!-- --></A><H3>
isThereWsStorageSection</H3>
<PRE>
public boolean <B>isThereWsStorageSection</B>()</PRE>
<DL>
<DD>Restituisce se presente, in Data Division, <br>
 lo statement Linkage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the isThereWsStorageSection</DL>
</DD>
</DL>
<HR>

<A NAME="getAnalysisMapGoTo()"><!-- --></A><H3>
getAnalysisMapGoTo</H3>
<PRE>
public java.util.Map&lt;java.lang.Integer,java.lang.Object[]&gt; <B>getAnalysisMapGoTo</B>()</PRE>
<DL>
<DD>Restituisce la map di servizio GoTo generata in fase di analisi.<br>
 <p>
 Necessaria per la generazione del grafo di programma come processo<br>
 a livello di programma post analisi.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the map_GoTo</DL>
</DD>
</DL>
<HR>

<A NAME="setAnalysisMapGoTo(java.util.Map)"><!-- --></A><H3>
setAnalysisMapGoTo</H3>
<PRE>
public void <B>setAnalysisMapGoTo</B>(java.util.Map&lt;java.lang.Integer,java.lang.Object[]&gt;&nbsp;mapGoTo)</PRE>
<DL>
<DD>Imposta la map di servizio GoTo generata in fase di analisi.<br>
 <p>
 Necessaria per la generazione del grafo di programma come processo<br>
 a livello di programma post analisi.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mapGoTo</CODE> - the map_GoTo to set</DL>
</DD>
</DL>
<HR>

<A NAME="getAnalysisMapLabelSection()"><!-- --></A><H3>
getAnalysisMapLabelSection</H3>
<PRE>
public java.util.Map&lt;java.lang.String,java.lang.Object[]&gt; <B>getAnalysisMapLabelSection</B>()</PRE>
<DL>
<DD>Restituisce la map di servizio Label/Section generata in fase di analisi.<br>
 <p>
 Necessaria per la generazione del grafo di programma come processo<br>
 a livello di programma post analisi.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the map_LabelSection</DL>
</DD>
</DL>
<HR>

<A NAME="setAnalysisMapLabelSection(java.util.Map)"><!-- --></A><H3>
setAnalysisMapLabelSection</H3>
<PRE>
public void <B>setAnalysisMapLabelSection</B>(java.util.Map&lt;java.lang.String,java.lang.Object[]&gt;&nbsp;mapLabelSection)</PRE>
<DL>
<DD>Imposta la map di servizio Label/Section generata in fase di analisi.<br>
 <p>
 Necessaria per la generazione del grafo di programma come processo<br>
 a livello di programma post analisi.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mapLabelSection</CODE> - the map_LabelSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="setWsStorageSection(boolean)"><!-- --></A><H3>
setWsStorageSection</H3>
<PRE>
public void <B>setWsStorageSection</B>(boolean&nbsp;isThereWsStorageSection)</PRE>
<DL>
<DD>Imposta se presente, in Data Division, <br>
 lo statement Linkage Section.<br>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>isThereWsStorageSection</CODE> - the isThereWsStorageSection to set</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ProgramCobol.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../analyzer/ProgramCallsStack.InnerCallStackEntry.html" title="class in analyzer"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../analyzer/ProgramCobolEntry.html" title="class in analyzer"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html?analyzer/ProgramCobol.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="ProgramCobol.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_analyzer.Program">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
