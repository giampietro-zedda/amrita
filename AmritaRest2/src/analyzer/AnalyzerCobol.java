
package analyzer;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.Map.Entry;

import utilities.DateTimeService;
import utilities.NumericService;
import utilities.StringService;
import analyzer.Instruction.InnerSymbolEntry;
import analyzer.InstructionCobolDataItem.InnerConditionValueEntry;
import dao.DAOImplMetricScenario;
import dao.DAOImplObject;
import dao.IDAOMetricScenario;
import dao.IDAOObject;

import entities.EntityCopyEntityDefinition;
import entities.EntityDynamicField;
import entities.EntityDynamicFieldSub;
import entities.EntityDynamicFieldSubValue;
import entities.EntityMetricValue;
import entities.EntityMetricScenario;
import entities.EntityMetricViolation;
import entities.EntityObject;
import entities.EntityObjectOption;
import entities.EntityRelation;
import entities.EntityRelationOrigin;
import entities.EntityWhereUsedItem;
import enums.EnumAmritaExceptionError;
import enums.EnumCobolFigurativeConstants;
import enums.EnumCobolOperator;
import enums.EnumCobolReservedWords;
import enums.EnumCobolUsage;
import enums.EnumCobolValueType;
import enums.EnumDataItemGeneric;
import enums.EnumDataItemLevel;
import enums.EnumDataItemSystemEnvironment;
import enums.EnumDataItemType;
import enums.EnumExpressionItem;

import enums.EnumInstrDataCategory;
import enums.EnumLanguageItemInstr;
import enums.EnumMessageType;
import enums.EnumMetricsQualityCharacteristics;
import enums.EnumMetricsQualityFactors;
import enums.EnumMetricsScope;
import enums.EnumMetricsSqualeRating;
import enums.EnumMetricsViolation;
import enums.EnumMetricsViolationSeverity;
import enums.EnumObject;
import enums.EnumObjectOption;
import enums.EnumObjectStatus;
import enums.EnumPrecompilerReservedWords;
import enums.EnumRelation;
import enums.EnumRelationSourceProcess;
import enums.EnumRelationType;
import enums.EnumSourceType;
import enums.EnumSqlPredicate;
import enums.EnumSymbolType;
import enums.EnumThresholds;
import enums.EnumTypeProcessAnalysis;
import enums.EnumUserExit;
import enums.EnumWhereUsedType;
import enums.EnumWhereUsedTypeAlias;
import exception.ExceptionAmrita;

/**
 * Copyright (c) 2009-2011 e-Amrita - Ing. Giampietro Zedda   Turin (ITALY)
 * 
 * <h1>
 * AnalyzerCobol
 * </h1>
 * <p>
 * Questa classe gestisce l'analisi di un programma Cobol Completo o di un modulo copy. <br>
 * <p>
 * Riceve in input il descrittore completo del sorgente programma come oggetto {@link SourceInput} 
 * e produce un file nella directory di default con l'oggetto programma serializzato. <br>
 * Il nome dell'oggetto è <b>nome.program</b>.<br>
 * <p>
 * Nel caso il programma analizzato contenga degli statement copy da includere allora, viene verificato se sono già
 * stati analizzati e serializzati. In questo caso vengono inclusi direttamente nel programma.<br>
 * Tuttavia, se lo statement copy contiene dei Replacing By, viene verificato per ogni istruzione sorgente del
 * copy da includere, se esiste qualche valore da sostituire. In questo caso viene attivata l'analisi on fly per il
 * solo statement del copy interessato. Questa procedura garantisce sempre la corretta inclusione dei copy.
 * Quindi è possibile che il modulo copy da includere non sia ancora stato analizzato nel sistema e, in questo
 * caso, si tenta di analizzarlo prima di procedere all'inclusione attraverso una nuova istanza della classe
 * {@link AnalyzerCobolCopyProcedure} o {@link AnalyzerCobolCopyData}. <br>
 * <p>
 * L'analisi del programma produce un oggetto serializzato istanza della classe {@link ProgramCobol} che descrive
 * il programma in ogni dettaglio.<br>
 * Le metriche relative al programma analizzato sono invece memorizzate nella classe {@link Metrics} che viene 
 * serializzata insieme al programma.<br>
 * Se un moduòo copy richiamato non è stato ancora analizzato,  viene attivata l'analisi ricorsiva.<br>
 * Il riferimento alle metriche del modulo copy viene memorizzato nell'oggetto {@link CopyCobol}.<br>
 * <p>
 * Le logiche invece comuni a tutti i processi di analisi, indipendentemente dal linguaggio e dalla tipologia,
 * sono codificate nella classe {@link Analyzer}, dalla quale questa classe eredita.
 *
 * @author Giampietro Zedda
 * @version 1.0.0
 * @since 15/02/2010
 * @see Analyzer
 * @see GraphManager
 * @see Instruction
*/

public class AnalyzerCobol extends Analyzer implements AmritaConstants {
	

	////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Variabili di istanza di reference a servizi generalizzati  e centralizzati                                           
    ////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Informazioni contesto ricorsivo di esecuzione
	private InnerContextAnalysis ictx = null;

	// Descrittore completo programma sotto analisi.
	// Tutto il processo di analisi fa riferimento direttamente alle strutture di controllo
	// di Program, madre di programCobol e principalmente alla mappa map_Symbol, che viene aggiornata
	// ad ogni istruzione analizzata. I simboli non risolti vengono restituiti da unXrefSymbols(), in programCobol
	private ProgramCobol programCobol = null;                  					   

	// Descrittore istruzione copy sotto analsi.
	// Il copy è descritto da un array<ProgramCobolEntry<? extends Instruction>> 
	private CopyCobol copyCobol = null;
	
    // Gestore centralizzato aggiornamenti db cumulativi.
    private AnalyzerDbInfo analyzerDbInfo = null;

	// Analizzatore specifico Ibm Cics.
	// Utilizzato per l'analisi sorgente delle istruzioni Exec Cics.
    private AnalyzerCicsInstr analyzerCics = null;
    
	// Analizzatore specifico Sql (IBM).
	// Utilizzato per l'analisi sorgente delle istruzioni Exec Sql.
    private AnalyzerSql analyzerSql = null;
    
    // Gestore generalizzato logiche applicative.
    // Utilizzato per determinare i valori dinamici assunti dalle variabili.
    private LogicSamePgm logicSamePgm = null;       
    private LogicSpreadedPgm logicSpreadedPgm = null;       
    private LogicInfoDynamic logicInfoDynamic = null;
    
    // Indicatore modalità di attivazione AnalyzerCobol.
    // Se impostato a true indica che AnalyzerCobol è stato attivato non
    // per effettuare l'analisi completa del programma ma per elaborazioni
    // post analisi preliminare che utilizzano parzialmente codice condiviso.
    private boolean isProcessPgmlevel = false;
  
    // Indicatore modalità di attivazione AnalyzerCobol.
    // Se impostato a true indica che AnalyzerCobol è stato attivato non
    // per effettuare l'analisi completa del programma ma per elaborazioni
    // post analisi preliminare che utilizzano parzialmente codice condiviso.
    private boolean isProcessSystemlevel = false;
  
    
	////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Variabili di istanza generali per analisi sorgente                                                   
    ////////////////////////////////////////////////////////////////////////////////////////////////////////	

    // Parole riservate per identificazione istruzione.
    // Key  = parola valida di inizio istruzione o operando o operatore etc.
    // Dati = ArrayList di insiemi di sequenze di parole identificanti una istruzione valida
    // Con questa Map si gestisce l'individuazione di qualsiasi tipo di istruzione.
    // La Map viene caricata dal costruttore a partire da EnumCobolReservedWords
    public Map<String, ArrayList<InnerInstructionWordsEntry>> map_ReservedWords;	

    // Data item non definiti nel programma.
    // Key  = nome campo (es. EIBTRMID)
    // Dati = Enum con tipologia ambiente di appartenenza (es. CICS_PRECOMPILER)
    // Se il data item è definito in questa map allora non è un campo nativo Cobol
    public Map<String, EnumDataItemSystemEnvironment> map_DataItemSystemEnvironment = null;
    
	// Divisioni e sezioni programma correntemente sotto analisi
    public EnumCobolReservedWords activeDivisionArea = null;					  // Come Data Division
    public EnumCobolReservedWords activeSectionArea = null; 					  // Come Working-Storage Section, File Section ...
    public EnumCobolReservedWords activeControlArea = null; 					  // Come File-Control e I-O. Control.
 
	// Valori correnti generali
//    private UserExitInfo userExitInfoPgm = null;                                  // Sistema/sottosistema del programma sotto analisi
	public String pgmNameUnderParsing = "" ;             						  // Nome programma attualmente sotto analisi           	
	public String copyNameUnderParsing = "" ;             						  // Nome copy attualmente sotto analisi           	
	private String programName = "";                 							  // Coincide con pgmNameUnderParsing
    private int idxPgmCopyInDbObject = 0;                                         // Indice oggetto pgmo copy in struttura db
    
	// Valori correnti numeri istruzione nelle varie divisioni
	private int curNumDefIdDiv = 0;                    							  // Numero di definizione corrente Identification division
	private int curNumDefEnvDiv = 0;                    						  // Numero di definizione corrente Environment division
	private int curNumDefDataDiv = 0;                           				  // Numero di definizione corrente data division
    private int curNumDefProcDiv = 0;                           				  // Numero di definizione corrente procedure division
    
	/////////////////////////////////////////////////////////////////////////////
	// Campi  e strutture di servizio  
    /////////////////////////////////////////////////////////////////////////////
  
    private Map<String, InnerInternalProcedure> map_InternalProcedure = null;// Per gestione sottografi con procedure interne 
    private Map<String, Object[]> map_CopyDetected = null; 			              // Key  = copy name
    																			  // Data = Object[0] = True se tracciato prodotto
																				  //        Object[1] = ArrayList<InstructionCobol>   Copy stmt
																				  //        Object[2] = ArrayList<CopyCobol>          Copy object
    
	// GraphManager: map per connessione finale nodi BRANCH_INTERNAL a nodi JOIN (GoTo a Label)
    private Map<Integer, Object[]> map_GoTo = null;        		                 // Coppia nodo GoTo   /   Object[2]
																			     //                        Object[0] = GraphNode 
																			     //                        Object[1] = String[] labels|sections
																			                                                                                 
    private Map<String, Object[]> map_LabelSection = null;				         // Coppia label|section / Object[6]
																				 //                        Object[0] = GraphNode         
																			     //                        Object[1] = ArrayList<int> goTo instructions  
    																			 //                        Object[2] = ArrayList<int> perform instructions  
	 																			 //                        Object[3] = Int numInstr (prima definizione)       
    																			 //                        Object[4] = ArrayList<int> def instructions   
                                                                                 //                        Object[5] = Boolean true se section
    private Set<String> hashSet_ImplicitData = null;
    
    // Metriche per il programma sotto analisi.
    // Saranno serializzate insieme all'ogggetto ProgramCobol.
    private Metrics metricsProgram = null;							           // Programma nel suo complesso
    private Metrics metricsProgramMainline = null;					           // Mainline
 	private ArrayList<Metrics> al_metricsProgramSection = null;		           // Section/paragrafi richiamati
	private EntityMetricValue entityMetricProgram = null;                      // Di servizio
 	
 	// Violazioni per tipo/section.
 	// Utilizzata per l'individuazione delle violazioni e l'inserimentio su db a fine elaborazione
  	private Map<String, String> map_metricViolation = null;						// Key  = type violation + section Data = list num instr ..
  	private Map<String, String> map_metricViolationRow = null;					// Key  = type violation + section Data = list num row ..
  	private Map<String, String> map_metricViolationRowCopy = null;				// Key  = type violation + section Data = Value violazione (es. soglia)
 	private Map<String, String> map_metricViolationValue = null;				// Key  = type violation + section Data = Value violazione (es. soglia)

 	// Gestione durata operazioni
 	private long timeMSStart = 0;
 	private long timeMSEnd = 0;
 	private long timeMSElapsed = 0;
  	
    /**
	 * Costruttore  per analisi sorgente
	 */
	public AnalyzerCobol(UserConfiguration sd, ExecutionDirectives di) {
		super(sd, di);
		 
	    // Inizializzazioni varie
		this.activeDivisionArea = EnumCobolReservedWords.ID_DIVISION;				// Il programma inizia sempre per ID. DIVISION.
		this.activeSectionArea = EnumCobolReservedWords.NOT_ASSIGNED;
		this.activeControlArea = EnumCobolReservedWords.NOT_ASSIGNED; 
		this.analyzerDbInfo = new AnalyzerDbInfo(sd, di, programName);
		

		// Allocazione Map parole riservate/Enum per parsing sorgente
		// Allocazione Map con i copy incontrati nel programma
	    // Map con informazioni su procedure interne richiamate
	    // Map con goTo a label
	    // Map con label e nodo, goTo caller e perform caller
		this.map_ReservedWords = new HashMap<String, ArrayList<InnerInstructionWordsEntry>>(1000);
		this.map_DataItemSystemEnvironment = new HashMap<String, EnumDataItemSystemEnvironment>(100);
		this.map_CopyDetected = new HashMap<String, Object[]>();
		this.map_InternalProcedure = new HashMap<String, InnerInternalProcedure> ();
	    this.map_GoTo = new HashMap<Integer, Object[]> ();        		        	// NumInstr goTo -> nodo goTo / String[] label
	    this.map_LabelSection = new HashMap<String, Object[]> () ;				    // label         -> nodo label, goTo, Perform, numInstr
        
	    // Allocazione set con nomi campi da definire implicitamente prima di PROCEDURE
	    hashSet_ImplicitData = new HashSet<String>();
	    
	    // Scan enumerazione con parole riservate Cobol gestite
		for (EnumCobolReservedWords en_reservedWord : EnumCobolReservedWords.values()) {
			if (en_reservedWord == EnumCobolReservedWords.NOT_ASSIGNED) {
				continue;
			}
			putMapReservedWords(en_reservedWord); // -> map_ReservedWords
		}

		// Scan enumerazione con data items dei vari ambienti (gestiti dai precompilatori)
		for (EnumDataItemSystemEnvironment en_DataItemSystemEnvironment : EnumDataItemSystemEnvironment.values()) {
			if (en_DataItemSystemEnvironment == EnumDataItemSystemEnvironment.NOT_ASSIGNED) {
				continue;
			}
			this.map_DataItemSystemEnvironment.put(en_DataItemSystemEnvironment.getFieldName(), en_DataItemSystemEnvironment);
		}
	} 

	
    /**
	 * Costruttore  per attivazione da processo a livello pgm, post analisi preliminare.<br>
	 * 
	 */
	public AnalyzerCobol(UserConfiguration sd, ExecutionDirectives di, ProgramCobol programCobol) {
		super(sd, di);
		
	    // Inizializzazioni varie indispensabili
		this.programCobol = programCobol;
		this.analyzerDbInfo = new AnalyzerDbInfo(sd, di, programName);		
		this.ictx = new InnerContextAnalysis ();
		this.ictx.activeTypeSource = EnumSourceType.COBOL_PROGRAM;
		this.ictx.activeSourceName = this.pgmNameUnderParsing;
		
		
		// Allocazione Map parole riservate/Enum per parsing sorgente
		// Allocazione Map con i copy incontrati nel programma
	    // Map con informazioni su procedure interne richiamate
		this.map_ReservedWords = new HashMap<String, ArrayList<InnerInstructionWordsEntry>>(500);
		this.map_DataItemSystemEnvironment = new HashMap<String, EnumDataItemSystemEnvironment>(100);
		this.map_CopyDetected = new HashMap<String, Object[]>();
		this.map_InternalProcedure = new HashMap<String, InnerInternalProcedure> ();
	    this.map_GoTo = new HashMap<Integer, Object[]> ();        		        	// NumInstr goTo -> nodo goTo / String[] label
	    this.map_LabelSection = new HashMap<String, Object[]> () ;				    // label         -> nodo label, goTo, Perform, numInstr
		this.al_metricsProgramSection = new ArrayList<Metrics> ();
		
		// Scan enumerazione con parole riservate Cobol gestite
		for (EnumCobolReservedWords en_reservedWord : EnumCobolReservedWords.values()) {
			if (en_reservedWord == EnumCobolReservedWords.NOT_ASSIGNED) {
				continue;
			}
			putMapReservedWords(en_reservedWord); // -> map_ReservedWords
		}

		// Scan enumerazione con data items dei vari ambienti (gestiti dai precompilatori)
		for (EnumDataItemSystemEnvironment en_DataItemSystemEnvironment : EnumDataItemSystemEnvironment.values()) {
			if (en_DataItemSystemEnvironment == EnumDataItemSystemEnvironment.NOT_ASSIGNED) {
				continue;
			}
			this.map_DataItemSystemEnvironment.put(en_DataItemSystemEnvironment.getFieldName(), en_DataItemSystemEnvironment);
		}

	} 

	

	/**
	 * Restituisce il contenitore di info per fb
	 * 
	 * @return the analyzerDbInfo
	 */
	public AnalyzerDbInfo getAnalyzerDbInfo() {
		return analyzerDbInfo;
	}


	/**
	 * Imposta il contenitore di info per fb
	 * 
	 * @param analyzerDbInfo the analyzerDbInfo to set
	 */
	public void setAnalyzerDbInfo(AnalyzerDbInfo analyzerDbInfo) {
		this.analyzerDbInfo = analyzerDbInfo;
	}


	/**
	 * <h1>
	 * Analizza il sorgente del programma memorizzato nell'istanza di SourceInput.<br>
	 * </h1>
	 * Nome programma e istanza di SourceInput sono stati valorizzati dal costruttore di questa classe.
	 * Le operazioni di parsing comuni sono effettuate in modo centralizzato e generalizzato nella classe
	 * madre AnalyzerCobol. Qui vengono solo sviluppate le logiche specifiche.<br>
	 * Le variabili activeDivisionArea e activeProgramSection sono già valorizzate dalla classe
	 * madre.
	 * <p>
	 * @throws Exception 
	 */
	public void analyzeProgram(SourceInput si, InnerDescriptorSource ids) throws Exception {
		
		Object objectInstruction = null;
		Instruction instructionGeneric = null;
		ProgramCobolEntry<? extends Instruction> programEntry = null;
		
		initialPgm(si, ids.sourceFileName);   			// Operazioni iniziali per oggetto Program da analizzare
 
		// Lettura ahead istruzione nell'oggetto Instruction... corretto
		objectInstruction = getNextObjectInstruction(this.ictx);
        		
		// Scan istruzioni del programma da analizzare come oggetto Instruction completo di info sorgente
		while (objectInstruction != null) {

			// Impostazione variabili di divisioni, sezioni e aree attive del programma
			setActiveDivisionSectionAreas(this.ictx);

			// Creazione entry di programma con cast corretto e impostazioni varie correnti
			programEntry = createProgramEntry(objectInstruction, this.ictx);
			this.di.curEntryCobol = programEntry;			// Disponibile in caso di exception
			
			// Analisi istruzione e aggiornamento strutture e variabili di controllo
			this.ictx.isInstructionToAnalyze = true;
			dispatchInstructionAnalyzer(this.ictx, objectInstruction, programEntry);

			// Se parsing error impostazione flag generale di errore
			instructionGeneric = (Instruction) objectInstruction;
			if (instructionGeneric.isParsingError() 
			||  instructionGeneric.isSemanticError()) {
				this.ictx.isAnyInstructionErrorDetected = true;
			}
			// Se warning impostazione flag generale di warning
			if (instructionGeneric.isWarning()) {
				this.ictx.isAnyInstructionWarningDetected = true;
			}

			// Lettura in ciclo oggetto istruzione successiva
			objectInstruction = getNextObjectInstruction(this.ictx);
	        
		} // end-while

		
		finalPgm();  // Operazioni finali su istruzioni di procedure division e generali di programma
	}


	/**
	 * 
	 * Analizza il modulo copy memorizzato nell'istanza di SourceInput.<br>
	 * Metodo richiamato a fronte di analisi copy NON dovuto a COPY in programma sotto analisi
	 *  
	 * <p>
	 * @throws ExceptionAmrita 
	 * @throws SQLException 
	 */
	public void analyzeCopySource(SourceInput si, InnerDescriptorSource ids, EnumSourceType copySourceType) throws  Exception {
		
		String copyNameCaller = "";
		InstructionCobol instructionCopyStmt = null;
		
		// Simulazione condizioni come per analisi dall'interno di un programma
		initialOperationsCopy(si, ids.sourceFileName, ids.objectType);   // Operazioni iniziali per oggetto Copy da analizzare
		
		// Impostazione informazioni di contesto correnti
		this.ictx = new InnerContextAnalysis ();
		this.ictx.si = si;
		this.ictx.ar_RowsSource = si.getArrayRowSource();
		this.ictx.activeTypeSource = copySourceType;
		this.ictx.activeSourceName = ids.sourceFileName;
		this.di.curObjectId = ids.sourceFileName;
		this.di.curObjectType = si.getSourceType().getObjectType();
		this.ictx.isAnalysisOfProgram = false;
		this.ictx.si.setSourceType(copySourceType);
		
		// Simulazione divisione attiva
		if (copySourceType == EnumSourceType.COBOL_COPY_DATA) {
			this.activeDivisionArea = EnumCobolReservedWords.DATA_DIVISION;
			this.di.curCobolDivision = EnumCobolReservedWords.DATA_DIVISION;
		} else if (copySourceType == EnumSourceType.COBOL_COPY_PROC) {
			this.activeDivisionArea = EnumCobolReservedWords.PROC_DIVISION;
			this.di.curCobolDivision = EnumCobolReservedWords.PROC_DIVISION;
		} else {
			this.activeDivisionArea = EnumCobolReservedWords.ENV_DIVISION;
			this.di.curCobolDivision = EnumCobolReservedWords.ENV_DIVISION;
		}
		
		// Simulazione Istruzione copy, come se fosse stata trovata nel programma
		
		// Descrittore copy
		this.copyCobol = new CopyCobol(ucfg);
		this.copyCobol.setSourceInput(si);                             // Descritto completo sorgente con righe source
		this.copyCobol.setCopyName(ids.sourceFileName);
		this.copyCobol.setSysOwner(si.getSystemOwner());
		this.copyCobol.setSubSysOwner(si.getSubSystemOwner());
		this.copyCobol.setCopyType(copySourceType.getObjectType());
		this.copyCobol.setPath(si.getPathComplete());
		instructionCopyStmt = new InstructionCobol();
		instructionCopyStmt.copySetName(ids.sourceFileName);
		
        // Analisi copy e inserimento in strutture per update su db
		copyNameCaller = this.copyCobol.getCopyName();
		includeAnalyzeCopyEntries(this.ictx, instructionCopyStmt, copyNameCaller);
		
		// Errori di parsing/semantici: fine
		if (this.ictx.isAnyInstructionErrorDetected
		||  this.ictx.isAnyInstructionWarningDetected) {
			loggingParsingErrorsWarning();				// Si trattano le istruzioni di tutte le divisioni Cobol
			this.di.isExecutionWithErrors = true;
			this.di.curObjectWithErrors = true;
		}

		// Persistenza su file system già effettuata da includeAnalyzeCopyEntries()
		
		// Persistenza su db e oprazioni finali       
		finalCopyOperations(ids.sourceFileName);
  
	}
	

	/**
	 * Gestione soluzione singola istruzione con o senza contenuto dinamico.<br>
	 * <p>
	 * Tutte le informazioni dell'istruzione sono state memorizzate nell'oggetto
	 * istruzione in fase di analisi preliminare del programma (cobol o precompilatore).<br>
	 * <p>
	 * In questa fase vengono reperite le informazioni dinamiche, quali il nome di
	 * un programma per l'istruzione Cobol Call oppure il codice di abend per una
	 * istruzione Exec Cics Abend. Vengono quindi inserite tutte le relazioni nel
	 * data base, richiamando un metodo specifico per ogni istruzione Cobol nativa
	 * oppure demandando la gestione allo specifico analizzatore dei precompilatore
	 * (come AnalyzerCics)<br>.
	 * <p>
	 * Questo metodo, per ogni istruzione Cobol o di precompilatore, viene chiamato in fase
	 * di analisi del programma oppure nel processo di soluzione delle logiche "spreaded".
	 * <p>
	 * Per istruzioni che non hanno sicuramente logiche di contenuto dinamico da risolvere,
	 * non viene chiamato questo metodo.<br>
	 * <p>
	 * 
	 * @param Object cicsInstr
	 * @param int typeLogicDynamic  LOGIC_DYNAMIC_SAME_PGM, LOGIC_DYNAMIC_SPREADED_PGM
	 * @throws ExceptionAmrita 
	 * @throws SQLException 
	 */
	public void solveInstruction(Instruction instr  	    // Istruzione da risolvere
		    				   , int typeLogicDynamic	    // LOGIC_DYNAMIC_SAME_PGM, LOGIC_DYNAMIC_SPREADED_PGM
								) throws ExceptionAmrita, SQLException {

		
		InstructionCobolProcedure instructionCobolProc = null;
		InstructionCics instructionPrecompilerCics = null;
		@SuppressWarnings("unused")
		InstructionDL1 instructionPrecompilerDL1 = null;
		InstructionSql instructionPrecompilerSql = null;
		Instruction instrGeneric = null;
		InstructionSql instructionNormalized = null;
		String sourceOrigin = "";
		ExceptionAmrita excp = null;  
		
		instrGeneric = (Instruction) instr;

		// Se attivazione non a fronte di analisi sorgente ma di processo livello pgm
		// e opzione di soluzione codice dinamico attiva, rendo l'istruzione da risolvere
		if (isProcessPgmLevel() && di.optSolveDynamicLocal) {
			instrGeneric.setDynamicSolved(false);	
			instrGeneric.setDynamicSolvedFull(false);	
			instrGeneric.setDynamicWaitingForData(false);	
		}
		
		// Istruzione Cobol nativa
		if (instr instanceof InstructionCobolProcedure) {
			instructionCobolProc = (InstructionCobolProcedure) instr;
			
			switch (instructionCobolProc.getTypeInstr()) {
			 
			    // Istruzioni Cobol
				case PROC_CALL:
					 solveInstructionsDynamicCallCancel(instructionCobolProc , typeLogicDynamic, EnumRelation.PGM_CALLED_PGM);
					break;
				case PROC_CANCEL:
					 solveInstructionsDynamicCallCancel(instructionCobolProc , typeLogicDynamic, EnumRelation.PGM_CANCEL_PGM);
					break;

			default:
				break;
			}
			return;
		}
		

		// Istruzione precompilatore Cics
		if (instr instanceof InstructionCics) {

			instructionPrecompilerCics = (InstructionCics) instr;
			
			if (di.optSolveCodeCics) {
				this.analyzerCics.solveInstruction(instructionPrecompilerCics, typeLogicDynamic);
			}
			return;
		}
		
		// Istruzione precompilatore Sql
		if (instr instanceof InstructionSql) {

			instructionPrecompilerSql = (InstructionSql) instr;
			
			if (di.optSolveDmlSql) {
				sourceOrigin = instructionPrecompilerSql.getSourceInstr();
				this.analyzerSql.analyzeSqlInstruction(instructionNormalized);
				instructionPrecompilerSql.setSourceInstr(sourceOrigin);
			}
			return;
		}
		
		// Logging con exception e stack su log
       	excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOLVING_INSTRUCTION);
		logMessage(EnumMessageType.ERROR_INTERNAL, "EI0013", excp,  this.programName);
		logMessage(EnumMessageType.INFORMATION, "MI0035", this.pgmNameUnderParsing, instrGeneric.getSourceInstr());
		return;
	}


	/**
     * Soluzione istruzioni dinamiche Cobol native, Cics o altro,
     * localmente al programma.<br>
     * <p>
     * Vengono recuperate tutte le istruzioni di procedure division e,
     * per ogni istruzione, sarà attivato il metodo che attiverà il 
     * processo di soluzione necessario.
     * 
     */
	public void solveInstructionsDynamicLocally() throws ExceptionAmrita, SQLException {


     	// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
    	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	Instruction instruction = null;
     	
     	ar_procEntry = this.programCobol.entriesProcedure();
    	
    	// Scan Entries di programma 
    	for (int i = 0; i < ar_procEntry.length; i++) {
    		
    		// Estraggo istruzione e tipo istruzione
    		procEntry = ar_procEntry[i];
    		
     		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
    		if (!(procEntry.getInstruction() instanceof InstructionCobolProcedure)
    		&&  !(procEntry.getInstruction() instanceof InstructionCics)) {
				continue;
			}
    		instruction =  procEntry.getInstruction();
            
    		// Interessano solo le istruzioni dinamiche
    		if (!instruction.isDynamic()) {
				continue;
			}
     		
    		// Interessano solo le istruzioni dinamiche ancora da risolvere, anche parzialmente
    		if (instruction.isDynamicSolved()
    		&&  instruction.isDynamicSolvedFull()) {
				continue;
			}
    		
    		// Istruzione ancora da risolvere o richiesta forzatura
    		
      		solveInstruction(instruction, LOGIC_DYNAMIC_SAME_PGM);   
    		if (instruction.isSemanticError() ) {
				this.ictx.isAnyInstructionErrorDetected = true;
			}
      		
      		
		} // end-for
		finalPgmMarkDynamicLightSolved();						// Update flag istruzioni dinamiche light come solved

	}

	
	/**
     * Soluzione istruzioni dinamiche Cobol native, Cics o altro,
     * spreaded, ovvero esternamente al programma.<br>
     * <p>
     * Vengono recuperate tutte le istruzioni di procedure division e,
     * per ogni istruzione, sarà attivato il metodo che attiverà il 
     * processo di soluzione necessario.
     * 
     */
	public void solveInstructionsDynamicSpreaded() throws ExceptionAmrita, SQLException {
       
     	// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
    	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	Instruction instruction = null;
        EnumObjectStatus statusPgm = null;
    	boolean anyDynamicLight = true;
    	boolean anyDynamicNotSolved = false;
    	boolean anyDynamicNotSolvedFull = false;
    	boolean anyDynamicSpreadedToSolve = false;
    	boolean anyDynamicWaitingForData = false;  
    	
     	ar_procEntry = this.programCobol.entriesProcedure();
    	
    	// Scan Entries di programma 
    	for (int i = 0; i < ar_procEntry.length; i++) {
    		
    		// Estraggo istruzione e tipo istruzione
    		procEntry = ar_procEntry[i];
    		
     		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
    		if (!(procEntry.getInstruction() instanceof InstructionCobolProcedure)
    		&&  !(procEntry.getInstruction() instanceof InstructionCics)) {
				continue;
			}
    		instruction =  procEntry.getInstruction();
            
    		// Interessano solo le istruzioni dinamiche
    		if (!instruction.isDynamic()) {
				continue;
			}
  
    		// Interessano solo le istruzioni dinamiche ancora da risolvere
    		if (instruction.isDynamicSolved() && instruction.isDynamicSolvedFull()) {
				continue;
			}
   		
      		// Se l'istruzione è stata risolta lo stato è passato a DynamicSolved
    		if (!instruction.isDynamicWaitingForData() && !instruction.isDynamicSpreaded()) {
				continue;
			}
    		
      		solveInstruction(instruction, LOGIC_DYNAMIC_SPREADED_PGM);    
      		    
      		// Impostazione flag generali se almeno una istruzione dinamica soddisfa le condizioni
      		if (!instruction.isDynamicLight()) {
      			anyDynamicLight = false;
			}
      		if (!instruction.isDynamicSolved()) {
      			anyDynamicNotSolved = true;
			}
      		if (!instruction.isDynamicSolvedFull()) {
      			anyDynamicNotSolvedFull = true;
			}
      		if (instruction.isDynamicWaitingForData()) {
      			anyDynamicWaitingForData = true;
 			}
     		if (instruction.isDynamicSpreaded()) {
      			if (!instruction.isDynamicSolved() || !instruction.isDynamicSolvedFull()) {
      				anyDynamicSpreadedToSolve = true;
      			}      			
			}
    		
     		// L'istruzione di Update dei flag di DynamicField sono accodate in LogicInfoDynamic.putDatabaseInfoAll() a fine solveInstruction()
     		
		} // end-for
    	
    	// Tutte le istruzioni dininamiche completamente risolte
    	statusPgm = EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_SOLVED;
    	if (anyDynamicNotSolved == false 
    	&&  anyDynamicNotSolvedFull == false 
    	&&  anyDynamicWaitingForData == false
    	&&  anyDynamicSpreadedToSolve == false) {
    		statusPgm = EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_SOLVED;
		} else if (anyDynamicWaitingForData) {
			statusPgm = EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_WAITING_FOR_DATA;
		} else if (anyDynamicSpreadedToSolve) {
			statusPgm = EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_SPREAD_TO_SOLVE;
		}
	    	
    	// Inserimento update flag stato programma a fine elaborazione
    	String strSql = "";
    	
		strSql = "UPDATE Object" +
				 "    SET statusObject = "  + statusPgm.ordinal()  +
				 "  WHERE sys = '"   + programCobol.sysOwner + "'" +
		         "   AND subSys = '" + programCobol.subSysOwner + "'" +
		         "   AND idObject = '" + programCobol.programName + "'" +
		         "   AND typeObject = " + EnumObject.OBJECT_PGM_COBOL.ordinal() 
		         ;

		this.analyzerDbInfo.addSqUpdateStatement(strSql);
   	
	}

	
	/**
     * Individuazione del codice morto nel programma<br>
     * <p>
     * Si tratta di dati e copy non utilizzati e 
     * codice non raggiungibile.
     * 
	 * @param metricsProgram 
	 * @param graphManager 
	 * @throws SQLException 
	 * @throws ExceptionAmrita 
     * 
     * 
     */
	public void detectDeadCode() throws ExceptionAmrita, SQLException   {
        
		// Ogni metodo verifica se l'opzione di dead code è abilitata
		
	   	finalPgmDataDeadCodeCopy();		  				// Individuazione copy non utilizzati e caricamento PGM_WITH_COPY_UNUSED 
		finalPgmDataDeadCodeDataItems();	  			// Scan definizioni data division e gestione marcatura campi non referenziati come dead code 
 		finalPgmProcDeadCodeInstructions();				// Scan istruzioni procedure division e marcatura istruzioni non raggiungibili	  
		finalPgmProcDeadCodeCopy();						// Scan istruzioni procedure division e marcatura copy con istruzioni tutte dead code  
 
	}

	
	/*
     * Misurazioni per metriche di Halstead<br>
     * <p>
     * Si tratta delle misure per:<br>
     * C Complessita ciclomatica di McCabe<br>
     * H Indice di Halstead<br>
     * MI Indice di manutenibilità MI<br>
     * FP Numero function point<br>
     * <p>
     * Le metriche vengono calcolate e memorizzate
     * nell'oggetto {@link Metrics}, serializzato insieme a {@link ProgramCobol}.
	 * @param metricsProgram 
	 * @param graphManager 
     * 
     * 
     */
	private void evaluatePgmMetricsHalstead(int iStart, int iEnd, Metrics metrics) throws ExceptionAmrita, SQLException {
        
		Instruction.InnerSymbolEntry[] ar_symbolInstructionUsed = null;
		List<Instruction.InnerSymbolEntry> li_symbolInstruction = null;
		Map<EnumCobolReservedWords, Integer> map_HalsteadOperator = null;   // Operatori distinti e occorrenze di questi (Istruzioni, operatori, ..)
 	    Map<String, Integer> map_HalsteadOperand = null;  					// Operandi distinti e eccorrenze di questi (campo o una literal nell'istruzione.
	    EnumSymbolType symbolType = null;
	    String symbolName = "";
	    
	    // Di servizio
		ArrayList<EnumCobolReservedWords> al_operatorDistinct = null;
		Integer distinctOperatorOccurs = 0;
		Integer distinctOperandOccurs = 0;
		
		// Halstead
		int halsteadOperators = 0;                    // n1 Numero operatori distinti in un programma (es. istruzione IF, (, GREATER, etc.)
		int halsteadOperands = 0;                     // n2 Numero operandi distinti in un programma (es. un campo definito o literal etc)
		int halsteadOperatorsOcc = 0;                 // N1 Numero occorrenze di operatori n1
		int halsteadOperandsOcc = 0;                  // N2 Numero occorrenze di operandi  n2

		// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
    	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	InstructionCobolProcedure instruction = null;

 
    	//////////////////////////////////////////////////
		// Inizializzazione 
		//////////////////////////////////////////////////
		
		// Allocazione strutture per metriche di Halstead
		map_HalsteadOperator = new HashMap<EnumCobolReservedWords, Integer> ();
		map_HalsteadOperand = new HashMap<String, Integer> ();
 		

		//////////////////////////////////////////////////
		// Calcolo misure operatori/Operandi di Halstead
		//////////////////////////////////////////////////
		
     	ar_procEntry = this.programCobol.entriesProcedure();
		
    	// Scan istruzioni (mainline/section/paragrafo)
    	for (int i = iStart; i <= iEnd; i++) {
    		
    		// Estraggo istruzione e tipo istruzione
    		procEntry = ar_procEntry[i];
    		
     		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
    		if (!(procEntry.getInstruction() instanceof InstructionCobolProcedure)) {continue;}
    		
 			instruction =  (InstructionCobolProcedure) procEntry.getInstruction();
    		
    		// Aggiornamento counter OR/AND per McCabe e operatori di Halstead
 			updateInstructionForMcCabeAndHalstead(instruction);
            
 			// Operatori di Halstead
 			
     		// Update occorrenze operatori distinti istruzione  e presenti nell'istruzione come (,),+,-,..,>, LESS, ...
    		// Una istruzione label NON è un operatore distinto.
    		if (instruction.getTypeInstr() != EnumCobolReservedWords.PROC_LABEL) {
         		// Update occorrenze operatore distinto X codice istruzione
        		distinctOperatorOccurs = map_HalsteadOperator.get(procEntry.getTypeInstr());
        		if (distinctOperatorOccurs == null) {distinctOperatorOccurs = new Integer(0);}
        		distinctOperatorOccurs++;
        		map_HalsteadOperator.put(procEntry.getTypeInstr(), distinctOperatorOccurs);
        		// Update occorrenze operatore distinto X operatori in codice istruzione
       		    al_operatorDistinct = instruction.getHalsteadOperators();
        		for (EnumCobolReservedWords operator : al_operatorDistinct) {
        	   		// Update occorrenze operatore distinto operatore
            		distinctOperatorOccurs = map_HalsteadOperator.get(operator);
            		if (distinctOperatorOccurs == null) {distinctOperatorOccurs = new Integer(0);}
            		distinctOperatorOccurs++;
            		map_HalsteadOperator.put(operator, distinctOperatorOccurs);
      			} // end-for operatori istruzione
			}

    		// Operandi di Halstead
 
    		// La label è un operando distinto
    		if (instruction.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
           		// Update occorrenze operando distinto codice istruzione
    			symbolName = instruction.labelGetName();
    			distinctOperandOccurs = map_HalsteadOperand.get(symbolName);
        		if (distinctOperandOccurs == null) {distinctOperandOccurs = new Integer(0);}
        		distinctOperandOccurs++;
        		map_HalsteadOperand.put(symbolName, distinctOperandOccurs);
                continue;
    		}
    		
        	// Estrazione simboli definiti/usati dall'istruzione che rappresentano operandi per Halstead
           	ar_symbolInstructionUsed = instruction.symbolsUsed();
    		li_symbolInstruction = new ArrayList<Instruction.InnerSymbolEntry> ();
           	li_symbolInstruction = Arrays.asList(ar_symbolInstructionUsed);
            	
            // Scan simboli definiti/usati dall'istruzione che rappresentano operandi per Halstead
           	for (InnerSymbolEntry innerSymbolEntry : li_symbolInstruction) {
    			
    			symbolName = innerSymbolEntry.symbolName;
            	symbolType = innerSymbolEntry.qualifier.getSymbolType();
    			
    			// Non è un operando secondo Halstead
    			if (!symbolType.equals(EnumSymbolType.COBOL_SYMBOL_DATA_ITEM)
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA)		
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM)		
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_FIGURATIVE)		
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_ENVIRONMENT_NAME)		
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_MNEMONIC_NAME)
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_SPECIAL_REGISTER)
    			&&  !symbolType.equals(EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL)) {
    				continue;
    			}

         		// Update occorrenze operando distinto codice istruzione
    			distinctOperandOccurs = map_HalsteadOperand.get(symbolName);
        		if (distinctOperandOccurs == null) {distinctOperandOccurs = new Integer(0);}
        		distinctOperandOccurs++;
        		map_HalsteadOperand.put(symbolName, distinctOperandOccurs);
    		}
    		
 		} // end-for istruzioni

    	
   		//////////////////////////////////////////////////
		// Totalizzazione operatori/Operandi di Halstead
		//////////////////////////////////////////////////
		
    	// Scan map operatori di Hasltead
    	for (Entry<EnumCobolReservedWords, Integer> entryOperator : map_HalsteadOperator.entrySet()) {
			
    		distinctOperatorOccurs = entryOperator.getValue();
    		
     		// Conteggio
       		halsteadOperators++;
       		halsteadOperatorsOcc = halsteadOperatorsOcc + distinctOperatorOccurs;
    		
		}

    	// Scan map operandi di Hasltead
    	for (Entry<String, Integer> entryOperand : map_HalsteadOperand.entrySet()) {
			
    		distinctOperandOccurs = entryOperand.getValue();
    		
     		// Conteggio
       		halsteadOperands++;
       		halsteadOperandsOcc = halsteadOperandsOcc + distinctOperandOccurs;
    		
		}
    	
     	
        //////////////////////////////////////////////
		// Aggiornamento misure
        //////////////////////////////////////////////
    	
     	// Misure di Halstead
    	metrics.setHalsteadOperators(halsteadOperators);
    	metrics.setHalsteadOperands(halsteadOperands);
    	metrics.setHalsteadOperatorsOcc(halsteadOperatorsOcc);
    	metrics.setHalsteadOperandsOcc(halsteadOperandsOcc);
 
    	// Calcolo indici a partire dalle misure
    	metrics.computeIdxHalstead(); 		// Calcolo indici di lunghezza, volume, difficoltà, sforzo e tempo di sviluppo
 
    }
 

	/*
     * Misurazioni per metriche di McCabe di programma con utilizzo formula semplificata<br>
     * <p>
     * Si utilizza la formula semplificata dei predicati scandendo le istruzioni di programma
     * invece che il grafo di programma.
     * Le informazioni del grafo quali numero archi e nodi sono già state estratte e memorizzate.
     * 
     * Incrementano di uno l'indice di McCabe i predicati dovuti a:
     * 
     * 1) IF condtion
     * 2) EVALUATE|SEARCH... WHEN condition
     * 3) PERFORM .. UNTIL condition
     * 4) GO TO DEPENDING ON 
     * 5) |NOT AT END
     * 6) |NOT INVALID KEY
     * 7) |NOT EOP
     * 8) |NOT ON SIZE ERROR
     * 9) |NOT ON OVERFLOW
     * 11) Per ogni condizione estesa (AND/OR) si incrementa di 1
     * 11) Grafo nel suo complesso
     */
	private void evaluatePgmMetricsMcCabeSemplified(int numInstrStart, int numInstrEnd, Metrics metrics) {
		
		// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
       	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	InstructionCobolProcedure instruction = null;
    	ArrayList<ExpressionCobol> al_exprCondition = null;
     	ArrayList<CobolPerformLoop> al_performLoopDescriptor = null;
		String[] ar_labelGoTo = null;
     	
    	boolean isAnyPredicate = false;
		int cntInstrException = 0;			  			// AT END|ON OVERFLOW|..
		int cntInstrLabelGoTo = 0;			  			// Ogni label rappresenta un predicato implicito
		int cntPredicate = 0;			  				// If/When/Perform inner/Perform until
		int cntMcCabeOperatorsOrAnd = 0;			  	// OR AND
		
		ar_procEntry = this.programCobol.entriesProcedure();
		al_exprCondition = new ArrayList<ExpressionCobol>();
		
		// Scan istruzioni 
		for (int i = numInstrStart; i <= numInstrEnd; i++) {
			
			procEntry = ar_procEntry[i];
			isAnyPredicate = false;
			al_exprCondition.clear();
			
			// |NOT |AT END|INVALID KEY|ON OVERFLOW|AT EOP
			if (procEntry.getTypeInstr().getCobolInstrCategory() == EnumInstrDataCategory.COBOL_PROC_INSTRUCTION_EXCEPTION) {
				cntInstrException++;	
			}
			
			// GOTO
			if (procEntry.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
				instruction = (InstructionCobolProcedure) procEntry.getInstruction();
				// Depending On
				if (instruction.goToIsDependingOn()) {
					ar_labelGoTo = instruction.goToGetLabels();
					cntInstrLabelGoTo = cntInstrLabelGoTo + ar_labelGoTo.length;
				}
			}

			// IF
			if (procEntry.getTypeInstr() == EnumCobolReservedWords.PROC_IF) {
				instruction = (InstructionCobolProcedure) procEntry.getInstruction();
				isAnyPredicate = true;
				al_exprCondition.add(instruction.ifGetCondition());
			}
			
			// WHEN (search/evaluate)
			if (procEntry.getTypeInstr() == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH) {
				instruction = (InstructionCobolProcedure) procEntry.getInstruction();
				isAnyPredicate = true;
				if (instruction.whenIsOther()) {
					al_exprCondition.addAll(instruction.whenGetConditions());
				}
			}
	
			// PERFORM
			if (procEntry.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
				instruction = (InstructionCobolProcedure) procEntry.getInstruction();
			
				// Inner Perform o perform until
				if (instruction.performIsWithUntil()) {
					isAnyPredicate = true;
					al_performLoopDescriptor = instruction.performGetUntil();
					al_exprCondition = new ArrayList<ExpressionCobol>();
					for (CobolPerformLoop performLoopDescriptor : al_performLoopDescriptor) {
						al_exprCondition.add(performLoopDescriptor.getUntilConditionExpression());
					}
				}
			}

			// Nessun predicato
			if (!isAnyPredicate) {
				continue;
			}
			
			cntPredicate++;
			
    		// And Or in espressioni estratte per McCabe esteso
    		for (ExpressionCobol expressionX : al_exprCondition) {
    			cntMcCabeOperatorsOrAnd = cntMcCabeOperatorsOrAnd + expressionX.getMcCabeOperatorsExtended();
    		}
		}
		
		// Calcolo indice esteso di complessità ciclomatica con formula semplificata
     	metrics.setMcCabeOperatorsOrAnd(cntMcCabeOperatorsOrAnd);
       	metrics.computeIdxMcCabeSemplified(cntPredicate, cntMcCabeOperatorsOrAnd + cntInstrException + cntInstrLabelGoTo); 
      	metrics.setIdxMcCabeHigh(metrics.getIdxMcCabeAvg());
     	metrics.setIdxMcCabeLow(metrics.getIdxMcCabeAvg());
     	metrics.setIdxMcCabeTot(metrics.getIdxMcCabeAvg());
	}

	
	/**
     * Valutazione completa metriche di complessità strutturale<br>
     * <p>
     * Si tratta dell misure di fan-in e fan-out.<br>
     * <p>
     * Per una descrizione completa si veda la classe {@link Metrics}
     * 
     */
	public void evaluatePgmMetricsComplexityStructure() throws ExceptionAmrita, SQLException {
 
	}

	/**
     * Valutazione completa metriche di Function Point<br>
     * <p>
     * Si tratta delle 5 misure di function point.<br>
     * <p>
     * Per una descrizione completa si veda la classe {@link Metrics}
     * 
     */
	public void evaluatePgmMetricsFunctionPoint() throws ExceptionAmrita, SQLException {
    }
	
	/**
     * Valutazione completa metriche di Rehosting<br>
     * <p>
     * Per una descrizione completa si veda la classe {@link Metrics}
     * 
     */
	public void evaluatePgmMetricsRehosting() throws ExceptionAmrita, SQLException {
    }
	

	
	/* ---------------------------------------------------
	 * Update istruzioni per metriche di McCabe e Halstead
	 * ---------------------------------------------------
	 * 
	 * Per McCabe si trattano le istruzioni con condizioni 
	 * ovvero IF, Evaluate-When, Search-When e Perform Until 
	 * conteggiando gli operatori logici OR e AND.  
	 * 
	 * Per Halstead si considerano tutte le istruzioni
	 * e si conteggia e si individuano tutti gli operatori, 
	 * logici e aritmetici, aggiornando l'istruzione stessa.
	 * Si tratta di operatori quali ")", "(", ",", ":", 
	 * a fronte di indexing e/o reference modification.
	 * 
	 */
	private void updateInstructionForMcCabeAndHalstead(InstructionCobolProcedure instruction) {
		
		ExpressionCobol expression = null;
		ArrayList<ExpressionCobol> al_expression = null;
	    ArrayList<EnumCobolReservedWords> al_HalsteadOperators = null;
	    ArrayList<CobolPerformLoop> al_performLoopCondition = null;
	    DataItemCobolIdentifier ar_dataItemCobolIdentifier[] = null;
		int cntMcCabeOperatorsExtended = 0;

		al_HalsteadOperators = new ArrayList<EnumCobolReservedWords> ();

		// If McCabe+Halstead
		if (instruction.getTypeInstr() == EnumCobolReservedWords.PROC_IF) {
			expression = instruction.ifGetCondition();
	        instruction.setMcCabeOperatorsExtended(expression.getMcCabeOperatorsExtended());
	        instruction.setHalsteadOperators(expression.getHalsteadOperators());
	        return;
		}
		
		// Evaluate-When e Search-When McCabe+Halstead
		if (instruction.getTypeInstr() == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH) {
			cntMcCabeOperatorsExtended = 0;
			al_expression = instruction.whenGetConditions();
			if (al_expression != null) {
				for (ExpressionCobol expressionCobol : al_expression) {
				    cntMcCabeOperatorsExtended = cntMcCabeOperatorsExtended + expressionCobol.getMcCabeOperatorsExtended();
				    al_HalsteadOperators.addAll(expressionCobol.getHalsteadOperators());
				}
			}
		    instruction.setMcCabeOperatorsExtended(cntMcCabeOperatorsExtended);
		    al_HalsteadOperators.trimToSize();    // Optimize
		    instruction.setHalsteadOperators(al_HalsteadOperators);
	        return;
		}
	
		// Perform-Until McCabe+Halstead
		if (instruction.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
			cntMcCabeOperatorsExtended = 0;
			al_performLoopCondition = instruction.performGetUntil();
			for (CobolPerformLoop performCondition : al_performLoopCondition) {
				// Perform ... from ...
				if (performCondition.getFromExpression() != null) {
					cntMcCabeOperatorsExtended = cntMcCabeOperatorsExtended + performCondition.getFromExpression().getMcCabeOperatorsExtended();
					al_HalsteadOperators.addAll(performCondition.getFromExpression().getHalsteadOperators());
				}
				// Perform ... Until
			    if (instruction.performIsWithUntil()) {
			    	cntMcCabeOperatorsExtended = cntMcCabeOperatorsExtended + performCondition.getUntilConditionExpression().getMcCabeOperatorsExtended();
			    	al_HalsteadOperators.addAll(performCondition.getUntilConditionExpression().getHalsteadOperators());
			    }
			}
		    instruction.setMcCabeOperatorsExtended(cntMcCabeOperatorsExtended);
		    al_HalsteadOperators.trimToSize();    // Optimize
		    instruction.setHalsteadOperators(al_HalsteadOperators);
	        return;
		}
		
        // Istruzione qualsiasi.
		// Conteggio operatori di Halstead per indentificatori indexati e/o con ref mode.
		
		ar_dataItemCobolIdentifier = instruction.getOperandsInput();
        for (DataItemCobolIdentifier identifier : ar_dataItemCobolIdentifier) {
        	
        	// Operatori di Halstead per indexing
           	if (identifier.getQualifier().isOccursed()) {
           		// Scan indici
        		for (ExpressionCobol expressionIndex : identifier.getQualifier().getIndexes()) {
        			al_HalsteadOperators.addAll(expressionIndex.getHalsteadOperators());
				}
        		// Inserimento operatori ( )
        		al_HalsteadOperators.add(EnumCobolReservedWords.OPERATOR_PAR_OPEN);
        		al_HalsteadOperators.add(EnumCobolReservedWords.OPERATOR_PAR_CLOSE);
             }
       	
           	// Operatori di Halstead per reference modification
           	if (identifier.getQualifier().isThereRefModification()) {
           		// Operatori di Halstead per posizione e lunghezza
        		al_HalsteadOperators.addAll(identifier.getQualifier().getPos().getHalsteadOperators());
        		al_HalsteadOperators.addAll(identifier.getQualifier().getLength().getHalsteadOperators());
        		// Inserimento operatori ( ) :
        		al_HalsteadOperators.add(EnumCobolReservedWords.OPERATOR_PAR_OPEN);
           		al_HalsteadOperators.add(EnumCobolReservedWords.OPERATOR_PAR_CLOSE);
           		al_HalsteadOperators.add(EnumCobolReservedWords.OPERATOR_REF_MOD_SEPARATOR);
             }
		}
        al_HalsteadOperators.trimToSize();    // Optimize
        instruction.setHalsteadOperators(al_HalsteadOperators);
	}


	/**
	 * --------------------------------------------------------------------------------------------
	 * Estrazione identificatori completi Cobol (Campi con i qualificatori di utilizzo) da stringa,
	 * --------------------------------------------------------------------------------------------
	 * 
	 * A fronte di analisi COPY non derivati da stmt COPY in programmi NON segnalo errori se item non trovato
	 * 
	 * 
	 * Gli identificatori sono separati da spazi o da virgole, tipicamente a fronte di MOVE, DISPLAY
	 * STRING etc. o da porzioni di istruzioni.<br>
	 * L'identificatore può richiamare una funzione intrinseca.
	 * 
	 * Al minimo la stringa contiene una costante figurativa o una literal numerica o alfanumerica.
	 * 
	 * La stringa identificatore in input può contenere una sequenza di campi espressi quale:
	 * 
	 * 1) Literal alfanumerica  
	 * 2) Literal numerica  
	 * 3) By Reference  
	 * 4) By Content    
	 * 5) By Value  
	 * 6) Function NomeFunction(...)  
	 * 7) nessuna
     *
     * Seguito opzionalmente da:
     *
	 * 1) Length Of     
	 * 2) Address Of    
     * 3) nessuna
     *
     * Seguito obbligatoriamente se NON è Function da:
     *
	 * 1) data-name
 	 * 2) data-name Of|In group-name
     *   
     *
     * Seguito opzionalmente da:
	 * 
	 * 1) (index1, index2,...)
	 * 2) (index1, index2,...) 
	 * 3) nessuna
	 * 
     * Seguito opzionalmente da:
     *
	 * 1) (pos:lng)
	 * 2) (pos:)
	 * 3) (:lng)
	 * 4) (special register: special register)
	 * 5) nessuna
	 * 
     * seguito opzionalmente da:
	 * 
	 * 1) Rounded
	 * 
	 */
	public ArrayList<DataItemCobolIdentifier> extractIdentifiers(Instruction instruction, String strInput)  {
				
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;  // Papping parola riservata Cobol
		ArrayList<DataItemCobolIdentifier> al_identifierOut = null;  		// ArrayList di output con gli identificatori individuati
	    ArrayList<String> al_tokenQualifierWrk = null;                  	// (i1, i2, ..)(pos:lng)
	    ArrayList<String> al_tokenQualifierIdx = null;                  	// (i1, i2, ..)(pos:lng)
	    ArrayList<String> al_tokenQualifierRefMod = null;                  	// (i1, i2, ..)(pos:lng)
	    ExceptionAmrita excp = null;  										// Exception
	    LiteralCobol literalCobol = null;                                   // Per gestione unificata literal alfanumeriche, esadecimali e numeriche
	    int[] ar_dataItemDefPointers = null;                                // Numeri istruzioni in data division di definizione data item
	    int definitionPointer = 0;                                          // Numero istruzione definizione dati in data division
	    
		// Strutture per per identifier
        DataItemCobolIdentifier identifier = null;
        DataItemQualifier qualifier = null;
        EnumCobolReservedWords reservedWord = null;
        EnumInstrDataCategory dataItemCategory = null;
        EnumDataItemSystemEnvironment dataItemSystemEnvironment = null;
        
        // Variabili per gestione identificatori di Call Using e Procedure division
        boolean byReference = false;			// Vale fino a successivo byContent
        boolean byContent = false;				// Vale fino a successivo byReference
        boolean byValue = false;				// Vale fino a successivo byReference o byContent
        
        // variabili di servizio
        Scanner scn = null;						// Scanner per estrazione parole
        String strToAnalyze = "";				// Stringa dinamica da analizzaare
        String token = "";						// Singolo token estratto con Scanner
        String tokenPrec = "";					// Singolo token estratto con Scanner
        String underGroupName = "";				// Nome campo di gruppo sotto il quale l'identificatore è definito come indicato dalla clausola OF
        int cntParOpen = 0;                     // Per gestione campi indexati dentro reference modification
        int iEndLiteral = 0;                    // Il token potrebbe essere un campo che inizia con un numero
        boolean isDefinitionComplete = false;   // False = identificatore errato o incompleto o nessun identificatore
		boolean isReferenceModification = false;// True  = identificatore con reference modification (pos:lng)
		
		// Initial
        al_identifierOut = new ArrayList<DataItemCobolIdentifier> ();
        literalCobol = new LiteralCobol();
             
		// Per corretto trattamento literal come token atomico
        strToAnalyze = replaceSpaceInLiteralWithUnderscore(instruction, strInput);
        strToAnalyze = normalizeDataItemSource(instruction, strToAnalyze);
 		if (instruction.isParsingError()) {  // Literal non chiuse
			return al_identifierOut;
		}   
          
        // Inserisce space fra operatori e divide eventualmente parole con -, quando è un operatore matematico
        strToAnalyze = normalizeIdentifiers(instruction, strToAnalyze);
        if (instruction.isParsingError()) {
			return al_identifierOut;    
		}
        
        scn = new Scanner(strToAnalyze);
        token = nextToken(scn);
        
        // Loop fino a quando non ci sono più identificatori da estrarre 
        while (!token.equals("")) {
			
        	// Virgola di separazione fra identificatori diversi: skip
        	if (token.equals(",")) {
        		token = nextToken(scn);
				continue;
			}
 
            // Nuovi oggetti per parola riservata, identificatore e qualificatore
            identifier = new DataItemCobolIdentifier();
    	    qualifier = new DataItemQualifier();
            identifier.setQualifier(qualifier);   						// Valorizzo reference qualificatore in identificatore
            qualifier.setByReferenceDeclared(byReference);
            qualifier.setByContentDeclared(byContent);
            qualifier.setByValueDeclared(byValue);
            al_tokenQualifierIdx = new ArrayList<String> ();
            al_tokenQualifierRefMod = new ArrayList<String> ();
    
            // Token più comuni: literal alfanumeriche e numeriche
            iEndLiteral = literalCobol.parseLiteral(token+" ", 0);
             
      	    // Literal alfanumerica. 
    	    if (literalCobol.isLiteralString()) {
       	    	identifier.setNameIdentifier(token.replace('_', ' '));
        	    identifier.setIdentifierType(EnumCobolReservedWords.OPERAND_LITERAL_ALPHA);
       	        qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
        	    qualifier.setSymbolValue(identifier.getNameIdentifier());			// literal
       	        al_identifierOut.add(identifier);
      	    	isDefinitionComplete = true;
      	    	token = nextToken(scn);
    	    	continue;			// Successivo identificatore
			}

       	    // Literal numerica intera, con virgola o floating point.
    	    // Bisogna verificare che non sia un campo che inizia cone di numeri.
     	    if (literalCobol.isLiteralNum() && iEndLiteral == token.length() - 1) {
    	    	qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
     	    	identifier.setNameIdentifier(token);
    	    	identifier.setIdentifierType(EnumCobolReservedWords.OPERAND_LITERAL_NUM);
    	    	qualifier.setSymbolValue(token);
     	    	if (StringService._isNumericDouble(token)) {
    	    		qualifier.setSymbolValueNumericDouble(StringService._getNumericDouble(token));
				} else if (StringService._isNumericLong(token)) {
					if (StringService._getNumericLong(token) == null) {
						qualifier.setSymbolValueNumericLong(0);
					} else {
						qualifier.setSymbolValueNumericLong(StringService._getNumericLong(token));
					}
				} else if (StringService._isNumericFloating(token)) {
					qualifier.setSymbolValueNumericFloat(StringService._getNumericFloating(token));
				}
       	    	al_identifierOut.add(identifier);
    	    	isDefinitionComplete = true;
    	    	token = nextToken(scn);
    	    	continue;			// Successivo identificatore
			}
    	    
   	        // By reference/Content/Value di procedure division using e Call
    	    
     	    // By di Reference/Content/Value
       	    if (token.equals("BY")) {
       	    	token = nextToken(scn);
       	    	isDefinitionComplete = false;
          	    continue;     
			}
             
       	    // By Reference  
       	    if (token.equals("REFERENCE")) {
    	    	byReference = true;
     	    	byContent = false;
     	    	byValue = false;
     	    	token = nextToken(scn);	
     	    	isDefinitionComplete = false;
  				continue;
       	    }
       	    
     	    // By Content  
     	    if (token.equals("CONTENT")) {
     	    	byReference = false;
     	    	byContent = true;
     	    	byValue = false;
     	    	token = nextToken(scn);	
    	    	isDefinitionComplete = false;
  				continue;
    	    }
     	  
     	    // By Value  
     	    if (token.equals("VALUE")) {
     	    	byReference = false;
    	    	byContent = false;
    	    	byValue = true;
    	    	token = nextToken(scn);	
    	    	isDefinitionComplete = false;
 				continue;
     	    }

       	 
            // Il token inizia con una parola riservata Cobol che NON è una funzione intrinseca
            al_reservedWordEntry = this.map_ReservedWords.get(token);
            if (al_reservedWordEntry != null && al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
            	
            	reservedWord = al_reservedWordEntry.get(0).en_WordReservedOwner;
  
            	// Si tratta di casi tipo ON: devo prendere la combinazione di valori di una sola parola chiave
            	if (al_reservedWordEntry.size() > 1) {
					for (InnerInstructionWordsEntry wordEntry : al_reservedWordEntry) {
						if (wordEntry.al_wordKey.size() == 1) {
							reservedWord = wordEntry.en_WordReservedOwner;
							break;
						}
					}
				}
  	                
    			//  Costante figurativa Space/zero/low-value ....
         	    if (reservedWord.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_FIGURATIVE) {
         	    	identifier.setNameIdentifier(token);
         	    	identifier.setIdentifierType(reservedWord);
        	    	qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_FIGURATIVE);
        	    	qualifier.setSymbolValue(token);
        	    	al_identifierOut.add(identifier);
         	    	token = nextToken(scn);
        	    	isDefinitionComplete = true;
        	    	continue;			// Successivo identificatore
    			}
         	    
         	    // Special register 
         	    if (reservedWord.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER) {
         	      
         	       // Special register di una sola parola trattabile come identificatore
          	       if (reservedWord != EnumCobolReservedWords.REGISTER_LENGTH_OF
                   &&  reservedWord != EnumCobolReservedWords.REGISTER_ADDRESS_OF) {
         	    	  identifier.setNameIdentifier(token);
         	    	  identifier.setIdentifierType(reservedWord);
  					  qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_SPECIAL_REGISTER); 
  					  qualifier.setSymbolValue(token);					             
  					  al_identifierOut.add(identifier);
  					  token = nextToken(scn);
					  isDefinitionComplete = true;
					  continue;			// Successivo identificatore
				   }
         	       
           	       // Length of  
         	       if (reservedWord == EnumCobolReservedWords.REGISTER_LENGTH_OF) {
      	    		   qualifier.setLengthOfDeclared(true); 
         	       }
         	       // Address of
         	       if (reservedWord == EnumCobolReservedWords.REGISTER_ADDRESS_OF) {
      	    		   qualifier.setAddressOfDeclared(true); 
          	       }
         	       // Posizionamento su identificatore
  	    		   token = nextToken(scn);   // OF  
 	    		   token = nextToken(scn);   // Identificatore
         	    }
         	    
        	    // Environment name (Sysin, Sysipt, ....)
         	    if (reservedWord.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_ENVIRONMENT_NAME) {
       	    	   identifier.setNameIdentifier(token);
     	    	   identifier.setIdentifierType(reservedWord);
				   qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_ENVIRONMENT_NAME); 
				   qualifier.setSymbolValue(token);					             
				   al_identifierOut.add(identifier);
				   token = nextToken(scn);
				   isDefinitionComplete = true;
    			   continue;			// Successivo identificatore
         	    }
         	    
    		}
  
            // Il token inizia con una parola riservata Cobol che identifica una funzione intrinseca
            if (al_reservedWordEntry != null 
            && al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
             	reservedWord = al_reservedWordEntry.get(0).en_WordReservedOwner;
             	tokenPrec = token;
             	token = nextToken(scn);			// Nome funzione intrinseca
             	// Sorgente corrotto o funzione non tabellata in enumeration o errore di programma
             	if (token.equals("") || !isIntrinsicFunction(al_reservedWordEntry, token)) {
    				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
    				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0032", tokenPrec, excp, this.programName, token);
    	 			instruction.setSemanticError(true);
    	 			break;
				}
             	token = nextToken(scn);			// (
             	cntParOpen = 1;
             	while (!token.equals("")) {
             		token = nextToken(scn);	
            		if (token.equals("(")) {cntParOpen++;}
            		if (token.equals(")")) {cntParOpen--;}
             		if (cntParOpen == 0) {break;}
             		if (token.equals("ALL")) {continue;}
             		// Data item dentro l'identificatore
             		
				}
             	token = nextToken(scn);	
            }
            
            // Il token NON inizia con una parola riservata Cobol che identifica una funzione intrinseca
            // Il token può essere solo un identificatore, preceduto o meno da Length/Address Of
            if (al_reservedWordEntry == null
            || (al_reservedWordEntry.size() > 0 && al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC)) {
	            identifier.setNameIdentifier(token);							      // Nome campo
	            identifier.setIdentifierType(EnumCobolReservedWords.DATA_DIV_DATA_ITEM);
	            qualifier.setSymbolType(EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);       // Suppongo sia un campo
	            qualifier.setSymbolValue(token);					                  // Nome simbolo 
	 
	            // Aggiorno tipo identifier se campo di ambiente esterno al Cobol
	            dataItemSystemEnvironment = this.map_DataItemSystemEnvironment.get(token);
	            if (dataItemSystemEnvironment != null) {
	            	dataItemCategory = dataItemSystemEnvironment.getTypePrecompiler();
	            	switch (dataItemCategory) {
							case CICS_PRECOMPILER:
								identifier.setIdentifierType(EnumCobolReservedWords.PRECOMPILER_CICS);
								break;
							case SQL_PRECOMPILER:
								identifier.setIdentifierType(EnumCobolReservedWords.PRECOMPILER_SQL);
								break;
							case DL1_PRECOMPILER:
								identifier.setIdentifierType(EnumCobolReservedWords.PRECOMPILER_DL1);
								break;
							}
	 			}
	            
	            // Data item non di ambiente esterno al Cobol: recupero definizioni nel programma
	            // Il campo DFHCOMMAREA è di ambiente esterno ma è definito a programma
	            if ((dataItemSystemEnvironment == null
	            ||  token.equals("DFHCOMMAREA")) && this.programCobol != null) {
	               ar_dataItemDefPointers = this.programCobol .dataItemPointers(token);
	            }
	            
	            // Se Empty sto analizzando un copy non a fronte di analisi di un programma
	            if (!this.programName.isEmpty()) {
					// Campo Cobol non definito nel programma: errore e break
					if (ar_dataItemDefPointers == null && this.map_DataItemSystemEnvironment.get(token) == null) {
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
						instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", token, excp,
								this.programName, token);
						instruction.setSemanticError(true);
						break;
					} 
				}
				// Imposto reference a istruzione di definizione dati (null se campo di ambiente esterno)
	            // Suppongo che il campo non sia qualificato da OF|IN e prendo la prima definizione
	            if (ar_dataItemDefPointers != null) {
		            definitionPointer = ar_dataItemDefPointers[0]; 
		            identifier.setDataItem(this.programCobol.instructionDataItem(definitionPointer));
		            identifier.setNumInstr(definitionPointer);
		        }
	            
	            // Solo o ultimo identificatore, non qualificato, non indicizzato e senza reference modification
	            if (!scn.hasNext()) {
	            	isDefinitionComplete = true;
	            	al_identifierOut.add(identifier);
	           	    break;
	    		}
	            token = nextToken(scn);	
            
            } // end-if
            
             
            // Operatori di apparatenenza area OF|IN
            if (token.equals("OF") || token.equals("IN")) {
            	token = nextToken(scn);	
            	if (token.equals("")) {
					break;
				}
 				qualifier.setUnderGroupDeclared(true);
				qualifier.setGroupNameOwner(token);
				qualifier.getGroupNameFields().add(token);
				// Update numInstr in identifier alla corretta definizione specificata da OF
			    // Scan definizioni campo con lo stesso nome	
				for (int pointerDef : ar_dataItemDefPointers) {
					underGroupName = this.programCobol.groupOwnerName(pointerDef);
					// Stesso gruppo dichiarato in OF|IN: update la definizione dati nell'identificatore
					if (token.equals(underGroupName)) {
			            identifier.setDataItem(this.programCobol.instructionDataItem(pointerDef));
			            identifier.setNumInstr(pointerDef);
			            break;
					}
				}
				token = nextToken(scn);
				// Eventuali altri qualificatori OF
				while (token.equals("OF")) {
					token = nextToken(scn);
					qualifier.getGroupNameFields().add(token);
					token = nextToken(scn);
				}
		    }
              
            // Qualificatori  (I1, I2, ..)(pos:lng) o (I1, I2, ..) o (pos:lng)
            // I1, I2, .. possono essere identificatori Cobol completi
            if (token.equals("(")) {
            	// Estrazione in due ArrayList separate
            	al_tokenQualifierWrk = new ArrayList<String> ();
            	isReferenceModification = false;
            	
              	token = nextToken(scn);
              	cntParOpen = 1;
              	
            	// Scan indici o reference modification
             	while (!token.equals("")) {

					if (token.equals("(")) {cntParOpen++;}
  					if (token.equals(")")) {cntParOpen--;}
 					if (token.equals(")") && cntParOpen == 0) {break;}

 					// E' qualificazione di reference modification
					if (token.equals(":")) {
						isReferenceModification = true;
						qualifier.setRefModification(true);
					}
					
					// Accodamento token
					al_tokenQualifierWrk.add(token);
					token = nextToken(scn);
            	}
             	
            	if (isReferenceModification) {
					al_tokenQualifierRefMod = al_tokenQualifierWrk;
				} else {
					al_tokenQualifierIdx = al_tokenQualifierWrk;
				}
            	
            	token = nextToken(scn);  
            	
            	// Scan reference modification dopo indici
            	if (token.equals("(") && !isReferenceModification) {
            		al_tokenQualifierRefMod = new ArrayList<String> ();
            		cntParOpen = 1;
            		token = nextToken(scn);
            		
                	while (!token.equals("")) {
                		
    					if (token.equals(",")) {
    						token = nextToken(scn);
    						continue;
    					}
    					
    					if (token.equals("(")) {cntParOpen++;}
       					if (token.equals(")")) {cntParOpen--;}
     					if (token.equals(")") && cntParOpen == 0) {break;}
 
    					// Accodamento token
 					    al_tokenQualifierRefMod.add(token);
    					token = nextToken(scn);
                	}
                	token = nextToken(scn);				// Primo token utile successivo
 				}
            	// Solo se data item cobol o di ambiente esterno c
            	if (dataItemSystemEnvironment == null 
            	|| (dataItemSystemEnvironment != null && dataItemSystemEnvironment.isIndexVerify())) {
                   	extractQualifiers(instruction, al_tokenQualifierIdx, al_tokenQualifierRefMod, qualifier);
                	if (instruction.isParsingError()) {
    					break;
    				}
				}
    		}
            
            
            // Verifica se qualificatore ROUNDED
            if (token.equals("ROUNDED")) {
    			qualifier.setRoundedDeclared(true);
            	token = nextToken(scn);				// Primo token utile successivo
			}
            
            // Identificatore estratto con tutte le sue qualificazioni
            // La stringa inizia con il nuovo qualificatore da estrarre
            
          	// Accodamento identificatore estratto completo
        	al_identifierOut.add(identifier);
        	isDefinitionComplete = true;
             
            // Cerco nuovo identificatore da token succesivo
            
        } // end-while
       
       	    
       	
       	// Identificatori incompleti o errati o nessun identificatore in input
    	if (!isDefinitionComplete) {
    		// La definizione incompleta non è dovuta a un errore semantico
    		if (!instruction.isSemanticError()) {
    			instruction.setParsingError(true);
			}
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_IDENTIFIER);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
 		}
       	    
 		return al_identifierOut;
	}

	/*
	 * -----------------------------------------------------------
	 * Normalizzazione definizione source a causa cattiva gestione
	 * -----------------------------------------------------------
	 * 
	 * Necessario cambiare logica di analii e rendere tutto tokenabel ???
	 * 
	 * Per problema su PIC 9(8 ) si ricompattano parentesi aperte e chiuse
	 * 
	 */
    private String normalizeDataItemSource(Instruction instruction, String strToNormalize) {
		String strNormalized = "";
		char doubleApice = 34;					// Doppio apice ""

		strNormalized = strToNormalize;
		strNormalized = strNormalized.replace("( ", "(");
		strNormalized = strNormalized.replace("( ", "(");
		strNormalized = strNormalized.replace("( ", "(");
		strNormalized = strNormalized.replace(" )", ")");
		strNormalized = strNormalized.replace(" )", ")");
		strNormalized = strNormalized.replace(" )", ")");
		strNormalized = strNormalized.replace("VALUE'", "VALUE '");
		strNormalized = strNormalized.replace("VALUE" + new Character(doubleApice).toString(), "VALUE " + new Character(doubleApice).toString() );
		strNormalized = strNormalized.replace("VALUES'", "VALUES '");
		strNormalized = strNormalized.replace("VALUES" + new Character(doubleApice).toString(), "VALUES " + new Character(doubleApice).toString() );
		 
		return strNormalized;
	}


	/*
     * Restituisce true se la function name è presente nell'enty confezionato 
     * a partire da EnumReservedWords
     *   
     */
	private boolean isIntrinsicFunction(ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry, String functionName) {

		ArrayList<String> al_keys = null;
		boolean isFuncionDefined = false;
		
		// Scan possibili sequenze FUNCTION nomeFunction
		for (InnerInstructionWordsEntry functionDescriptor : al_reservedWordEntry) {
			al_keys = functionDescriptor.al_wordKey;
			if (al_keys.get(1).equals(functionName)) {
				isFuncionDefined = true;
				break;
			}
		}
		return isFuncionDefined;
	}

	/*
     * 
     * Inserimento nell'istruzione utilizzi simboli in input o in output.
     * Utilizzato anche da analizzatore Cics.
     * 
     */
	public void addInstructionSymbolsUsedAndDefined(Instruction instruction
						                          ,DataItemCobolIdentifier identifier
						                          ,int cobolDataItemUsedType
						                          ) {
		
		DataItemQualifier qualifier = null;
	
		
		// Gestione data item in input
		if (cobolDataItemUsedType == COBOL_DATA_ITEM_USED_INPUT) {
			
			
			// Caricamento simbolo in input (può anche essere una literal numerica o alfanumerica)
			// Viene inserito completo di qualificatore di utilizzo, se non qualificato si passa il tipo simbolo
			qualifier = identifier.getQualifier();
			if (qualifier != null) {
				instruction.addSymbolInput(identifier.getNameIdentifier(), qualifier);
			} else {
				instruction.addSymbolInput(identifier.getNameIdentifier(), identifier.getIdentifierType().getCobolSymbolType());
			}
			
			
			// Simbolo definiti dentro l'istruzione (literal o costante figuratival)
			if (identifier.getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_NUM
			||  identifier.getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_ALPHA) {
				instruction.addSymbolDefinedInside(identifier.getNameIdentifier(), identifier.getIdentifierType().getCobolSymbolType());
			} else {
				// Caricamento reference a identificatore completo
				instruction.addOperandInput(identifier.getNameIdentifier(), identifier);
			}

			// Caricamento simboli di qualificazione (se esistono), gruppi, indici, posizione etc. come input
			if (qualifier != null) {
				addInstructionSymbolsQualifier(instruction, identifier, qualifier);
				return;
			}
			
			return;
		} 
			
		// Gestione data item in output
		if (cobolDataItemUsedType == COBOL_DATA_ITEM_USED_OUTPUT) {
			
			// Caricamento reference a identificatore completo
			instruction.addOperandOutput(identifier.getNameIdentifier(), identifier);

			// Caricamento simbolo in output (NON può  essere una literal numerica o alfanumerica)
			// Viene inserito completo di qualificatore di utilizzo, se non qualificato vale null.
			qualifier = identifier.getQualifier();
			if (qualifier != null) {
				instruction.addSymbolOutput(identifier.getNameIdentifier(), qualifier);
			} else {
				instruction.addSymbolOutput(identifier.getNameIdentifier(), identifier.getIdentifierType().getCobolSymbolType());
			}
			
			// Caricamento simboli di qualificazione (se esistono), gruppi, indici, posizione etc. come input
			if (qualifier != null) {
				addInstructionSymbolsQualifier(instruction, identifier, qualifier);
				return;
			}
		} 
		
	}


	/**
	 * 
	 * Restituisce l'istanza di LogicSamePgm utilizzata nel processo di analisi
	 * del programma corrente.
	 * 
	 * @return the LogicSamePgm
	 */
	public LogicSamePgm getLogicSamePgm() {
		return logicSamePgm;
	}

	/**
	 * 
	 * Imposta l'istanza di LogicSamePgm utilizzata nel processo di analisi
	 * del programma corrente.<br>
	 * Metodo richiamato a fronte di processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setLogicSamePgm(LogicSamePgm logicSamePgm) {
		this.logicSamePgm = logicSamePgm;
		return;
	}

	/**
	 * 
	 * Imposta il nome del programma sotto parsing.
	 * Metodo richiamato a fronte di processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setPgmNameUnderParsing(String pgmNameUnderParsing) {
		this.pgmNameUnderParsing = pgmNameUnderParsing;
		return;
	}

	/**
	 * 
	 * Imposta l'istanza di LogicSpreadedPgm utilizzata nel processo di analisi
	 * del programma corrente.<br>
	 * Metodo richiamato a fronte di processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setLogicSpreadedPgm(LogicSpreadedPgm logicSpreadedPgm) {
		this.logicSpreadedPgm = logicSpreadedPgm;
		return;
	}

	/**
	 * 
	 * Restituisce l'istanza di logicSpreadedPgm utilizzata nel processo di analisi
	 * del programma corrente.
	 * 
	 * @return the LogicSamePgm
	 */
	public LogicSpreadedPgm getLogicSpreadePgm() {
		return logicSpreadedPgm;
	}



	/**
	 * pgmNameUnderParsing
	 * Restituisce il nome del programma correntemente sotto analisi.
	 * 
	 * @return the program name
	 */
	public String getProgramName() {
		return this.programName;
	}

	/**
	 * Imposta l'oggetto programma codificato.<br>
	 * Metodo richiamato a fronte di processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 * 
	 * @param programCobol the programCobol to set
	 */
	public void setProgramCobol(ProgramCobol programCobol) {
		this.programCobol = programCobol;
	}

	/**
	 * 
	 * Restituisce l'oggetto programma codificato.<br>
	 * Metodo richiamato a fronte di processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 * @return the programCobol
	 */
	public ProgramCobol getProgramCobol() {
		return programCobol;
	}





	/**
	 * Imposta l'oggetto {@link UserExitInfo} con le informazioni di sistema e sottosistema<br>
	 * <p>
	 * 
	 * @param metricsProgram the metricsProgram to set
	 */
	public void setUserExitInfoPgm(UserExitInfo userExitInfoPgm) {
		this.di.userExitInfoPgm = userExitInfoPgm;
	}


	/**
	 * Impostazione iniziale contesto di analisi.<br>
	 * <p>
	 * Questo metodo viene richiamato da {@link ProcessPgmLevel} per
	 * le elaborazioni a livello di programma, per simulare la stessa
	 * situazione operativa che si ha a fine analisi preliminare del
	 * programma, quando si effettuano contestualmente le stesse operazioni.<br>
	 * <p>
	 * 
	 */
	public void setInitialContextAnalysis() {
		this.ictx = new InnerContextAnalysis ();
		this.ictx.activeTypeSource = EnumSourceType.COBOL_PROGRAM;
		this.ictx.activeSourceName = this.pgmNameUnderParsing;
		this.programName = this.pgmNameUnderParsing;
		this.ictx.metrics = this.metricsProgram;
		
		// Attivazione a fronte di PROCESS_PGM_LEVEL e PROCESS_SYSTEM_LEVEL, nessuna informazione sul sorgente
		if (isProcessPgmlevel || isProcessSystemlevel) {
			this.activeDivisionArea = EnumCobolReservedWords.PROC_DIVISION;
			return;
		}
		this.ictx.si = si;
		this.ictx.ar_RowsSource = this.si.getArrayRowSource();
	}

	/**
	 * 
	 * Restituisce l'oggetto che aggrega tutti gli aggiornamenti da fare
	 * sul db per l'analisi del programma in corso.
	 * 
	 * @return AnalyzerDbInfo updates db container
	 */
	public AnalyzerDbInfo getDbInfo() {
		return this.analyzerDbInfo;
	}

	/**
	 * 
	 * Imposta l'oggetto che aggrega tutti gli aggiornamenti da fare
	 * sul db per l'analisi del programma in corso. <br>
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * @return AnalyzerDbInfo updates db container
	 */
	public void setDbInfo(AnalyzerDbInfo analyzerDbInfo) {
		this.analyzerDbInfo = analyzerDbInfo;
		return;
	}


	/**
	 * 
	 * Restituisce l'oggetto che aggrega tutti gli aggiornamenti da fare
	 * sul db per l'analisi del programma in corso.
	 * 
	 * @return AnalyzerDbInfo updates db container
	 */
	public LogicInfoDynamic getLogicInfoDynamic() {
		return this.logicInfoDynamic;
	}
	

	/**
	 * 
	 * Imposta l'oggetto che aggrega tutti gli aggiornamenti da fare
	 * sul db per l'analisi del programma in corso.<br>
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setLogicInfoDynamic(LogicInfoDynamic logicInfoDynamic) {
		this.logicInfoDynamic = logicInfoDynamic;
		return;
	}

	/**
	 * Restituisce true se {@link AnalyzerCobol} è stato attivato
	 * a fronte dell'esecuzione del processo a livello di pgm.<br>
	 * In questo caso non viene effettuata l'analisi del sorgente
	 * del programma ma vengono utilizzate porzioni di codice condiviso.<br>
	 * <p>
	 * 
	 * @return the isProcessPgmlevel
	 */
	public boolean isProcessPgmLevel() {
		return isProcessPgmlevel;
	}



	/**
	 * Imposta se {@link AnalyzerCobol} è stato attivato
	 * a fronte dell'esecuzione del processo a livello di pgm.<br>
	 * In questo caso non viene effettuata l'analisi del sorgente
	 * del programma ma vengono utilizzate porzioni di codice condiviso.<br>
	 * <p>
	 * 

	 * @param isProcessPgmlevel the isProcessPgmlevel to set
	 */
	public void setProcessPgmLevel(boolean isProcessPgmlevel) {
		this.isProcessPgmlevel = isProcessPgmlevel;
	}


	/**
	 * Restituisce true se {@link AnalyzerCobol} è stato attivato
	 * a fronte dell'esecuzione del processo a livello di sistema.<br>
	 * In questo caso non viene effettuata l'analisi del sorgente
	 * del programma ma vengono utilizzate porzioni di codice condiviso.<br>
	 * <p>
	 * 
	 * @return the isProcessSystemlevel
	 */
	public boolean isProcessSystemLevel() {
		return isProcessSystemlevel;
	}



	/**
	 * Imposta se {@link AnalyzerCobol} è stato attivato
	 * a fronte dell'esecuzione del processo a livello di sistema.<br>
	 * In questo caso non viene effettuata l'analisi del sorgente
	 * del programma ma vengono utilizzate porzioni di codice condiviso.<br>
	 * <p>
	 * 

	 * @param isProcessSystemlevel the isProcessPgmlevel to set
	 */
	public void setProcessSystemLevel(boolean isProcessSystemlevel) {
		this.isProcessSystemlevel = isProcessSystemlevel;
	}



	/**
	 * 
	 * Restituisce l'istanza dell'analizzatore Cics.
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 * @return AnalyzerCics object
	 */
	public AnalyzerCicsInstr getAnalyzerCics() {
		return this.analyzerCics;
	}
	

	/**
	 * Imposta Restituisce l'istanza dell'analizzatore Cics.
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setAnalyzerCics(AnalyzerCicsInstr analyzerCics) {
		this.analyzerCics = analyzerCics;
		return;
	}

	
	/**
	 * 
	 * Restituisce l'istanza dell'analizzatore Sql.
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 * @return AnalyzerSql object
	 */
	public AnalyzerSql getAnalyzerSql() {
		return this.analyzerSql;
	}
	

	/**
	 * Imposta Restituisce l'istanza dell'analizzatore Sql.
	 * Metodo richiamato a fronte di esecuzione processi a livello pgm
	 * dopo l'analisi preliminare del programma.
	 * 
	 */
	public void setAnalyzerSql(AnalyzerSql analyzerSql) {
		this.analyzerSql = analyzerSql;
		return;
	}

	
 	 /**
	 * 
	 * Gestione serializzazione di oggetti, tipicamente copy e programmi.
	 * L'oggetto  viene memorizzato su disco in formato serializzato.
	 * 
	 * @param String dirFileSerialized 		Directory file di output 
	 * @param String suffixFile 			Suffisso file di output (SUFFIX_SERIALIZED_COPY, SUFFIX_SERIALIZED_PGM, ..)
	 * @param String idObject 				Nome file di output 
	 * @param String objectToSerialize 		Istanza oggetto da serializzare
	 * @throws ExceptionAmrita 
	 */
	public void  putSerialized(String dirFileSerialized         // Recuperata dal chiamante da SystemDefaults
			                 , String suffixFile                // Passata dal chiamante da AmritaConstants
			                 , String idObject                  // Nome Copy, programma, ..
			                 , Object objectToSerialize         // Oggetto da serializzare
			                 ) throws ExceptionAmrita {
		
		ExceptionAmrita excp = null;
		ObjectOutputStream oos = null;
		String fileName = null;
		
		fileName = dirFileSerialized + File.separator + idObject + "." + suffixFile;
		
		try {
			// Open del file
			oos = new ObjectOutputStream(new FileOutputStream(fileName));
			// Scrittura su file oggetto graph corrente
			oos.writeObject (objectToSerialize);
			// Chiususa file
			oos.close ();
 		} catch (Exception e) {
        	logMessage(EnumMessageType.ERROR_INTERNAL, "EI0008", e, idObject, objectToSerialize.getClass().getName(), fileName);
			if (suffixFile.equalsIgnoreCase(SUFFIX_SERIALIZED_COPY)) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SERIALIZE_COPY, e);
			} else {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SERIALIZE_PGM, e);
			}
 			// Il main gestisce l'eccezione, fornisce info supplementari e decide se continuare l'elaborazione
            throw excp;
		}	
 		
		// Serializzazione di pgm o copy a fronte di analisi programma
 		if (!this.programName.isEmpty()) {
			// Serializzazione completata: log messaggio informativo
			if (suffixFile.equalsIgnoreCase(SUFFIX_SERIALIZED_COPY)) {
				logMessage(EnumMessageType.INFORMATION, "MI0032", this.pgmNameUnderParsing, idObject, fileName,
						CopyCobol.class.getName());
			} else {
				logMessage(EnumMessageType.INFORMATION, "MI0112", this.pgmNameUnderParsing, fileName,
						ProgramCobol.class.getName());
			} 
			
		// Serializzazione copy analizzato singolarmente non a fronte di analisi programma
		} else {
			logMessage(EnumMessageType.INFORMATION, "MI0207", idObject, fileName, CopyCobol.class.getName());			
		}
 				
		return;
	}
	
	
	


	/**
	 * 
	 * Restituisce loggetto serializzato con il path fornito.
	 * 
	 * @param String dirFileSerialized 		Directory file di output 
	 * @param String suffixFile 			Suffisso file di output (SUFFIX_SERIALIZED_COPY, SUFFIX_SERIALIZED_PGM, ..)
	 * @param String idObject 				Nome file di output 
	 * @return Object object 				Oggetto deserializzato di cui effettuare il casting
	 * @throws ExceptionAmrita 
	 */
	public Object getSerialized(String dirFileSerialized         // Recuperata dal chiamante da SystemDefaults
			                  , String idObject                  // Nome Copy, programma, ..
			                  , String suffixFile                // Passata dal chiamante da AmritaConstants
		                       ) throws ExceptionAmrita {
		
		Object objectUnserialized = null;
		ExceptionAmrita excp = null;
		ObjectInputStream ois = null;
		String fileName = null;
		
		fileName = dirFileSerialized + File.separator + idObject + "." + suffixFile;
  
		try {
			// Open del file
			ois = new ObjectInputStream(new FileInputStream(fileName));
			objectUnserialized = ois.readObject();
			ois.close ();
			
 		} catch (Exception e) {
 			if (suffixFile.equalsIgnoreCase(SUFFIX_SERIALIZED_COPY)) {
				logMessage(EnumMessageType.ERROR_INTERNAL, "EI0009", e, idObject, CopyCobol.class.getName(), fileName);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_UNSERIALIZE_COPY, e);
			} else {
				logMessage(EnumMessageType.ERROR_INTERNAL, "EI0009", e, idObject, ProgramCobol.class.getName(), fileName);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_UNSERIALIZE_PGM, e);
			}
			// Il main gestisce l'eccezione, fornisce info supplementari e decide se continuare l'elaborazione
            throw excp;
		}

		// De-serializzazione completata: log messaggio informativo
 		if (this.di.optVerboseMessages) {
 			if (suffixFile.equalsIgnoreCase(SUFFIX_SERIALIZED_COPY)) {
 				if (this.pgmNameUnderParsing.trim().equals("")) {
 					logMessage(EnumMessageType.INFORMATION, "MI0305",  idObject, CopyCobol.class.getName(), fileName);
				} else {
	 				logMessage(EnumMessageType.INFORMATION, "MI0033", this.pgmNameUnderParsing, idObject, CopyCobol.class.getName(), fileName);
				}
 			} else {
 				logMessage(EnumMessageType.INFORMATION, "MI0033", this.pgmNameUnderParsing, idObject, CopyCobol.class.getName(), fileName);
 			}
		}
		return objectUnserialized;
	}


	/**
	 * 
	 * Restituisce il numero di istruzione corrente, che verrà inserita a fine parsing.
	 * 
	 * @return the curNumDefProcDiv
	 */
	public int getCurNumDefProcDiv() {
		return curNumDefProcDiv;
	}





	////////////////////////////////////////////////////////////////////////////////////////////
	////////////////// 						Metodi privati  				 /////////////////// 
    ////////////////////////////////////////////////////////////////////////////////////////////

	/*
	 * Attivazione corretto analizzatore istruzione in base alla divisione attiva.
     * Aggiornamneto strutture contenenti le istruzioni analizzate.
     * Aggiornamento strutture di cross reference del programma, in
     * base a ogni istruzione analizzata.
	 * 
	 * Questo metodo viene attivato, anche in processo ricorsivo, a fronte di:
	 * 
	 *   1) Analisi programma completo
	 *   2) Analisi copy richiamato nel programma
	 *   3) Analisi copy richiamato da copy (nested)
	 *   4) Analisi copy specifico attivato da analyzeCopy()
	 * 
	 * 
	 */	
	private void dispatchInstructionAnalyzer(
								              InnerContextAnalysis ictx								// Contesto sorgente corrente
								            , Object objectInstruction								// Istruzione sotto analisi
								            , ProgramCobolEntry<? extends Instruction> programEntry // Container per l'istruzione
								             ) throws ExceptionAmrita
								                    , SQLException {		
		
	
		Instruction instructionGeneric = null;
		InstructionSql instructionPrecompilerSql = null;
		instructionGeneric = (Instruction) objectInstruction;
		InstructionCobol instructionCopyStmt = null;
		int iInstr = 0;
		
		// Smistamento in base a divisione attiva
		
		switch (this.activeDivisionArea) {
		
				// Istruzioni di Identification division
				case ID_DIVISION:

					// Analisi istruzione (xref è solo per data e procedure division)
					if (ictx.isInstructionToAnalyze) {
						analyzeIdentificationDivisionStmt(ictx, objectInstruction);
					}

				    // Sto analizzando un'istruzione di un programma, o di un copy richiamato a ogni livello
					// L'entry con l'istruzione analizzata viene comunque inserito
					if (ictx.isAnalysisOfProgram) {
						this.di.curNumInstr=this.curNumDefIdDiv;
						this.curNumDefIdDiv = this.programCobol.addEntryIdentification(programEntry);
						instructionGeneric.setNumInstr(this.curNumDefIdDiv);
					}
					
					this.di.curNumInstr=this.curNumDefIdDiv;  // Valido in caso di exception					
					this.curNumDefIdDiv++;

					// Gestione inclusione items copy con eventuale analisi ricorsiva 
					if (ictx.isInstructionToAnalyze && !ictx.isCopyIncludingInProgress && ictx.activeTypeInstr == EnumCobolReservedWords.DIR_COMPILER_COPY) {
						includeAnalyzeCopyEntries(ictx, (InstructionCobol) objectInstruction, "");
					}
					break;
					
				// Istruzioni di Environment division
				case ENV_DIVISION:
					
					// Analisi istruzione (xref è solo per data e procedure division)
					if (ictx.isInstructionToAnalyze) {
						analyzeEnvironmentDivisionStmt(ictx, objectInstruction);
					}
					
				    // Sto analizzando un'istruzione di un programma, o di un copy richiamato a ogni livello
					// L'entry con l'istruzione analizzata viene comunque inserito
					if (ictx.isAnalysisOfProgram) {
						this.curNumDefEnvDiv = this.programCobol.addEntryEnvironment(programEntry);
						instructionGeneric.setNumInstr(this.curNumDefEnvDiv);
					}
					
					this.di.curNumInstr=this.curNumDefEnvDiv;  // Valido in caso di exception					
					this.curNumDefEnvDiv++;

					// Gestione inclusione items copy con eventuale analisi ricorsiva 
					if (ictx.isInstructionToAnalyze && !ictx.isCopyIncludingInProgress && ictx.activeTypeInstr == EnumCobolReservedWords.DIR_COMPILER_COPY) {
						includeAnalyzeCopyEntries(ictx, (InstructionCobol) objectInstruction, "");
					}
					break;
				
					
				// Istruzioni di Data division
				case DATA_DIVISION:
					
					// Analisi istruzione (xref è solo per data e procedure division)
					if (ictx.isInstructionToAnalyze) {
						analyzeDataDivisionStmt(ictx, objectInstruction);
					}
					
					// Sto analizzando un'istruzione di un programma, o di un copy richiamato a ogni livello
					// L'entry con l'istruzione analizzata viene comunque inserito.
					// Update xref di programma
					if (ictx.isAnalysisOfProgram) {
						updateProgramXrefDataFromInstruction(objectInstruction, this.curNumDefDataDiv);
						this.curNumDefDataDiv = this.programCobol.addEntryData(programEntry);
						instructionGeneric.setNumInstr(this.curNumDefDataDiv);
					}

					this.di.curNumInstr=this.curNumDefDataDiv;  // Valido in caso di exception					
					this.curNumDefDataDiv++;
	
					// Gestione inserimento copy di servizio e data items impliciti
					precompilerCopySimulationInsert(ictx);  // Se WORLING-STORAGE SECTION o LINKAGE-SECTION
				    insImplicitDataItems();                 //   

					// Gestione inclusione items copy con eventuale analisi ricorsiva copy cobol
					if (ictx.isInstructionToAnalyze && !ictx.isCopyIncludingInProgress && ictx.activeTypeInstr == EnumCobolReservedWords.DIR_COMPILER_COPY) {
						// Completamento operazione inserimento relazioni ed oggetti
						iInstr = this.curNumDefDataDiv - 1;
						copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY, EnumObject.OBJECT_COPY_COBOL_DATA, ((InstructionCobol) objectInstruction).copyGetName(), "", iInstr, ((InstructionCobol) objectInstruction).getTypeInstrCategory(), ((Instruction) objectInstruction));
						// Copy NESTED: si inserisce relazione COPY-COPY ed eventualmente l'oggetto relazionato 
						if (ictx.copyNestinglevel > 0) {
							copyIncludeAddObjectAndRelation(ictx.copyNameCaller, EnumRelation.COPY_COPY, EnumObject.OBJECT_COPY_COBOL_DATA, ((InstructionCobol) objectInstruction).copyGetName(), "", iInstr,  ((InstructionCobol) objectInstruction).getTypeInstrCategory(), ((Instruction) objectInstruction));
						}						
						includeAnalyzeCopyEntries(ictx, (InstructionCobol) objectInstruction, ictx.activeSourceName);   
					}
					
					// Gestione inclusione Include Sql, viene simulata l'inclusione di un copy 
					if (ictx.isInstructionToAnalyze && ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_SQL) {
						instructionPrecompilerSql = (InstructionSql) instructionGeneric;
						if (instructionPrecompilerSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
							instructionCopyStmt = new InstructionCobol();
							instructionCopyStmt.copySetName(instructionPrecompilerSql.sqlIncludeGetName());
							instructionCopyStmt.setCopySqlInclude(true);
							iInstr = this.curNumDefDataDiv - 1;
							Instruction i = (Instruction) objectInstruction;
							copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY_SQL_INCLUDE, EnumObject.OBJECT_COPY_COBOL_DATA, instructionCopyStmt.copyGetName(), "", iInstr, instructionCopyStmt.getTypeInstrCategory(), i);
							includeAnalyzeCopyEntries(ictx, instructionCopyStmt, "");
							setErrorOnCurrentInstructionIfAny(ictx, (Instruction) objectInstruction, (Instruction) instructionCopyStmt);
						}
					}
					break;
				
					
				// Istruzioni di Procedure division
				case PROC_DIVISION:
					
					// Analisi istruzione (xref è solo per data e procedure division)
					if (ictx.isInstructionToAnalyze) {
						analyzeProcDivisionStmt(ictx, objectInstruction);
					}
					
					// Sto analizzando un'istruzione di un programma, o di un copy richiamato a ogni livello
					// L'entry con l'istruzione analizzata viene comunque inserito.
					// Update xref di programma
					if (ictx.isAnalysisOfProgram) {   
						updateProgramXrefProcFromInstruction(this.ictx, objectInstruction, this.curNumDefProcDiv);
						this.curNumDefProcDiv = this.programCobol.addEntryProcedure(programEntry);
						instructionGeneric.setNumInstr(this.curNumDefProcDiv);
					}

					this.di.curNumInstr=this.curNumDefProcDiv;  // Valido in caso di exception					
					this.curNumDefProcDiv++;

					// Gestione inclusione items copy con eventuale analisi ricorsiva 
					if (ictx.isInstructionToAnalyze && ictx.activeTypeInstr == EnumCobolReservedWords.DIR_COMPILER_COPY) {
						iInstr = this.curNumDefProcDiv - 1;
						copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY, EnumObject.OBJECT_COPY_COBOL_PROC, ((InstructionCobol) objectInstruction).copyGetName(), "", iInstr, ((InstructionCobol) objectInstruction).getTypeInstrCategory(), (InstructionCobol) objectInstruction);
						// Copy NESTED: si inserisce relazione COPY-COPY ed eventualmente l'oggetto relazionato 
						if (ictx.copyNestinglevel > 0) {
							copyIncludeAddObjectAndRelation(ictx.copyNameCaller, EnumRelation.COPY_COPY, EnumObject.OBJECT_COPY_COBOL_PROC, ((InstructionCobol) objectInstruction).copyGetName(), "", iInstr,  ((InstructionCobol) objectInstruction).getTypeInstrCategory(), (InstructionCobol) objectInstruction);
						}						
						includeAnalyzeCopyEntries(ictx, (InstructionCobol) objectInstruction,  "");
					}
					// Gestione inclusione Include Sql, viene simulata l'inclusione di un copy 
					if (ictx.isInstructionToAnalyze && !ictx.isCopyIncludingInProgress && ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_SQL) {
						instructionPrecompilerSql = (InstructionSql) instructionGeneric;
						if (instructionPrecompilerSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
							instructionCopyStmt = new InstructionCobol();
							instructionCopyStmt.copySetName(instructionPrecompilerSql.sqlIncludeGetName());
							// Completamento operazione inserimento relazioni ed oggetti
							iInstr  = this.curNumDefProcDiv - 1;
							copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY, EnumObject.OBJECT_COPY_COBOL_PROC, instructionCopyStmt.copyGetName(), "", iInstr, instructionPrecompilerSql.getTypeInstrCategory(), (Instruction) objectInstruction);
							includeAnalyzeCopyEntries(ictx, instructionCopyStmt, "");
							setErrorOnCurrentInstructionIfAny(ictx, (Instruction) objectInstruction, (Instruction) instructionCopyStmt);
						}
					}
					break;
					
			} // end-switch
	}

	/*
     * -------------------------------------------------------------------------
     * Verifica se copy di mappa Cics e in questo caso recuperoCics mapName 
     * e inserimento relazioni
 	 *   PGM_CICS_MAP 
	 *   PGM_CICS_MAPSET 
     * -------------------------------------------------------------------------
     */
	@SuppressWarnings("unchecked")
	private void gestAddRelPgmPgmCicsMapMapsetIfCopyMap(InstructionCobol instructionCopyStmt) throws ExceptionAmrita, SQLException {
		
		Map<String, Object[]> map_Copy = null;     // Coppie nome copy/true se campi utilizzati
		String copyName = "";
		String mapName = "";
		String mapsetName = "";
		boolean isCopyUsed = false;
		int i;
		
	    // Statement Copy
	    copyName = instructionCopyStmt.copyGetName();

		// Non è un copy di mappa Cics, che deve essere già stata analizzata prima del programma
		if (!this.analyzerDbInfo.isMapset(copyName)) {
			return;
		}
						
		// Copy di mappa Cics, inserisco relazioni
		mapsetName = copyName;
		mapName = this.analyzerDbInfo.getMapName(mapsetName);
		
		// Relazione pgm_map 
        this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
										        			EnumObject.OBJECT_PGM_COBOL
														  , this.pgmNameUnderParsing
														  , EnumObject.OBJECT_CICS_MAP
													  	  , mapName
														  , EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS
														  , EnumRelation.PGM_CICS_MAP  
														  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
														  , this.pgmNameUnderParsing
														  , instructionCopyStmt.getNumInstr()
														  , instructionCopyStmt.getRowStartSource()
														  , instructionCopyStmt.getRowEndSource()
														  , ""
														  , 0
														  , 0
														  , instructionCopyStmt.getTypeInstrCategory()
														  , EnumCobolReservedWords.DATA_DIVISION
														  , false
														  , false
														  , false
														  , this.di.userExitInfoPgm
														   );
		// Relazione pgm_map 
        this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
										        			EnumObject.OBJECT_PGM_COBOL
														  , this.pgmNameUnderParsing
														  , EnumObject.OBJECT_CICS_MAPSET
													  	  , mapsetName
														  , EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS
														  , EnumRelation.PGM_CICS_MAPSET 
														  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
														  , this.pgmNameUnderParsing
														  , instructionCopyStmt.getNumInstr()
														  , instructionCopyStmt.getRowStartSource()
														  , instructionCopyStmt.getRowEndSource()
														  , ""
														  , 0
														  , 0
														  , instructionCopyStmt.getTypeInstrCategory()
														  , EnumCobolReservedWords.DATA_DIVISION
														  , false
														  , false
														  , false
														  , this.di.userExitInfoPgm
														   );		
						

	}  
	
	/*
	 * ---------------------------------------------------------------------------
	 * Impostazione errore in istruzione corrente se istruzione fornita in errore
	 * ---------------------------------------------------------------------------
	 * 
	 * Metodo richiamato tipicamente a frronte di include sql
	 * Se l'istruzione da valutare non è errata nessuna operazione
	 * Altrimenti si trasferiscono le info di errore nell'istruzione corrente 
	 * Si imposta il flag generale di errore
	 * 
	 */
	private void setErrorOnCurrentInstructionIfAny(InnerContextAnalysis ictx, Instruction currentInstruction, Instruction instructionToEvaluate) {
		
		// Nessuna operazione da fare
		if (!instructionToEvaluate.isParsingError()
		&&  !instructionToEvaluate.isSemanticError()) {
			return;
		}
		
		// Update istruzione corrente
		currentInstruction.setParsingError(instructionToEvaluate.isParsingError());
		currentInstruction.setSemanticError(instructionToEvaluate.isSemanticError());
		currentInstruction.setExcpError(instructionToEvaluate.getExcpError());
		currentInstruction.setMsgType(instructionToEvaluate.getMsgType());
		currentInstruction.setMsgCode(instructionToEvaluate.getMsgCode());
		currentInstruction.setTokenInError(instructionToEvaluate.getTokenInError());
		currentInstruction.setMsgParm(instructionToEvaluate.getMsgParm());
		
		// Flag generale di analisi
		ictx.isAnyInstructionErrorDetected = true;
		
	}


	/*
	 * Analisi ricorsiva Copy Cobol di Environment, Data o Procedure division.
	 * 
	 * Questo metodo viene richiamato durante l'analisi di un programma o di un copy richiamato
	 * ricorsivamente da un programma, oppure direttamente dalla funzione di analisi copy,
	 * tramite il metodo (analyzeCopy();
	 * 
	 */
    @SuppressWarnings("unchecked")  
	private CopyCobol analyzeCopyRecursive(InnerContextAnalysis ictx				// Contesto sorgente chiamante
	    		                         , String copyNameToAnalyze  				// Nome copy da analizzare
	    		                         , EnumObject typeCopyObject 	        	// Tipo copy sorgente da analizzare
	    								 , SourceInput si							// Copy da analizzare
	    		                         , String copyNameCaller					// Nome copy chiamante
	    		                          ) throws ExceptionAmrita, SQLException {
    	
 
		Object objectInstruction = null;										// Restituito da parser istruzioni				
		Instruction instructionGeneric = null;								    // Istruzione generica		
		InstructionCobol instructionCobol = null;								    // Istruzione Cobol generica		
		Instruction instructionGenericNotReplaced = null;					    // Istruzione Cobol generica originale		
		ProgramCobolEntry<? extends Instruction> di_programEntry = null;		// Entry corrente presente in direttive
		ProgramCobolEntry<? extends Instruction> programEntry = null;			// Entry generico di programma
		ProgramCobolEntry<? extends Instruction> programEntryNotReplaced = null;// Entry generico di programma originale
     	InnerContextAnalysis ictxCopyCalled = null;								// Nuovo oggetto contesto copy da analizzare
       	CopyCobol objectCopyCobol = null;           							// Oggetto copy output del processo di analisi
       	Object ar_Object[] = null;                                      		// Mappato da map copyDetected
       	ArrayList<InstructionCobol> al_CopyStmt = null;                 		// Secondo elemento ar_Object
       	ArrayList<CopyCobol> al_CopyObject = null;                      		// Terzo elemento ar_Object
 		boolean isStatementReplaced = false;     								// Impostato se source replacesd     
       	
        // Il nuovo contesto diventa il sorgente del copy da includere, a partire dal contesto corrente
       	ictxCopyCalled = ictx.clone();
       	ictxCopyCalled.isAnyInstructionWarningDetected = false;
       	ictxCopyCalled.isAnyInstructionErrorDetected = false;
    	ictxCopyCalled.ar_RowsSource = si.getArrayRowSource();
    	normalizeSourceCodeAndCounting(ictxCopyCalled, false);
    	ictxCopyCalled.activeTypeSource = null;
    	ictxCopyCalled.activeTypeObject = typeCopyObject;
    	ictxCopyCalled.copyStmt = ictx.copyStmt;
       	ictxCopyCalled.copyName = copyNameToAnalyze;
        ictxCopyCalled.activeSourceName = copyNameToAnalyze;
       	ictxCopyCalled.copyNestinglevel++;
        ictxCopyCalled.copyNameCaller = copyNameToAnalyze;
      	ictxCopyCalled.al_CopyEntry = new ArrayList<ProgramCobolEntry<? extends Instruction>> ();
       	
         // Istanziazione oggetto CopyCobol
        if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_DATA) {
        	objectCopyCobol = new CopyCobol(ucfg, copyNameToAnalyze, EnumObject.OBJECT_COPY_COBOL_DATA);
		} else if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_PROC) {
			objectCopyCobol = new CopyCobol(ucfg, copyNameToAnalyze, EnumObject.OBJECT_COPY_COBOL_PROC); 
		} else if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_ENV) {
			objectCopyCobol = new CopyCobol(ucfg, copyNameToAnalyze, EnumObject.OBJECT_COPY_COBOL_ENV);
		} else {
			objectCopyCobol = new CopyCobol(ucfg, copyNameToAnalyze, EnumObject.OBJECT_COPY_COBOL_ID);
		}
 
        // Per corretta gestione in caso di exception
        di_programEntry = this.di.curEntryCobol;				
        
        // Istanzio istruzione Cobol in area di, in quanto posso avere exception
        // prima di individuare l'istruzione
        this.di.curInstr = new InstructionCobol();
        
		// Lettura ahead istruzione copy nell'oggetto Instruction... corretto
		objectInstruction = getNextObjectInstruction(ictxCopyCalled);
        		
		// Scan istruzioni del copy da analizzare come oggetto Instruction completo di info sorgente
		while (objectInstruction != null) {
			
			instructionGeneric = (Instruction) objectInstruction;
			instructionGeneric.setNumInstr(this.curNumDefDataDiv);
			instructionGenericNotReplaced = (Instruction) instructionGeneric.clone();
			instructionGenericNotReplaced.setRowsSource(instructionGeneric.getRowsSource().clone());
			
			// Creazione entry di programma con cast corretto e impostazioni varie correnti
			// Viene creato un entry clonato per non memorizzare la versione replaced dell'istruzione
			programEntry = createProgramEntry(objectInstruction, ictxCopyCalled);
			programEntryNotReplaced = (ProgramCobolEntry<? extends Instruction>) programEntry.clone();
			programEntryNotReplaced.setInstruction(instructionGenericNotReplaced);
			programEntryNotReplaced.setUnderCopy(true);
			programEntryNotReplaced.setUnderCopyName(copyNameToAnalyze);
			
			// Modifica eventuale source da replacing by dello statement Copy (if any e se è un pgm in analisi)
			isStatementReplaced = applyReplacingBy(ictx, instructionGeneric);	
			 
			// Impostazione variabili di divisioni, sezioni e aree attive del programma
			setActiveDivisionSectionAreas(ictxCopyCalled);
			
			// Update flag nested in oggetto copy
			if (objectInstruction instanceof InstructionCobol) {
				instructionCobol = (InstructionCobol) objectInstruction;
				if (instructionCobol.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
					objectCopyCobol.setPath(si.getPathComplete());  
					objectCopyCobol.setSourceInput(si);
					objectCopyCobol.setSysOwner(this.di.systemInput);
					objectCopyCobol.setSubSysOwner(this.di.subSystemInput);
					objectCopyCobol.setCopyNested(true);    
				}
			}
			
			// Analisi istruzione e aggiornamento strutture e variabili di controllo
			ictxCopyCalled.isInstructionToAnalyze = true;
			dispatchInstructionAnalyzer(ictxCopyCalled, objectInstruction, programEntry);
			
			// Analisi entry not replaced per successiva serializzazione copy originale
			if (isStatementReplaced) {
				if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_DATA) {
					analyzeDataDivisionStmt(ictxCopyCalled, programEntryNotReplaced.getInstruction());
				} else if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_ENV) {
					analyzeEnvironmentDivisionStmt(ictxCopyCalled, programEntryNotReplaced.getInstruction());
				} else if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_PROC) {
					analyzeProcDivisionStmt(ictxCopyCalled, programEntryNotReplaced.getInstruction());
				} else {
					analyzeIdentificationDivisionStmt(ictxCopyCalled, programEntryNotReplaced.getInstruction());
				}
			} else {
				programEntryNotReplaced.setInstruction((Instruction) objectInstruction);
			} 
			ictxCopyCalled.al_CopyEntry.add(programEntryNotReplaced);

			// Se parsing error impostazione flag generale di errore
			if (instructionGeneric.isParsingError() 
			||  instructionGeneric.isSemanticError() ) {
				ictxCopyCalled.isAnyInstructionErrorDetected = true;
			}
			// Se warning impostazione flag generale di warning
			if (instructionGeneric.isWarning()) {
				ictxCopyCalled.isAnyInstructionWarningDetected = true;
			}
			
			// Lettura in ciclo oggetto istruzione successiva
			objectInstruction = getNextObjectInstruction(ictxCopyCalled);
	        
	    } //end-while
        
  
		// Sono state analizzate e accodate in ictx.al_CopyEntry tutte le istruzioni del copy,
		// Eventuali copy sono stati esplosi e accodati ricorsivamente sempre a questa ArrayList
		// L'oggetto copy può quindi essere popolato, serializzato e restituito al chiamante 


		// Se warning impostazione flag generale di warning
		if (ictxCopyCalled.isAnyInstructionWarningDetected) {
			ictx.isAnyInstructionWarningDetected = true;
		}

		// Errori nel copy in analisi o in quelli nested inclusi: propagazione errore di parsing al chiamante
		if (ictxCopyCalled.isAnyInstructionErrorDetected) {
			ictx.isAnyInstructionErrorDetected = true;
			objectCopyCobol.setCopyWithAnyErrorDetected(true);				// Mark copy come in errore
		} else {
			// Popolamento oggetto copy e serializzazione 
			objectCopyCobol.setEntries(ictxCopyCalled.al_CopyEntry);
			objectCopyCobol.setPath(si.getPathComplete());  
			objectCopyCobol.setSourceInput(si);
			objectCopyCobol.setSysOwner(si.getSystemOwner());
			objectCopyCobol.setSubSysOwner(si.getSubSystemOwner());
			objectCopyCobol.setPath(si.getPathComplete());
			objectCopyCobol.setDir(si.getDirInput());
			putSerialized(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjCopy(), SUFFIX_SERIALIZED_COPY, copyNameToAnalyze, objectCopyCobol);
		}

		
		// Accodamento entries copy corrente (che include i copy ricorsivi analizzati ricorsivamente)
		// agli entries copy del chiamante. 
		ictx.al_CopyEntry.addAll(ictxCopyCalled.al_CopyEntry); 

		// Update strutture di persistenza
		if (this.di.optUpdateDb) {
			
			// Stato analisi  
			updateCopyStatusOnDbStructure(objectCopyCobol);

 			ar_Object = map_CopyDetected.get(copyNameToAnalyze);
			
			// Creazione entry map se inesistente
			if (ar_Object == null) {
				ar_Object = new Object[3];
				ar_Object[0] = false;    // True = campi copy inseriti in struttura db
				al_CopyStmt = new ArrayList<InstructionCobol> ();
				al_CopyStmt.add(ictx.copyStmt);
				ar_Object[1] = al_CopyStmt;
				al_CopyObject = new ArrayList<CopyCobol> ();
				al_CopyObject.add(objectCopyCobol);
				ar_Object[2] = al_CopyObject;
				this.map_CopyDetected.put(copyNameToAnalyze, ar_Object);
			}

			// Ripristino per corretta gestione in caso di exception
	        //this.di.curEntryCobol = di_programEntry;		// ??? e' null, verificare se utile

			// Copy già trattato: return
			if ((Boolean) ar_Object[0] == true) {
				return objectCopyCobol;
			}

			// Aggiornamento strutture per inserimento su db a fine elaborazione
			// Vengono inseriti i campi del tracciato record
			if (!objectCopyCobol.isCopyWithAnyErrorDetected() && this.di.optCopyDefOnDbToInsert) {
				prepareCopyElementsForDbUpdate(objectCopyCobol, copyNameToAnalyze, typeCopyObject);
				ar_Object[0] = true;
			}
		}

		return objectCopyCobol;
	}

	
	/*
     * 
     * Analizza l'istruzione di identification division.
     * 
     */
	private void analyzeIdentificationDivisionStmt (InnerContextAnalysis ictx, Object instruction) throws ExceptionAmrita, SQLException {
	
		InstructionCobolIdentification instructionIdDivision = null;
		InstructionCobol copyCobolStatement;
		
		this.di.curNumInstr = this.curNumDefIdDiv;			// Disponibile in caso di exception
		
		// Dispatcher analisi specifica istruzione
		switch (ictx.activeTypeInstr) {
			
		// Program-id
		case ID_DIV_PROGRAM_ID:	
			instructionIdDivision = (InstructionCobolIdentification)instruction;
			analyzeProgramIdStmt(ictx, instructionIdDivision);
	 		break;
			
		// Modulo copy: attivazione analizzatore specifico
		case DIR_COMPILER_COPY:	
			copyCobolStatement = (InstructionCobol)instruction;
			analyzeCopyStmt(ictx, copyCobolStatement, EnumObject.OBJECT_COPY_COBOL_ID);
	 		break;
			

		default:
			break;
		}

		return;
	}
 
	/*
     * 
     * Analizza l'istruzione di environment division.
     * 
     */
	private void analyzeEnvironmentDivisionStmt (InnerContextAnalysis ictx, Object instruction) throws ExceptionAmrita, SQLException {
		
		InstructionCobolEnvironment instructionEnvDivision = null;
		InstructionCobol copyCobolStatement;
		
		this.di.curNumInstr = this.curNumDefEnvDiv;			// Disponibile in caso di exception
		
		// Dispatcher analisi specifica istruzione
		switch (ictx.activeTypeInstr) {
		    // Select ..
			case ENV_DIV_SELECT:
				instructionEnvDivision = (InstructionCobolEnvironment) instruction;
				analyzeEnvSelect(instructionEnvDivision);
				break;
			// Decimal-point ..
			case ENV_DIV_SPECIAL_NAMES:
				instructionEnvDivision = (InstructionCobolEnvironment) instruction;
				analyzeEnvSpecialNames(instructionEnvDivision);
				break;
			// Definizioni java
			case ENV_DIV_REPOSITORY:
				instructionEnvDivision = (InstructionCobolEnvironment) instruction;
				analyzeEnvRepository(instructionEnvDivision);
				break;
			
			// Modulo copy: attivazione analizzatore specifico
			case DIR_COMPILER_COPY:	
				copyCobolStatement = (InstructionCobol)instruction;
				analyzeCopyStmt(ictx, copyCobolStatement, EnumObject.OBJECT_COPY_COBOL_ENV);
		 		break;
				

		default:
			break;
		}
		
 		return;
	}

	
    
	/*
     * 
     * Analizza l'istruzione di data division aggiornando fornita in input.
     * L'aggiornamento dei simboli e cross references dipende dal contesto chiamante
     * 
     */
	private void analyzeDataDivisionStmt (InnerContextAnalysis ictx, Object instruction) throws ExceptionAmrita, SQLException {
		
		ExceptionAmrita excp = null;  
		
		this.di.curNumInstr = this.curNumDefDataDiv;			// Disponibile in caso di exception
		
		// Definizioni istruzioni trattate
		Instruction instructionGeneric = null;
		InstructionCobol copyCobolStatement = null;
		InstructionCobolDataItem instructionDataItem = null;
		InstructionCobolDataStruct instructionDataDivision = null;
		InstructionCics instructionPrecompilerCics = null;
		InstructionSql instructionPrecompilerSql = null;
		InstructionDL1 instructionPrecompilerDL1 = null;
		
		// Statement FD: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_FD) {
			instructionDataDivision = (InstructionCobolDataStruct) instruction;
			analyzeDataFdSd(COBOL_FD, instructionDataDivision);
			return;
		}

		// Statement SD: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_SD) {
 			instructionDataDivision = (InstructionCobolDataStruct) instruction;
			analyzeDataFdSd(COBOL_SD, instructionDataDivision);
			return;
		}


		// Data item: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {
			instructionDataItem = (InstructionCobolDataItem) instruction;
			analyzeDataItemStmt(instructionDataItem);
			return;
		}

		
		// Modulo copy: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.DIR_COMPILER_COPY) {
			copyCobolStatement = (InstructionCobol)instruction;
			analyzeCopyStmt(ictx, copyCobolStatement, EnumObject.OBJECT_COPY_COBOL_DATA);
 			return;
		}
		// Precompilatore Cics: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_CICS) {
			instructionPrecompilerCics = (InstructionCics)instruction;
			analyzePrecompilerCics(instructionPrecompilerCics);
 			return;
		}  
		
		// Precompilatore Sql: attivazione analizzatore specifico
		if (ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_SQL) {
			instructionPrecompilerSql = (InstructionSql)instruction;
			analyzePrecompilerSql(instructionPrecompilerSql);
 			return;
		}
		
		// Tipologia istruzioni generiche che non devono essere gestite
		if (ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_SECTION_PROGRAM_DELIMITER
		||  ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_COMPILER_DIRECTIVE) {
			return;
		}
		
		// Istruzione non gestita
	    excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_DIVISION);
	    instructionGeneric = (Instruction) instruction;
	    instructionGeneric.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0017", "", excp, this.programName);
		
	}

  
    
	/*
     * 
     * Analizza l'istruzione di procedure division, se da analizzare.
     * Aggiornando le strutture interne, nell'istruzione, dei simboli utilizzati
     * 
     */
	private void analyzeProcDivisionStmt(InnerContextAnalysis ictx, Object instruction) throws ExceptionAmrita, SQLException {
		
		this.di.curNumInstr = this.curNumDefProcDiv;			// Disponibile in caso di exception
		
		// Dispatcher analisi delle sole istruzioni da analizzare.
		// Per esempio END-IF viene solo memorizzata.
		
		switch (ictx.activeTypeInstr) {

			    // Istruzioni Cobol
				case PROC_DIVISION: 
					analyzeProcProcDivision((InstructionCobolProcedure)instruction);
					break;
				case PROC_LABEL: 
					analyzeProcLabel((InstructionCobolProcedure)instruction);
					break;
				case PROC_SECTION: 
					analyzeProcSection(ictx, (InstructionCobolProcedure)instruction);
					break;
				case PROC_IF:  
					analyzeProcIf((InstructionCobolProcedure)instruction);
					break;
				case PROC_ELSE:  
					analyzeProcElse((InstructionCobolProcedure)instruction);
					break;
				case PROC_NEXT_SENTENCE:  
					analyzeProcNextSentence((InstructionCobolProcedure)instruction);
					break;
				case PROC_MOVE:  
					analyzeProcMove((InstructionCobolProcedure)instruction);
					break;
				case PROC_GOTO:   
					analyzeProcGoTo((InstructionCobolProcedure)instruction);
					break;
				case PROC_CALL:  
					analyzeProcCall(ictx, (InstructionCobolProcedure)instruction);
					break;
				case PROC_CANCEL:  
					analyzeProcCancel((InstructionCobolProcedure)instruction);
					break;
				case PROC_PERFORM:  
					analyzeProcPerform(ictx, (InstructionCobolProcedure)instruction);
					break;
				case PROC_EVALUATE:  
					analyzeProcEvaluate(ictx, (InstructionCobolProcedure)instruction);
					break;
				case PROC_SEARCH:  
					analyzeProcSearch((InstructionCobolProcedure)instruction);
					break;  
				case PROC_WHEN_EVALUATE_SEARCH:   
					analyzeProcWhenEvaluateSearch((InstructionCobolProcedure)instruction);
					break;
				case PROC_OPEN:  
					analyzeProcOpen((InstructionCobolProcedure)instruction);
					break;
				case PROC_CLOSE: 
					analyzeProcClose((InstructionCobolProcedure)instruction);
					break;
				case PROC_READ:  
					analyzeProcRead((InstructionCobolProcedure)instruction);
					break;
				case PROC_WRITE:  
					analyzeProcWrite((InstructionCobolProcedure)instruction);
					break;
				case PROC_REWRITE:  
					analyzeProcRewrite((InstructionCobolProcedure)instruction);
					break;
				case PROC_DELETE:  
					analyzeProcDelete((InstructionCobolProcedure)instruction);
					break;
				case PROC_START:  
					analyzeProcStart((InstructionCobolProcedure)instruction);
					break;
				case PROC_EXIT:  
					analyzeProcExit((InstructionCobolProcedure)instruction);
					break;
				case PROC_STOP: 
					analyzeProcStop((InstructionCobolProcedure)instruction);
					break;
				case PROC_GOBACK:  
					analyzeProcGoback((InstructionCobolProcedure)instruction);
					break;
				case PROC_CONTINUE:  
					analyzeProcContinue((InstructionCobolProcedure)instruction);
					break;
				case PROC_ENTRY:
					analyzeProcEntry((InstructionCobolProcedure)instruction);
					break;
				case PROC_COMPUTE:  
					analyzeProcCompute((InstructionCobolProcedure)instruction);
					break;
				case PROC_ADD:  
					analyzeProcAddSubMultDiv((InstructionCobolProcedure)instruction);
					break;
				case PROC_SUBTRACT:  
					analyzeProcAddSubMultDiv((InstructionCobolProcedure)instruction);
					break;
				case PROC_MULTIPLY:  
					analyzeProcAddSubMultDiv((InstructionCobolProcedure)instruction);
					break;
				case PROC_DIVIDE:  
					analyzeProcAddSubMultDiv((InstructionCobolProcedure)instruction);
					break;
				case PROC_SET:  
					analyzeProcSet((InstructionCobolProcedure)instruction);
					break;
				case PROC_INITIALIZE:  
					analyzeProcInitialize((InstructionCobolProcedure)instruction);
					break;
				case PROC_ACCEPT:  
					analyzeProcAccept((InstructionCobolProcedure)instruction);
					break;
				case PROC_DISPLAY:  
					analyzeProcDisplay((InstructionCobolProcedure)instruction);
					break; 
				case PROC_ALTER:
					analyzeProcAlter((InstructionCobolProcedure)instruction);
					break;
				case PROC_EXAMINE:
					analyzeProcExamine((InstructionCobolProcedure)instruction);
					break;
				case PROC_EXHIBIT:
					analyzeProcExibit((InstructionCobolProcedure)instruction);
					break;
				case PROC_STRING:  
					analyzeProcString((InstructionCobolProcedure)instruction);
					break;
				case PROC_UNSTRING:  
					analyzeProcUnstring((InstructionCobolProcedure)instruction);
					break;
				case PROC_TRANSFORM:
					analyzeProcTransform((InstructionCobolProcedure)instruction);
					break;
				case PROC_SORT:  
					analyzeProcSortMerge((InstructionCobolProcedure)instruction, "SORT");
					break;
				case PROC_MERGE:  
					analyzeProcSortMerge((InstructionCobolProcedure)instruction, "MERGE");
					break;
				case PROC_RETURN:  
					analyzeProcReturn((InstructionCobolProcedure)instruction);
					break;
				case PROC_RELEASE:  
					analyzeProcRelease((InstructionCobolProcedure)instruction);
					break;
				case PROC_INITIATE:
					analyzeProcInitiate((InstructionCobolProcedure)instruction);
					break;
				case PROC_TERMINATE:
					analyzeProcTerminate((InstructionCobolProcedure)instruction);
					break;
				case PROC_INSPECT:
					analyzeProcInspect((InstructionCobolProcedure)instruction);
					break;
				case PROC_DECLARATIVES:  
					analyzeProcDeclaratives((InstructionCobolProcedure)instruction);
					break;
				case PROC_INVOKE:   
					analyzeProcInvoke((InstructionCobolProcedure)instruction);
					break;
				case PROC_USE:  
					analyzeProcUse((InstructionCobolProcedure)instruction);
					break;

			     // Istruzioni di servizio per marcare eccezioni dal flusso normale
			 	case PROC_ON_SIZE_ERROR:  
			     	 analyzeProcOnSizeError((InstructionCobolProcedure)instruction);
			     	 break;
				case PROC_ON_OVERFLOW:  
				     analyzeProcOnOverflow((InstructionCobolProcedure)instruction);	
				     break;
				case PROC_ON_EXCEPTION:  
				     analyzeProcOnException((InstructionCobolProcedure)instruction);
				     break;
				case PROC_AT_END:  
				     analyzeProcAtEnd((InstructionCobolProcedure)instruction); 
				     break;
				case PROC_AT_END_OF_PAGE:	
				     analyzeProcAtEndOfPage((InstructionCobolProcedure)instruction);
				     break;
				case PROC_AT_EOP:	
				     analyzeProcAtEop((InstructionCobolProcedure)instruction);
				     break;
				case PROC_NOT_ON_SIZE_ERROR:	 
				     analyzeProcOnSizeError((InstructionCobolProcedure)instruction);
				     break;
				case PROC_NOT_ON_OVERFLOW:	
					 analyzeProcOnOverflow((InstructionCobolProcedure)instruction);
					 break;
				case PROC_NOT_ON_EXCEPTION:	 
				     analyzeProcOnException((InstructionCobolProcedure)instruction);
				     break;
				case PROC_NOT_AT_END:  
				     analyzeProcAtEnd((InstructionCobolProcedure)instruction);	
				     break;
				case PROC_NOT_AT_END_OF_PAGE: 
					 analyzeProcAtEndOfPage((InstructionCobolProcedure)instruction);
					 break;
				case PROC_NOT_AT_EOP:  	
				     analyzeProcAtEop((InstructionCobolProcedure)instruction);	
				     break;
				case PROC_NOT_INVALID_KEY:  
				     analyzeProcInvalidKey((InstructionCobolProcedure)instruction);	
				     break;
				case PROC_INVALID_KEY:  
					 analyzeProcInvalidKey((InstructionCobolProcedure)instruction);	
					 break;
 
			    // Istruzioni di chiusura rilevanti ai fini del grafo di programma		 
				case PROC_END_PERFORM:  
					analyzeProcPerform(ictx, (InstructionCobolProcedure)instruction);
					break;
				case PROC_END_EVALUATE:  
					analyzeProcEvaluate(ictx, (InstructionCobolProcedure)instruction);
					break;
					 
				// Direttive compilatore
		        case DIR_COMPILER_COPY:  
		        	analyzeCopyStmt(ictx, (InstructionCobol)instruction, EnumObject.OBJECT_COPY_COBOL_PROC);
		        	 break;
				case DIR_COMPILER_SERVICE:
					analyzeDirCompilerService((InstructionCobolProcedure)instruction);
					break;
					
				// Istruzioni di precompilatori
				case PRECOMPILER_CICS:
					analyzePrecompilerCics((InstructionCics)instruction);
					break;
				case PRECOMPILER_SQL:
					analyzePrecompilerSql((InstructionSql)instruction);
					break;
				default:
					break;
				}
	}
        
    /* -----------------------------------------------------
     * Simulazione inserimento copy precompilatori Sql/Cics 
     * -----------------------------------------------------
     * 
     * 1) In fase di normalizzazione source iniziale si è determinato se il
     *     programma era Cics/Sql/Dl1
     * 2) Questo metodo viene richiamato dopo l'analisi degli statements
     *    WS-Storage Section e Linkage section.
     *    i numeri di istruzione, in data division, di ws-storage e Linkage section
     * 3) Il file di pilot di esecuzione può avere codificate direttive quali:
     *    COPY_PRECOMPILER CICS LINKAGE CICS-EIB.cbl
     *    COPY_PRECOMPILER CICS WORKING CICS-API.cbl
     * 4) I copy, se necessario, vengono inseriti subito dopo gli statement
     *    Ws-Storage Section e Linkage Section.
     * 
     */
	private void precompilerCopySimulationInsert(InnerContextAnalysis ictx) throws ExceptionAmrita, SQLException {
	    
		Scanner scn = null;
		EnumCobolReservedWords activeTypeInstrOld = null;
		String precompiler = "";										// CICS|SQL|DL1
		String sectionCobol = "";										// WORKING|LINKAGE
		String copyName = "";											// name.suffix
		
		// Solo se statement sotto cui inserire eventuali copy
		if (ictx.activeTypeInstr != EnumCobolReservedWords.DATA_DIV_WS_SECTION
		&&  ictx.activeTypeInstr != EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION) {
			return;
		}
		activeTypeInstrOld = ictx.activeTypeInstr;
		
        // Scan copy precompiler in direttive di esecuzione
		for (String copyPrecompilerEntry : this.di.al_copyPrecompiler) {
			scn = new Scanner(copyPrecompilerEntry);
			
			// Info copy da includere
			precompiler = nextToken(scn);
			sectionCobol = nextToken(scn);
			copyName = nextToken(scn);
			
			// Condizioni NO operation
			if (precompiler.equals("SQL")  && !this.programCobol.isSqlProgram())  {continue;}
			if (precompiler.equals("CICS") && !this.programCobol.isCicsProgram()) {continue;}
			if (precompiler.equals("DL1") &&  !this.programCobol.isDl1Program())  {continue;}
			
			// Da includere dopo statement working
			if (sectionCobol.equals("WORKING") && ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_WS_SECTION) {
				precompilerCopySimulationPhisicalInclude(copyName);
				continue;
			}
			
			// Da includere dopo statement Linkage
			if (sectionCobol.equals("LINKAGE") && ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION) {
				precompilerCopySimulationPhisicalInclude(copyName);
				continue;
			}
		}
		
		ictx.activeTypeInstr = activeTypeInstrOld;
		
	}

	
    /* -----------------------------------------------
     * Inclusione copy precompiler in data division 
     * -----------------------------------------------
     * 
     * 1) Generazione statement copy fittizio
     * 2) Simulazione normale trattamento copy statement
     * 3) Il copyName potrebbe contenere un suffisso.
     *    Se presente viene eliminato ed eventualmente, in caso di ambiguità,
     *    codificare la direttiva di input FILE_SUFFIX_COPY
     */
	private void precompilerCopySimulationPhisicalInclude(String copyNameFull) throws ExceptionAmrita, SQLException {
		
		ProgramCobolEntry<? extends Instruction> programEntry = null;
		ProgramCobolEntry<? extends Instruction>[] ar_entryData = null;
		ProgramCobolEntry<? extends Instruction> entryData = null;
		InstructionCobol instructionCopyStmt = null;
		String ar_rowSource[] = null;
		String copyNameNoSuffix = "";
		@SuppressWarnings("unused")
		String suffix = "";
		String srcCopyStmt = "";
		int numInstrStart = 0;
		int i = 0;
		
		numInstrStart = this.curNumDefDataDiv;
		
		// Estrazione nome copy senza suffisso
		i = copyNameFull.indexOf(".");
		if (i < 0) {
			copyNameNoSuffix = copyNameFull;
		} else {
			copyNameNoSuffix = copyNameFull.substring(0, i);
			suffix = copyNameFull.substring(i + 1);
		}
				
		// Composizione statement copy simulata
		ar_rowSource = new String[1];
		srcCopyStmt = "COPY " + copyNameNoSuffix;
		ar_rowSource[0] = "            " + srcCopyStmt;
		instructionCopyStmt = new InstructionCobol();
		instructionCopyStmt.setRowsSource(ar_rowSource);
		instructionCopyStmt.setSourceInstr(srcCopyStmt);
		ictx.activeTypeInstr = EnumCobolReservedWords.DIR_COMPILER_COPY;
		ictx.objectInstr = instructionCopyStmt;

		// Creazione entry di programma con cast corretto e impostazioni varie correnti
		programEntry = createProgramEntry(instructionCopyStmt, this.ictx);
		programEntry.setEntryPrecompiler(true);
		this.di.curEntryCobol = programEntry;											// Disponibile in caso di exception
		
		// Analisi istruzione e aggiornamento strutture e variabili di controllo
		this.ictx.isInstructionToAnalyze = true;
		dispatchInstructionAnalyzer(this.ictx, instructionCopyStmt, programEntry);
		
	}


	/*
     * 
     * Analisi statement PROCEDURE DIVISION USING data-name1 data-name2 ..
     *                   PROCEDURE DIVISION.
     * 
     */
	private void analyzeProcProcDivision(InstructionCobolProcedure instruction)  {
		
		String sourceInstr = instruction.getSourceInstr();
		String str = "";
		ArrayList<DataItemCobolIdentifier> al_identifierUsingParm = null;
		
		str = sourceInstr.trim();

		// Elimino parole chiave
		str = str.replace("PROCEDURE", "");
		str = str.replace("DIVISION", "");
		str = str.replace("USING", "");
		str = str.trim();
		
		// Nessun parametro di using: return
		if (str.trim().equals("")) {
			return;
		}
		
		// Estrazione data item di Using
        al_identifierUsingParm = extractIdentifiers(instruction, str);
        // Parsing error
        if (instruction.isParsingError()) {
			return;
		}
        
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////

		// Opzione using e parametri using codificati nell'istruzione
 		instruction.procDivSetUsingParms(al_identifierUsingParm);
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Impostazione campo di using come symbolo di input
	  	// Impostazione di tutti i sottocampi eventuali come symboli di input
		for (DataItemCobolIdentifier identifier : al_identifierUsingParm) {
			addInstructionSymbolsUsedAndDefined(instruction, identifier, COBOL_DATA_ITEM_USED_INPUT);
		  	addInstructionSymbolsUsedAndDefinedGroup(instruction, identifier, INSTR_USE_DATA_ITEM_INPUT);
		}
	
	}
	

    /* ----------------------------------------------------
     * Inclusione data items impliciti per il compilatore
     * ----------------------------------------------------
     * 
      */
	private void insImplicitDataItems() throws ExceptionAmrita{
		ProgramCobolEntry<? extends Instruction> programEntry = null;
		InstructionCobolDataItem instructionDataItem = null;
		String strInstr = "";
		
		// Nulla da inserire
		if (this.hashSet_ImplicitData.size() == 0
		|| ictx.activeTypeInstr != EnumCobolReservedWords.DATA_DIV_WS_SECTION) {
			return;
		}
		
		strInstr="01 $IMPLICIT$.";
		programEntry=new ProgramCobolEntry();
		instructionDataItem = new InstructionCobolDataItem();
		programEntry.setInstruction(instructionDataItem);
		instructionDataItem.setSourceInstr(strInstr);
		analyzeDataItemStmt(instructionDataItem);
 
		updateProgramXrefDataFromInstruction(instructionDataItem, this.curNumDefDataDiv);
		this.curNumDefDataDiv = this.programCobol.addEntryData(programEntry);
		instructionDataItem.setNumInstr(this.curNumDefDataDiv);
		
		this.di.curNumInstr=this.curNumDefDataDiv;  // Valido in caso di exception					
		this.curNumDefDataDiv++;
 		
		
		// Scan Data items impliciti da inserire
        for (String idDataItem : this.hashSet_ImplicitData) {
        	strInstr="05 " + idDataItem + " PIC X(250) VALUE SPACE";
    		programEntry=new ProgramCobolEntry();
    		instructionDataItem = new InstructionCobolDataItem();
    		programEntry.setInstruction(instructionDataItem);
    		instructionDataItem.setSourceInstr(strInstr);
    		analyzeDataItemStmt(instructionDataItem);
     
    		updateProgramXrefDataFromInstruction(instructionDataItem, this.curNumDefDataDiv);
    		this.curNumDefDataDiv = this.programCobol.addEntryData(programEntry);
    		instructionDataItem.setNumInstr(this.curNumDefDataDiv);
    		
    		this.di.curNumInstr=this.curNumDefDataDiv;  // Valido in caso di exception					
    		this.curNumDefDataDiv++;
		}
        
        this.hashSet_ImplicitData.clear();
	}

	/*
     * 
     * Analisi statement label.
     * Viene solo inserita la label come simbolo definito nell'istruzione.
     * 
     */
	@SuppressWarnings("unchecked")
	private void analyzeProcLabel(InstructionCobolProcedure instruction) {
       
		String label= "";
		Object ar_object[] = null;
		ArrayList<Integer> al_numInstr = null;
		
		label = instruction.getSourceInstr().trim();
		instruction.addSymbolDefinedInside(label, EnumSymbolType.COBOL_SYMBOL_LABEL);
		
		// Caricamento Descriptor istruzione con opzioni e strutture dati
 		instruction.labelPutName(label);
 		 		
		// Map descrittore label|section
 		ar_object = this.map_LabelSection.get(label);

 		// Label definita prima di perform/goTo
 		if (ar_object == null) {
 	 		ar_object = new Object[6];
 			ar_object[0] = null;										// GraphNode
 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
			ar_object[5] = new Boolean(false);					        // Label 
  	 	    this.map_LabelSection.put(label, ar_object);
		}
		ar_object[3] = this.curNumDefProcDiv;						// Int numInstr def (prima incontrata)
		al_numInstr = (ArrayList<Integer>) ar_object[4];
		al_numInstr.add(this.curNumDefProcDiv);
		ar_object[5] = new Boolean(false);					            // Label 
 	}

	/*
     * 
     * Analisi statement nome-sction SECTION.
     * Viene solo inserita la section come simbolo definito nell'istruzione.
     * 
     */
	@SuppressWarnings("unchecked")
	private void analyzeProcSection(InnerContextAnalysis ictx, InstructionCobolProcedure instruction) {

		Scanner scn = null;
		ExceptionAmrita excp = null;
		Object ar_object[] = null;
		ArrayList<Integer> al_numInstr = null;
		String sourceInstr = instruction.getSourceInstr();
		String str = "";
		String strPriority = "";
		String section= "";
		int numPriority = 0;
		
		str = sourceInstr.trim();
		
		scn = new Scanner(str);
		section = nextToken(scn);				// Section name
		ictx.curProcInternalName = section;		// Di servizio
		nextToken(scn);    						// Section
		strPriority = nextToken(scn); 			// Eventuale priority
		
		// if any must be numeric
		if (!strPriority.equals("")) {
			if (!StringService._isNumeric(strPriority)) {
				instruction.setParsingError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
				return;
			}
			numPriority = StringService._getNumericInt(strPriority);
		}

		
        // Inserimento in simboli definiti dall'istruzione
		instruction.addSymbolDefinedInside(section, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		
		// Caricamento Descriptor istruzione con opzioni e strutture dati
  		instruction.sectionSetName(section);
 		if (!strPriority.equals("")) {
 			instruction.sectionSetPriority(numPriority);
		}
		 
        
		// Map descrittore label|section
 		ar_object = this.map_LabelSection.get(section);
 		
 		// Section definita prima di perform/goTo
 		if (ar_object == null) {
 	 		ar_object = new Object[6];
 			ar_object[0] = null;										// GraphNode
 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
			ar_object[3] = this.curNumDefProcDiv;						// Int numInstr def (prima incontrata)
			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
			ar_object[5] = new Boolean(true);       					// Section 
  	 	    this.map_LabelSection.put(section, ar_object);
		}
		al_numInstr = (ArrayList<Integer>) ar_object[4];
		al_numInstr.add(this.curNumDefProcDiv);
		ar_object[5] = new Boolean(true);					            // Section 
	
	}
    
	
	/*
	 * 
	 * Analisi istruzione IF 
	 * 
	 * 
	 */
	private void analyzeProcIf(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
        ExpressionCobol expression = null;
        DataItemCobolIdentifier identifier = null;
        
		String sourceInstr = instruction.getSourceInstr();
		String str = "";
		
		// Elimino if
		str = sourceInstr.substring(2).trim();
		// Elimino Then se presente 
		str = str + " ";
		str = str.replace(" THEN ", "");

		// Estraggo espressione condizione
		expression = extractExpression(instruction, str);  
        if (instruction.isParsingError()) {
			return;
		}
   
		// Condizione if nell'istruzione
		instruction.ifSetCondition(expression);
		
		// Inserimento simboli in input all'istruzione e definiti nell'istruzione
        for (ExpressionCobolElement expressionElement : expression.al_expressionElement) {
        	
        	// Operando: inserisco simboli definiti e in input all'istruzione
        	if (expressionElement.isOperand()) {
            	identifier = expressionElement.getDataItemIdentifier();
            	addInstructionSymbolsUsedAndDefined(instruction, identifier, COBOL_DATA_ITEM_USED_INPUT);
			}
		}		
		
	}
    

	/*
     * 
     * Analisi statement Else.
     * Non viene effettuata nessuna operazione particolare.
     * 
     */
	private void analyzeProcElse(InstructionCobolProcedure instruction) {	
		 
	}

	/*
     * 
     * Analisi statement Next Sentence.
     * Non viene effettuata nessuna operazione particolare.
     * 
     */
	private void analyzeProcNextSentence(InstructionCobolProcedure instruction) {
		 
	}

	
	/*
     * 
     * Analisi statement MOVE.
     * 
     * 1) MOVE A TO B  C  D
     * 2) MOVE corr A TO grp-A, ....
     * 3) MOVE A(i1,i2,in) OF grp-i TO ....
     * 4) MOVE A(i1,i2,in)(pos:lng) OF grp-i TO ....
     * 
     */
	private void analyzeProcMove(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		DataItemCobolIdentifier identifierFrom = null;
		ArrayList<DataItemCobolIdentifier> al_identifierTo = null;
		ArrayList<DataItemCobolIdentifier> al_identifierFrom = null;
		DataItemCobolIdentifier identifierFromImplicit = null;
		DataItemCobolIdentifier identifierToImplicit = null;
		InstructionCobolDataItem dataItemFrom = null;
		InstructionCobolDataItem dataItemTo = null;
        ExceptionAmrita excp = null;
        
		String sourceInstr = "";
		String str = "";
		String strNormalized = "";
		String strFrom = "";
		String strTo = "";
		boolean moveCorr = false;
		boolean moveAll = false;
		char doubleApice = 34;					// Doppio apice ""
		String strDoubleApice = new Character(doubleApice).toString();
		int iFrom = 0;
		int iTo = 0;
		int ar_pointerImplicitFrom[] = null;
		int ar_pointerImplicitTo[] = null;
		
		sourceInstr = getSourceNormalized(instruction.getSourceInstr());

		// Elimino Move
		str = sourceInstr.substring(4).trim();
        
		// Normalizzo situazioni come MOVE ALL'*' o MOVE ALL"*" inserendo uno spazio
		str=str.replace("ALL'", "ALL '");
		
		// Move Corresponding
		if (str.startsWith("CORRESPONDING ")) {
			str = str.substring(13).trim();
			moveCorr = true;
		} else if (str.startsWith("CORR ")) {
			str = str.substring(5).trim();
			moveCorr = true;
		}
		
		// Move All ...
		if (str.startsWith("ALL ")) {
			str = str.substring(4).trim();
			moveAll = true;
		}
       
		// Inserimento space prima di TO per codifiche tipo MOVE A(1,2)TO campo
		str = str.replace(")TO", ") TO ");
		str = str.replace("'TO", "' TO ");
		str = str.replace(strDoubleApice+"TO", strDoubleApice + " TO ");
		iFrom = 0;
		// Porebbe esserci TO dentro la literal
		strNormalized = replaceSpaceInLiteralWithUnderscore(instruction, str);
		iTo = strNormalized.indexOf(" TO ");
		if (iTo == -1) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			return;
		}
		
		// MOVE |CORR strFrom TO strTo
		strFrom = str.substring(iFrom, iTo).trim();
		strTo = str.substring(iTo + 4).trim();
		   
		// Estraggo identificatore di input e identificatori di output
		al_identifierFrom = extractIdentifiers(instruction, strFrom); 
		if (al_identifierFrom.size() == 0) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", strFrom, excp, new String[]{this.programName});
			return;
		}
		
		identifierFrom = al_identifierFrom.get(0);
		al_identifierTo = extractIdentifiers(instruction, strTo);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		// Move corresponding
		if (moveCorr) {
			instruction.moveSetCorr();
		}
		
		// Move reference modification
		if (!moveCorr) {
			if (identifierFrom.getQualifier() != null && identifierFrom.getQualifier().isThereRefModification()) {
				instruction.moveSetRefMod();
			}
			for (DataItemCobolIdentifier identifierTo : al_identifierTo) {
				if (identifierFrom.getQualifier() != null &&  identifierTo.getQualifier().isThereRefModification()) {
					instruction.moveSetRefMod();
				}
			}
		}
		
		// Move All
		if (moveAll) {
			instruction.moveSetAll();
		}
		// Campo sender di input e receiver di output
		instruction.moveSetIdentifierFrom(identifierFrom);
		instruction.moveSetIdentifiersTo(al_identifierTo);
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore di input
		addInstructionSymbolsUsedAndDefined(instruction, identifierFrom, COBOL_DATA_ITEM_USED_INPUT);
		 
		// Scan identificatori campi in output
		for (DataItemCobolIdentifier identifierTo : al_identifierTo) {
			addInstructionSymbolsUsedAndDefined(instruction, identifierTo, COBOL_DATA_ITEM_USED_OUTPUT);
		}
		
		if (!moveCorr) {
			return;
		}
		
		//////////////////////////////////////////////////////////////////////
		// Caricamento campi impliciti in input e output a fronte di Move Corr
		//////////////////////////////////////////////////////////////////////
		
        // Pointer campi elementari componenti il gruppo in input e in output
 		ar_pointerImplicitFrom = this.programCobol.dataItemsUnderGroupPointers(identifierFrom.getNumInstr(), DATA_ITEMS_ELEMENTARY_FIELDS);
 		ar_pointerImplicitTo = this.programCobol.dataItemsUnderGroupPointers(al_identifierTo.get(0).getNumInstr(), DATA_ITEMS_ELEMENTARY_FIELDS);
		
 		// Scan campi componenti il gruppo di input
 		for (int pointerFrom : ar_pointerImplicitFrom) {
			dataItemFrom = this.programCobol.dataItemDefinition(pointerFrom);
 			
			// Scan campi componenti il gruppo di output 
 			for (int pointerTo : ar_pointerImplicitTo) {
 				dataItemTo = this.programCobol.dataItemDefinition(pointerTo);
 				
 				// No match: skip
 				if (!dataItemFrom.getDataName().equals(dataItemTo.getDataName())) {
					return;
				}
 				
 				// Simbolo usato implicitamente dall'istruzione in unput
 				identifierFromImplicit = new DataItemCobolIdentifier();
 				identifierFromImplicit.setDataItem(dataItemFrom);
 				identifierFromImplicit.setNameIdentifier(dataItemFrom.getDataName());
				identifierFromImplicit.setIdentifierType(EnumCobolReservedWords.DATA_DIV_DATA_ITEM);
				identifierFromImplicit.setNumInstr(pointerFrom);
				addInstructionSymbolsUsedAndDefined(instruction, identifierFromImplicit, COBOL_DATA_ITEM_USED_INPUT); 				

 				// Simbolo usato implicitamente dall'istruzione in output
 				identifierToImplicit = new DataItemCobolIdentifier();
 				identifierToImplicit.setDataItem(dataItemTo);
 				identifierToImplicit.setNameIdentifier(dataItemTo.getDataName());
 				identifierToImplicit.setIdentifierType(EnumCobolReservedWords.DATA_DIV_DATA_ITEM);
 				identifierToImplicit.setNumInstr(pointerTo);
				addInstructionSymbolsUsedAndDefined(instruction, identifierToImplicit, COBOL_DATA_ITEM_USED_OUTPUT); 				
 			}
		}
	}

	/*
     * 
     * Analisi statement GO TO.
     * Viene gestito il GoTo incondizionato e il GoTo Depending On campo
     * 
     */
	@SuppressWarnings("unchecked")
	private void analyzeProcGoTo(InstructionCobolProcedure instruction) throws ExceptionAmrita {
        
		Scanner scn = null;
		String labelsDependingOn = "";
		String  ar_label[] = null;
		Object ar_object[] = null;
		ArrayList<Integer> al_numInstr = null;
		ArrayList<DataItemCobolIdentifier> al_identifierDependingOn = null;
		DataItemCobolIdentifier identifierDependingOn = null;
		String sourceInstr = null;
		String str = "";
		String label = "";
		String strIdentifierDependingOn = "";
		int iDepending = 0;
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(2).trim();  					// Elimino GO
		str = StringService._delFirstWord(str, "TO").trim();    	// Elimino TO opzionale
		scn = new Scanner(str);
		
		iDepending = str.indexOf(" DEPENDING ");
	
		// Non è Go To depending On: estrazione label
		if (iDepending < 0) {
			label = scn.next();
			instruction.addSymbolInput(label, EnumSymbolType.COBOL_SYMBOL_LABEL);
			ar_label = new String[1];
			ar_label[0] = label;
			instruction.goToPutLabels(ar_label);
			
			// Map descrittore goTo
	 		ar_object = new Object[2];
			ar_object[0] = null;									    // node goTo
			ar_object[1] = ar_label;									// String[] labels
	 	    this.map_GoTo.put(this.curNumDefProcDiv, ar_object);
	 	    // Map descrittore labelSection
			ar_object = this.map_LabelSection.get(label);
	 		if (ar_object == null) {
	 	 		ar_object = new Object[6];
	 			ar_object[0] = null;										// GraphNode
	 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
	 			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
				ar_object[3] = 0;											// Int numInstr def
	 			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
	 			ar_object[5] = false;					                    // true/false a fronte di label/section
	  	 	    this.map_LabelSection.put(label, ar_object);
			} 
			al_numInstr = (ArrayList<Integer>) ar_object[1];
			al_numInstr.add(this.curNumDefProcDiv);
			return;
		}
		 
		// E' Go To depending On

		labelsDependingOn = str.substring(0, iDepending).trim();   	// Elenco di label separate o meno da virgole
		str = str.substring(iDepending + 10).trim();
		str = StringService._delFirstWord(str, "ON").trim();    			//  Elimino ON opzionale
		scn = new Scanner(str);
		strIdentifierDependingOn = scn.next();
			
		// Estraggo le label
		labelsDependingOn = labelsDependingOn.replace(',', ' ');
		ar_label = labelsDependingOn.split(" +");
		
		// Estraggo identificatore di selezione label in input
		al_identifierDependingOn = extractIdentifiers(instruction, strIdentifierDependingOn);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		identifierDependingOn = al_identifierDependingOn.get(0);
		   
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		instruction.goToPutLabels(ar_label);
		instruction.goToPutDependingOnField(identifierDependingOn);
		instruction.goToSetDependingOn();
		
		// Identificatore di input
		addInstructionSymbolsUsedAndDefined(instruction, identifierDependingOn, COBOL_DATA_ITEM_USED_INPUT);

		// Scan label e inserimento simbolo in input all'istruzione
		for (int i = 0; i < ar_label.length; i++) {
			label = ar_label[i];
			
			instruction.addSymbolInput(ar_label[i], EnumSymbolType.COBOL_SYMBOL_LABEL);
			
	 	    // Map descrittore labelSection
			ar_object = this.map_LabelSection.get(label);
	 		if (ar_object == null) {
	 	 		ar_object = new Object[6];
	 			ar_object[0] = null;										// GraphNode
	 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
	 			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
				ar_object[3] = 0;											// Int numInstr def
	 			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
	 			ar_object[5] = false;										// true/false a fronte di label/section
	  	 	    this.map_LabelSection.put(label, ar_object);
			} 
			al_numInstr = (ArrayList<Integer>) ar_object[1];
			al_numInstr.add(this.curNumDefProcDiv);
		}
		
				
 		// Map descrittore goTo
 		ar_object = new Object[2];
		ar_object[0] = null;									    // node goTo
		ar_object[1] = ar_label;									// String[] labels
 	    this.map_GoTo.put(this.curNumDefProcDiv, ar_object);
	}

	
    /*
     * 
     * Analisi statement Call.
     * Eventuali situazioni di exception vengono gestite come istruzioni separate.
     * 
     */
	private void analyzeProcCall(InnerContextAnalysis ictx, InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		EntityObject eo = null;
		ProgramCobol programCobolCalled = null;
		EntityDynamicField edf = null;
		EntityDynamicFieldSub edfs = null;
		ArrayList<DataItemCobolIdentifier> al_identifierProgramName = null;
		ArrayList<DataItemCobolIdentifier> al_identifierParm = null;
		ArrayList<DataItemCobolIdentifier> al_identifierGivingReturning = null;
		Object[] ar_objEntity = null;
		
		DataItemCobolIdentifier identifierProgramName = null;
		DataItemCobolIdentifier identifierGivingReturning = null;
		String sourceInstr = null;
		String str = "";
		String strUsingParm = "";
		String strGivingReturning = "";
		String pgmNameToCall = "";
		String copyOrigin = "";
		
		String strIdentifierProgramName = "";
		@SuppressWarnings("unused")
		boolean isMfLitlink = false;
		int iUsing = 0;
		int iUsingEnd = 0;
		int iGiving = 0;											// Cobol MF
		int iReturning = 0;											// Cobol MF
		int rowStart = 0;
		int rowEnd = 0;
		int rowStartInCopy = 0;
		int rowEndInCopy = 0;
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(4).trim();  					// Elimino CALL
		iUsingEnd = str.length();                                   // Default fino a fine stringa
		  
		// Eventuale clausola Giving/Returning
		iGiving = str.indexOf(" GIVING ");
		iReturning = str.indexOf(" RETURNING ");
		
		// Estrazione giving/returning
		if (iGiving > 0) {
			iUsingEnd = iGiving;
			strGivingReturning = str.substring(iGiving + 8).trim();
			if (strGivingReturning.startsWith("INTO ")) {
				strGivingReturning = strGivingReturning.substring(5).trim();
			}
		}
		if (iReturning > 0) {
			iUsingEnd = iReturning;
			strGivingReturning = str.substring(iReturning + 11);
		}
		
		// Estrazione nome programma e parametri Using
		iUsing = str.indexOf(" USING ");
        if (iUsing > 0) {
        	strIdentifierProgramName = str.substring(0, iUsing).trim();
        	strUsingParm = str.substring(iUsing + 7, iUsingEnd).trim();
 		} else {
 			strIdentifierProgramName =  str.substring(0);
 		}
              
        // Solo se Cobol MF
        if (strIdentifierProgramName.startsWith("LITLINK")) {
        	strIdentifierProgramName = strIdentifierProgramName.substring(7).trim();
        	isMfLitlink = true;
		}
        
		// Estraggo identificatori completi nome programma e parametri using
		al_identifierProgramName = extractIdentifiers(instruction, strIdentifierProgramName);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		
		identifierProgramName = al_identifierProgramName.get(0);
		if (!strUsingParm.equals("")) {
			al_identifierParm = extractIdentifiers(instruction, strUsingParm);
		}

		// Estraggo identificatore completo Giving/Returning se presente
		if (!strGivingReturning.equals("")) {
			al_identifierGivingReturning = extractIdentifiers(instruction, strGivingReturning);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				return;
			}
			identifierGivingReturning = al_identifierGivingReturning.get(0);
		}
		
		// Imposto il nome del campo contenente il programma o il valore della literal
		pgmNameToCall = identifierProgramName.getNameIdentifierFormatted();
		
		//////////////////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e descrittore per nome pgm
		//////////////////////////////////////////////////////////////////////////////////
         
		// Nome programma o literal
		addInstructionSymbolsUsedAndDefined(instruction, identifierProgramName, COBOL_DATA_ITEM_USED_INPUT);
        
		// Parametri Using
		if (iUsing > 0 ) {
			for (DataItemCobolIdentifier innerIdentifier : al_identifierParm) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
			}  
			// Inserisce anche l'opzione using
			instruction.callSetUsingParms(al_identifierParm);
		}
		
		// Caricamento dataItem Program in descrittore istruzione per successiva soluzione istruzione
		instruction.callSetProgram(identifierProgramName);
		instruction.addOperandDynamic("PROGRAM", identifierProgramName);
		
		// Giving
		if (iGiving > 0) {
			instruction.callSetGiving(identifierGivingReturning);
			addInstructionSymbolsUsedAndDefined(instruction, identifierGivingReturning, COBOL_DATA_ITEM_USED_OUTPUT);
		}
		// Returning
		if (iReturning > 0) {
			instruction.callSetReturning(identifierGivingReturning);
			addInstructionSymbolsUsedAndDefined(instruction, identifierGivingReturning, COBOL_DATA_ITEM_USED_OUTPUT);
		}

		// Caricamento dataItem Programmi in descrittore istruzione per successiva soluzione istruzione
		instruction.callCancelPutPgmFieldIdentifiers(al_identifierProgramName);


		//////////////////////////////////////////////////////////////////////////////////
		// Inserimento in strutture dati per update fina db		
		//////////////////////////////////////////////////////////////////////////////////
		
		instruction.setDynamic(false);               // Suppongo L'istruzione è statica
	
		// Istruzione DINAMICA: Inserimento campo istruzione dinamica in tabella DynamicField  e DynamicFieldSub con sottocampo a space 
		// Viene comunque inserito il campo dinamico in quanto potrebbe non essere attivo il flag di elaborazione istruzioni dinamiche
		// e non verrebbe pertanto tracciata l'istruzione
       	// La soluzione viene effettuata a fine analisi e tutte le istruzioni del programma devono essere già state analizzate.
		if (identifierProgramName.getIdentifierType() != EnumCobolReservedWords.OPERAND_LITERAL_ALPHA) {
			instruction.setDynamic(true);	
			// Inserimento istruzione dinamica in tabella DynamicField
			edf = new EntityDynamicField();
			edf.setSystem(this.di.systemInput);  
			edf.setSubSystem(this.di.subSystemInput);
			edf.setIdObject(this.pgmNameUnderParsing);
			edf.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			edf.setNumInstr(this.curNumDefProcDiv);
			edf.setIdField(identifierProgramName.getNameIdentifier());			
			edf.setNumField(identifierProgramName.getDataItem().getNumInstr()); // Data
			edf.setInstrCobolType(EnumCobolReservedWords.PROC_CALL);
			edf.setInstrPrecompType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
			edf.setInstrPrecompOprndType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
			this.analyzerDbInfo.addObjEntityDynamicField(edf);
			
	    // Istruzione STATICA, inserimento oggetti e relazioni su db.
		} else  {
			// Call dentro copy
			if (ictx.isCopyIncludingInProgress) {
				Instruction instrCopy = (Instruction) ictx.objectInstr;
				rowStart = instrCopy.getRowStartSource();
				rowEnd = instrCopy.getRowEndSource();
				copyOrigin = ictx.copyNameToInclude;
				rowStartInCopy = instruction.getRowStartSource();
				rowEndInCopy = instruction.getRowEndSource();
			// Call dentro pgm in analisi
			} else {
				rowStart = instruction.getRowStartSource();
				rowEnd = instruction.getRowEndSource();
				rowStartInCopy = 0;
				rowEndInCopy = 0;
			}
			
			
			instruction.setNumInstr(this.curNumDefProcDiv);
			// Inserisce oggetto pgm in struttura da subsys corrente/Owner/new
			eo=this.analyzerDbInfo.getAddObjectEntitled(pgmNameToCall, EnumObject.OBJECT_PGM_COBOL);
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
					  EnumObject.OBJECT_PGM_COBOL
					, this.programName
					, EnumObject.OBJECT_PGM_COBOL
					, pgmNameToCall
					, EnumObjectStatus.OBJECT_TO_BE_ANALYZED
					, EnumRelation.PGM_CALLED_PGM                          // PGM_CALLED_PGM , PGM_CANCEL_PGM
					, EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
					, this.programName
					, this.curNumDefProcDiv
					, rowStart
					, rowEnd
					, copyOrigin                                  
					, rowStartInCopy  									 
					, rowEndInCopy 									 
					, instruction.getTypeInstrCategory()
					, this.activeDivisionArea
					, false
					, false
					, identifierProgramName.getIdentifierType() != EnumCobolReservedWords.OPERAND_LITERAL_ALPHA        // true = dynamic  
					, this.di.userExitInfoPgm
					);
						
			
		}

	}
 
	
	
	/*
     * Analisi statement Cancel.
     * Questa istruzione può includere istruzioni imperative GO TO al suo interno
     * a fronte di OVERFLOW e EXCEPTION, le cui label vengono memorizzate nel
     * descriptor dell'istruzione.
     * 
    */
	private void analyzeProcCancel(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		EntityObject eo = null;
		EntityDynamicField edf = null;
		EntityDynamicFieldSub edfs = null;
		ArrayList<DataItemCobolIdentifier> al_identifierProgramName = null;

		String sourceInstr = null;
		String strPrograms = "";
		String copyOrigin = "";
		int progProgram = 0;
		int rowStart = 0;
		int rowEnd = 0;
		int rowStartInCopy = 0;
		int rowEndInCopy = 0;

		instruction.setDynamic(true);               						// Suppongo L'istruzione è dinamica
		sourceInstr = instruction.getSourceInstr();
		strPrograms = sourceInstr.substring(6).trim();  					// Elimino CANCEL

		// Estrazione identificatori completi nomi di programma
		al_identifierProgramName = extractIdentifiers(instruction, strPrograms);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}

		// Caricamento dataItem Programmi in descrittore istruzione per successiva soluzione istruzione
		instruction.callCancelPutPgmFieldIdentifiers(al_identifierProgramName);


		///////////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e preparazione per db
		///////////////////////////////////////////////////////////////////////////

		instruction.setDynamic(false);               // Suppongo L'istruzione è statica
		instruction.setNumInstr(this.curNumDefProcDiv);

		// Soluzione istruzione solo se statica, inserimento oggetti e relazioni su db
		// Se istruzione dinamica la soluzione viene effettuata a fine analisi.
		// Per l'analisi dinamica tutte le istruzioni del programma devono essere analizzate.
		// Recupero descrittori completi campi nome programma
		al_identifierProgramName = instruction.callCancelGetPgmFieldIdentifiers();

		// Analisi generalizzata valori dinamici (e statici) assunti dai nomi programma
		for (DataItemCobolIdentifier identifierProgramName : al_identifierProgramName) {

			// Campo DINAMICO: Inserimento campo istruzione dinamica in tabella DynamicField  e DynamicFieldSub con sottocampo a space 
	       	// La soluzione viene effettuata a fine analisi e tutte le istruzioni del programma devono essere già state analizzate.
			if (identifierProgramName.getIdentifierType() != EnumCobolReservedWords.OPERAND_LITERAL_ALPHA) {
				addInstructionSymbolsUsedAndDefined(instruction, identifierProgramName, COBOL_DATA_ITEM_USED_INPUT);
				// Inserimento istruzione dinamica in tabella DynamicField 
				instruction.setDynamic(true);
				instruction.addOperandDynamic("PROGRAM"+progProgram++, identifierProgramName);
				edf = new EntityDynamicField();
				edf.setSystem(this.di.systemInput); 							        // Key
				edf.setSubSystem(this.di.subSystemInput);
				edf.setIdObject(this.pgmNameUnderParsing);
				edf.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
				edf.setNumInstr(this.curNumDefProcDiv);
				edf.setIdField(identifierProgramName.getNameIdentifier());
				edf.setNumField(identifierProgramName.getDataItem().getNumInstr()); 	// Data
				edf.setInstrCobolType(EnumCobolReservedWords.PROC_CANCEL);
				edf.setInstrPrecompType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
				edf.setInstrPrecompOprndType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
				this.analyzerDbInfo.addObjEntityDynamicField(edf);	
				/*
				// Inserimento sottocampo a space  in tabella DynamicFieldSub 
				// Questo in quanto i valori sono sempre a livello di sottocampo (space se unico campo elementare)
				edfs = new EntityDynamicFieldSub();
				edfs.setSystem(this.di.systemInput);  
				edfs.setSubSystem(this.di.subSystemInput);
				edfs.setIdObject(this.pgmNameUnderParsing);
				edfs.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
				edfs.setNumInstr(this.curNumDefProcDiv);
				edfs.setIdField(identifierProgramName.getNameIdentifier());	
				edfs.setIdSubField("");	
				edfs.setNumField(identifierProgramName.getDataItem().getNumInstr()); // Data
				this.analyzerDbInfo.addObjEntityDynamicFieldSub(edfs);
				*/				
				continue;
			}

			// Inserisce oggetto pgm in struttura da subsys corrente/Owner/new
			eo=this.analyzerDbInfo.getAddObjectEntitled(identifierProgramName.getNameIdentifierFormatted(), EnumObject.OBJECT_PGM_COBOL);

			// Riga inizio e fine istruzione sono del copy dove la cancel si trova
			if (ictx.isCopyIncludingInProgress) {
				Instruction instrCopy = (Instruction) ictx.objectInstr;
				rowStart = instrCopy.getRowStartSource();
				rowEnd = instrCopy.getRowEndSource();
				copyOrigin = ictx.copyNameToInclude;
				rowStartInCopy = instruction.getRowStartSource();
				rowEndInCopy = instruction.getRowEndSource();
			// Riga inizio e fine sono del programma corrente
			} else {
				rowStart = instruction.getRowStartSource();
				rowEnd = instruction.getRowEndSource();
				rowStartInCopy = 0;
				rowEndInCopy = 0;
			}
			
		    // Istruzione STATICA, inserimento oggetti e relazioni su db.
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
					EnumObject.OBJECT_PGM_COBOL
					, this.programName
					, EnumObject.OBJECT_PGM_COBOL
					, identifierProgramName.getNameIdentifierFormatted()
					, EnumObjectStatus.OBJECT_TO_BE_ANALYZED
					, EnumRelation.PGM_CALLED_PGM                          // PGM_CALLED_PGM , PGM_CANCEL_PGM
					, EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
					, this.programName
					, curNumDefProcDiv
					, rowStart
					, rowEnd
					, copyOrigin                                  
					, rowStartInCopy  									 
					, rowEndInCopy 									 
					, instruction.getTypeInstrCategory()
					, this.activeDivisionArea
					, false
					, false
					, identifierProgramName.getIdentifierType() != EnumCobolReservedWords.OPERAND_LITERAL_ALPHA        // true = dynamic  
					, this.di.userExitInfoPgm
					);

		} // end-for		

		// Tipologia nodo grafo di programma

	}

	
	/*
     * Analisi statement Perform.
     * 
    */
	@SuppressWarnings("unchecked")
	private void analyzeProcPerform(InnerContextAnalysis ictx, InstructionCobolProcedure instruction) throws ExceptionAmrita {

		Scanner scn = null;
		ArrayList<DataItemCobolIdentifier> al_identifier = null;
		ArrayList<String> al_VaryingFromByUntil = null;
		ArrayList<CobolPerformLoop> al_innerLoopCondition = null;		// Condizioni di loop codificate
		ArrayList<Integer> al_numInstr = null;							// Numeri istruzioni chiamanti 
		Object ar_object[] = null;
		CobolPerformLoop innerPerformCondition = null;				    // Condizione di loop codificata
		ExpressionCobol expression = null;                              // Espressione aritmetico/logica
		String ar_String[] = null;
		String token = "";
		String sourceInstr = "";
		String procedureName = "";
		String procedureNameThru = "";
        String timesIdentifier = "";
        String varyingIdentifier = "";
        String varyingFrom = "";
        String varyingBy = "";
        String varyingFromByUntil = "";
		String until = "";
		String str = "";												// Stringhe estratte da istruzione
		char crtSplit = 0;
		String crtStrtSplit = "";
		boolean withTestBefore = false;
		boolean withTestAfter = false;
		boolean innerPerform = false;
		int iTimes = 0;													// Posizione parole chiave
		
		  
		// End-perform: aggiornamento tipo nodo
		if (ictx.activeTypeInstr == EnumCobolReservedWords.PROC_END_PERFORM) {
			return;
		}

		sourceInstr = instruction.getSourceInstr();
				
		// Di servizio  
		al_identifier = new ArrayList<DataItemCobolIdentifier> ();
		al_VaryingFromByUntil = new ArrayList<String> ();
		al_innerLoopCondition = new ArrayList<CobolPerformLoop> ();
		crtStrtSplit = Character.toString(crtSplit);
		
		// Elimino Perform  
		if (sourceInstr.length() > 9) {
			str = " " + sourceInstr.substring(8).trim().toUpperCase() + " ";
		}
		    
		// Elimino le parole opzionali per comodita di gestione
		str = str.replace(" WITH "," ");
        str = str.trim();
        // normalizzo eventuali parentesi
        str = str.replace("(", " ( ");
        str = str.replace(")", " ) ");
        
		scn = new Scanner(str);

		// Section o paragrafo
		token = nextToken(scn);
		
		// Inner perform: non cè il nome della procedura oppure si tratta di Perform K times
		if (token.equals("TEST")
		||  token.equals("VARYING")
		||  token.equals("UNTIL")
		||  this.programCobol.dataItemPointers(token)!= null
		||  StringService._isNumericInt(token)) {
			innerPerform = true;
		}
		
		
		// Solo se non inner perform
		if (!innerPerform) {
			procedureName = token;
			
			// Verifica se nome di Section o Label
			str = str.substring(token.length());
			scn = new Scanner(str);
			token = nextToken(scn);
			if (token.equals("THRU") || token.equals("THROUGH")) {
				token = nextToken(scn);
				procedureNameThru = token;
				token = nextToken(scn);
			}
		}

		// Verifica se Inner Perform k Times
		iTimes = str.indexOf(" TIMES");
		if (iTimes > 0) {
			timesIdentifier = token;
			token = "";
		}

		// Scan tokens
		while (!token.equals("")) {
			
			// Clausola With Test After
			if (token.equals("TEST")) {
				str = str.substring(token.length()).trim();
				token = nextToken(scn);
				if (token.equals("BEFORE")) {
					withTestBefore = true;
				} else {
					withTestAfter = true;
				}
				token = nextToken(scn);
				continue;
			}
			
			// Clausola Until
			if (token.equals("UNTIL")) {
				token = nextToken(scn);
				while (!token.equals("")) {
					// Gruppo finale di clausole After ..
					if (token.equals("AFTER")) {
						break;
					}
					until = until + " " + token;
					token = nextToken(scn);
				}
				varyingFromByUntil = varyingIdentifier + crtStrtSplit + varyingFrom + crtStrtSplit + varyingBy + crtStrtSplit + until;
				varyingIdentifier = "";
				varyingFrom = "";
				varyingBy = "";
                until = "";
				al_VaryingFromByUntil.add(varyingFromByUntil);
				
				// Ci sono ancora successive clusole After da analizzzare: gestiione generalizzata Varying in ciclo
				if (token.equals("AFTER")) {
					token = "VARYING";
					continue;
				}
				// Fine stringa
				break;
				
			} // end-if
            
			// Clausola Varying From By
			if (token.equals("VARYING")) {
				
				// Estraggo Varying identifier
				token = nextToken(scn);
				while (!token.equals("FROM")) {
					varyingIdentifier = varyingIdentifier + " " + token;
					token = nextToken(scn);
				} // end-while
				
				// Estraggo From identifier
				token = nextToken(scn);
				while (!token.equals("BY")) {
					varyingFrom = varyingFrom + " " + token;
					token = nextToken(scn);
				} // end-while
				
				// Estraggo By identifier
				token = nextToken(scn);
				while (!token.equals("UNTIL")) {
					varyingBy = varyingBy + " " + token;
					token = nextToken(scn);
				} // end-while
				continue;
				
			} // end-if
			
			// Clausola non riconosciuta
			instruction.setParsingError(true);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, null, new String[]{this.programName});
            return;
            
		} // end-while
		
		
        // Inner perform
        if (procedureName.equals("")) {
        	instruction.performSetInnerPerform(true);
		}

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////


		if (!procedureName.equals("")) {
			instruction.performSetFrom(procedureName);
			instruction.addSymbolInput(procedureName, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
		
		if (!procedureNameThru.equals("")) {
			instruction.performSetThru(procedureNameThru);
			instruction.performSetWithThru();
			instruction.addSymbolInput(procedureNameThru, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}

		// Perform ... k times
		if (!timesIdentifier.equals("")) {
			al_identifier = extractIdentifiers(instruction, timesIdentifier.trim());
			addInstructionSymbolsUsedAndDefined(instruction, al_identifier.get(0), COBOL_DATA_ITEM_USED_INPUT);
			instruction.performSetTimes(al_identifier.get(0));
			instruction.performSetWithTimes();
		    return;
		}
		
		// Varying k
		if (!varyingIdentifier.equals("")) {
			instruction.performSetWithVarying(true);
			al_identifier = extractIdentifiers(instruction, varyingIdentifier.trim());
			addInstructionSymbolsUsedAndDefined(instruction, al_identifier.get(0), COBOL_DATA_ITEM_USED_INPUT);
			instruction.performSetVarying(al_identifier.get(0));
		}
		
		// With test after/befor
        if (withTestAfter) {
         	instruction.performSetWithTestAfter();
		}
        if (withTestBefore) {
        	instruction.performSetWithTestBefore();
		}
        
		
		// Condizioni di loop
		
		// Scan condizioni di loop in source rilevate
		for (String loopDescriptor : al_VaryingFromByUntil) {
			 
			// estrazione singoli parametri di loop
			ar_String = loopDescriptor.split(crtStrtSplit);

			innerPerformCondition = new CobolPerformLoop();

			// Varying Identifier
			str = ar_String[0].trim();
			if (!str.equals("")) {
				al_identifier = extractIdentifiers(instruction, str);
				if (instruction.isParsingError()
				|| instruction.isSemanticError()) {
					return;
				}
				innerPerformCondition.setVaryingIdentifier(al_identifier.get(0));
				addInstructionSymbolsUsedAndDefined(instruction, al_identifier.get(0), COBOL_DATA_ITEM_USED_OUTPUT);
			}
			
			// From expression
			str = ar_String[1].trim();
			if (!str.equals("")) {
				expression = extractExpression(instruction, str);
				if (instruction.isParsingError()
				|| instruction.isSemanticError()) {
					return;
				}
				innerPerformCondition.setFromExpression(expression);
				addInstructionSymbolsExpressionInput(instruction, expression);
			}
			
			// By Identifier  
			str = ar_String[2].trim();
			if (!str.equals("")) {
				al_identifier = extractIdentifiers(instruction, str);
				if (instruction.isParsingError()
				|| instruction.isSemanticError()) {
					return;
				}
				innerPerformCondition.setByIdentifier(al_identifier.get(0));
				addInstructionSymbolsUsedAndDefined(instruction, al_identifier.get(0), COBOL_DATA_ITEM_USED_INPUT);
			}
			
			// Until condition expression
			str = ar_String[3].trim();
			if (!str.equals("")) {
				expression = extractExpression(instruction, str);
				if (instruction.isParsingError()
				|| instruction.isSemanticError()) {
					return;
				}
				instruction.performSetWithUntil();
				innerPerformCondition.setUntilConditionExpression(expression);
				addInstructionSymbolsExpressionInput(instruction, expression);
			}
			
			// Append condizione di loop
			al_innerLoopCondition.add(innerPerformCondition);
		}
        instruction.performSetUntil(al_innerLoopCondition);
        
        // Inner perforem: fine operazioni
        if (innerPerform) {
			return;
		}
        
        ar_object = this.map_LabelSection.get(procedureName);
        
		// Perform a label|section incontrata prima di definizione di label o section
		if (ar_object == null) {
			ar_object = new Object[6];
			ar_object[0] = null;										// GraphNode
			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
			ar_object[3] = 0;											// Int numInstr definizione label/section
			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
			ar_object[5] = new Boolean(false);							// false (suppongo perform a paragrafo)
	 	    this.map_LabelSection.put(procedureName, ar_object);
		} 
   		// Update num instr performing
		al_numInstr = (ArrayList<Integer>) ar_object[2];
		al_numInstr.add(this.curNumDefProcDiv);
 	}

	
	/*
     * Analisi statement Open.
     * 
     * Questa istruzione può includere istruzioni imperative GO TO al suo interno
     * a fronte di OVERFLOW e EXCEPTION, trattate come istruzioni separate.
     * 
    */
	private void analyzeProcOpen(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {
		
		ArrayList<String> al_OpenInput = null;
		ArrayList<String> al_OpenOutput = null;
		ArrayList<String> al_OpenIO = null;
		ArrayList<String> al_OpenExtend = null;
		ArrayList<String> al_OpenUnion = null;
		Scanner scn = null;
		
		String sourceInstr = null;
		String str = "";
		String token = "";
		String fileNameOpen = "";
		int typeOpen = COBOL_OPEN_INPUT;
		
		al_OpenInput = new ArrayList<String> ();
		al_OpenOutput = new ArrayList<String> ();
		al_OpenIO = new ArrayList<String> ();
		al_OpenExtend = new ArrayList<String> ();
		al_OpenUnion = new ArrayList<String> ();

		
		
		sourceInstr = instruction.getSourceInstr();
		
		// Elimino OPEN
		str = sourceInstr.substring(4).trim().toUpperCase() + " ";  
		
		// Elimino parole chiave non gestite
		str = str.replace(" REEL ", " ");
		str = str.replace(" UNIT ", " ");
		str = str.replace(" FOR ", " ");
		str = str.replace(" REMOVAL ", " ");
		str = str.replace(" REVERSED ", " ");
		str = str.replace(" NO ", " ");
		str = str.replace(" WITH ", " ");
		str = str.replace(" REWIND ", " ");
		str = str.replace(" LOCK ", " ");
		str = str.replace(",", " ");
		
		
		scn = new Scanner(str);
		token = nextToken(scn);
		
		// Scan tokens
		while (!token.equals("")) {
						
			if (token.equals("INPUT")) {
				typeOpen = COBOL_OPEN_INPUT;
				token = nextToken(scn);
				continue;
			} else if (token.equals("OUTPUT")) {
				typeOpen = COBOL_OPEN_OUTPUT;
				token = nextToken(scn);
				continue;
			} else if (token.equals("I-O")) {
				typeOpen = COBOL_OPEN_I_O;
				token = nextToken(scn);
				continue;
			} else if (token.equals("EXTEND")) {
				typeOpen = COBOL_OPEN_EXTEND;
				token = nextToken(scn);
				continue;
			}
			
			fileNameOpen = token;
			
			switch (typeOpen) {
				case COBOL_OPEN_INPUT:
					al_OpenInput.add(fileNameOpen);
					break;
				case COBOL_OPEN_OUTPUT:
					al_OpenOutput.add(fileNameOpen);
					break;
				case COBOL_OPEN_I_O:
					al_OpenIO.add(fileNameOpen);
					break;
				case COBOL_OPEN_EXTEND:
					al_OpenExtend.add(fileNameOpen);
					break;
			}
			
			token = nextToken(scn);

		}
		
 		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
    	instruction.openSetInputFiles(al_OpenInput);
      	instruction.openSetOutputFiles(al_OpenOutput);
     	instruction.openSetIOFiles(al_OpenIO);
     	instruction.openSetExtendFiles(al_OpenExtend);
		
		////////////////////////////////////////////////////////////////////
		// Caricamento nomi files utilizzati input 
		////////////////////////////////////////////////////////////////////
		
		for (String fileNameInput : al_OpenInput) {
			instruction.addSymbolInput(fileNameInput, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
			al_OpenUnion.add(fileNameInput);
		}
		for (String fileNameOutput : al_OpenOutput) {
			instruction.addSymbolInput(fileNameOutput, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
			al_OpenUnion.add(fileNameOutput);
		}
		for (String fileNameIO : al_OpenIO) {
			instruction.addSymbolInput(fileNameIO, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
			al_OpenUnion.add(fileNameIO);

		}
		for (String fileNameExtend : al_OpenExtend) {
			instruction.addSymbolInput(fileNameExtend, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
			al_OpenUnion.add(fileNameExtend);
		}
		
	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
		
		// Scan files aperti dall'istruzione
		for (String fileName : al_OpenUnion) {
			    this.analyzerDbInfo.getAddObjectEntitled(fileName, EnumObject.OBJECT_INTERNAL_FILE);
				this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
		        			                    EnumObject.OBJECT_PGM_COBOL
							                  , this.programName
						                      , EnumObject.OBJECT_INTERNAL_FILE
											  , fileName
											  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
											  , EnumRelation.PGM_INTERNAL_FILE
											  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
											  , this.programName
											  , this.curNumDefProcDiv
											  , instruction.getRowStartSource()
											  , instruction.getRowEndSource()
											  , ""
											  , 0
											  , 0
											  , instruction.getTypeInstrCategory()
											  , this.activeDivisionArea
											  , false
											  , false
											  , false
											  , this.di.userExitInfoPgm
											   );
		}
	
	}

	
	
	/*
     * Analisi statement Close.
     * 
    */
	private void analyzeProcClose(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {
		
		Scanner scn = null;
		ArrayList<String> al_FileClose = null;
		
		String sourceInstr = null;
		String str = "";
		String token = "";
		String fileNameClose = "";
		
		al_FileClose = new ArrayList<String>();
		sourceInstr = instruction.getSourceInstr();
		
		// Elimino CLOSE
		str = sourceInstr.substring(5).trim().toUpperCase() + " ";  
		
		// Elimino parole chiave per Qsam Files non gestite
		str = str.replace(" REEL ", " ");
		str = str.replace(" UNIT ", " ");
		str = str.replace(" FOR ", " ");
		str = str.replace(" REMOVAL ", " ");
		str = str.replace(" NO ", " ");
		str = str.replace(" WITH ", " ");
		str = str.replace(" REWIND ", " ");
		str = str.replace(" LOCK ", " ");
		str = str.replace(",", " ");
		
		
		scn = new Scanner(str.trim());
		token = nextToken(scn);
		
		// Scan tokens
		while (!token.equals("")) {
			
			fileNameClose = token;
			
			al_FileClose.add(fileNameClose);
			
			token = nextToken(scn);
		}
		
 		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
       	instruction.closeSetFiles(al_FileClose);
		
		////////////////////////////////////////////////////////////////////
		// Caricamento nomi files utilizzati input 
		////////////////////////////////////////////////////////////////////
		
		for (String fileNameClosed : al_FileClose) {
			instruction.addSymbolInput(fileNameClosed, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
		}
		
	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

		
		// Scan files aperti dall'istruzione
		for (String fileName : al_FileClose) {
			this.analyzerDbInfo.getAddObjectEntitled(fileName, EnumObject.OBJECT_INTERNAL_FILE);
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
			        			     		EnumObject.OBJECT_PGM_COBOL
								          , this.programName
										  , EnumObject.OBJECT_INTERNAL_FILE
										  , fileName
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_INTERNAL_FILE
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv 
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
		}
		
	}
	
	/*
     * Analisi statement Read.
     * 
    */
	private void analyzeProcRead(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {
		
		EntityObjectOption entityObjectOption = null;
		InstructionCobolDataStruct instrCobolData = null;
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobolDataItem intoDataItem = null;
		InstructionCobol instrGeneric = null;
		DataItemCobolIdentifier intoIdentifier = null;
		ArrayList<DataItemCobolIdentifier> al_Identifier = null;
		ArrayList<DataItemCobolIdentifier> al_identifierInto = null;
		ExceptionAmrita excp = null;
		Scanner scn = null;
        Scanner scnWork = null;
		String sourceInstr = null;
		String str = "";
		String strWork = "";
		String strInto = "";
		String fileNameRead = "";
		String filenameFd = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String keyDataName = "";
		String intoIoareaName = null;
		String ar_FileNameExternal[] = null;
		ar_FileNameExternal = new String[0];							// Vuoto di default
		int pointerIoarea = 0;
		int iInto = 0;
		int iNext = 0;
		int iKey = 0;
		int iEndInto = 0;
        boolean isFileWithBinaryFields = false;

        
        sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(4).trim().toUpperCase(); 		// Elimino READ
		
		// Elimino parole chiave per Qsam Files non gestite
		str = str.replace(" RECORD ", " ");
		str = str.replace(" IS ", " ");

		scn = new Scanner(str);
		
		// Individuo la posizione delle parole chiave ed estraggo il nome del file
		iInto = str.indexOf(" INTO ");
		iNext = str.indexOf(" NEXT ");
		iKey = str.indexOf(" KEY ");
		iEndInto = str.length() - 1;
		if (iKey > 0) {
			iEndInto = iKey;
		}

		fileNameRead = scn.next();
		
		// Estrazione eventuale INTO identifier
		if (iInto > 0) {
			strInto = str.substring(iInto + 6, iEndInto + 1).trim();
			// Estraggo identificatore di input  
			al_identifierInto = extractIdentifiers(instruction, strInto); 
			// Errore di programma o sorgente corrotto
			if (al_identifierInto.size() == 0) {
				instruction.setParsingError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", strInto, excp, new String[]{this.programName});
				return;
			}
			intoIdentifier = al_identifierInto.get(0);
			intoIoareaName = intoIdentifier.getNameIdentifier();
		} // end-if
		
		
		// INTO non specificato: implicitamente si dichiara il primo 01 dopo FD
		if (iInto == -1) {
			// Cerco FD del file interno
			for (int i = 0; i < this.programCobol.entriesData().length; i++) {
				ProgramCobolEntry<? extends Instruction> entryData = this.programCobol.entriesData()[i];
				instrGeneric = (InstructionCobol) entryData.getInstruction();
				
				// FD: verifica se lo stesso file
				if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_FD) {
					
					instrCobolData = (InstructionCobolDataStruct) entryData.getInstruction();
					filenameFd = (String) instrCobolData.getMapDescriptorObject("$FILE$");
					
					// Non è lo stesso file: cerca il prossimo
					if (!fileNameRead.equals(filenameFd)) {
						continue;
					}
					
					// Stesso file: l'istruzione successiva deve essere il livello 01 del record
					// Il campo ioarea potrebbe essere in un copy, anche nested: bypass statements copy
					for (i = i + 1; i <  this.programCobol.entriesData().length; i++) {
						entryData = this.programCobol.entriesData()[i];
						if (!(entryData.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
						instrGeneric = (InstructionCobol) entryData.getInstruction();
						break;
					}
					if (i >= this.programCobol.entriesData().length) {
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
						instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0029", filenameFd, excp, this.programName);
						instruction.setSemanticError(true);
						break;
					}
					
					// Carico il nome della ioarea come se fosse Into
					intoDataItem = (InstructionCobolDataItem) instrGeneric;
					intoIoareaName = intoDataItem.getDataName();
					al_Identifier = extractIdentifiers(instruction, intoIoareaName);
					intoIdentifier = al_Identifier.get(0);
					break;
					
				} // end-if
				
			} // end-for
			
		} // end-if

		
		// Cerco external file name da relazionare in read
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameRead.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		// External file non individuati, Select non presente nel programma, source corrotto
		if (ar_FileNameExternal == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0039", filenameFd, excp, this.programName, filenameFd);
			return;
		}
		

		
		// Estrazione eventuale KEY dataname
		if (iKey > 0) {
			strWork = str.substring(iKey + 5).trim();
			scnWork = new Scanner(strWork);
			keyDataName = scnWork.next();
		}

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
    	if (iNext > 0) {
			instruction.addOption("NEXT");
		}
    	instruction.readSetFileNameInternal(fileNameRead);
    	instruction.readSetFileNamesExternal(ar_FileNameExternal);
       	instruction.readSetIoareaInto(intoIdentifier);
    	
     	
    	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e  output
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(fileNameRead, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	if (!keyDataName.equals("")) {
			instruction.addSymbolInput(keyDataName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	// Impostazione di tutti i sottocampi eventuali come symboli di output
		instruction.addSymbolOutput(intoIoareaName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	  	addInstructionSymbolsUsedAndDefinedGroup(instruction, intoIdentifier, INSTR_USE_DATA_ITEM_OUTPUT);
	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
        
	    // Inserimento opzione di programma con files con dati binari
	  	pointerIoarea = intoIdentifier.getNumInstr();
	    if (this.programCobol.isDataItemGroupWithBynaryFields(pointerIoarea)) {
	    	isFileWithBinaryFields = true;
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_BINARY_FIELDS_FILES);
			analyzerDbInfo.addObjEntityOption(entityObjectOption);
		}

	  	
	  	// Internal file già inserito anche nella Select di programma
	    this.analyzerDbInfo.getAddObjectEntitled(fileNameRead, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameRead
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		// Relazione fra programma ed internal file in read
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  ,	EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameRead
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE_READ
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );


		// Relazioni fra programma ed external files in read
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
    	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
    									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
    									   );

    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE_READ
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
        	
    	    if (isFileWithBinaryFields) {
    	   		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
						EnumObject.OBJECT_PGM_COBOL
					  , this.programName
					  ,	EnumObject.OBJECT_EXTERNAL_FILE
					  , fileNameExternal
					  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
					  , EnumRelation.PGM_EXTERNAL_FILE_BYNARY_FIELDS
					  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
					  , this.programName
					  , this.curNumDefProcDiv
					  , instruction.getRowStartSource()
					  , instruction.getRowEndSource()
					  , ""
					  , 0
					  , 0
					  , instruction.getTypeInstrCategory()
					  , this.activeDivisionArea
					  , false
					  , false
					  , false
					  , this.di.userExitInfoPgm
					   );
     		}
        }
	
	
	}
		
	/*
     * Analisi statement Delete.
     * 
    */
	private void analyzeProcDelete(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		ExceptionAmrita excp = null;
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		Scanner scn = null;
		String sourceInstr = null;
		String str = "";
		String fileNameDelete = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String keyDataName = "";
		String ar_FileNameExternal[] = null;
		
		ar_FileNameExternal = new String[0];							// Vuoto di default
      
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(7).trim().toUpperCase(); 			// Elimino DELETE
		
		scn = new Scanner(str);
		
		fileNameDelete = scn.next();
		
 		
		// Cerco external file name da relazionare in read
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameDelete.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		// External file non individuati, Select non presente nel programma, source corrotto
		if (ar_FileNameExternal == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0039", fileNameDelete, excp, this.programName, fileNameDelete);
			return;
		}

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
       	instruction.rewriteSetFileNameInternal(fileNameDelete);
    	instruction.rewriteSetFilesNameExternal(ar_FileNameExternal);
    	    	
    	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e  output
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(fileNameDelete, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	if (!keyDataName.equals("")) {
			instruction.addSymbolInput(keyDataName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
        
	  	// Internal file già inserito anche nella Select di programma
   	    this.analyzerDbInfo.getAddObjectEntitled(fileNameDelete, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameDelete
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		// Relazione fra programma ed internal file in delete
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  ,	EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameDelete
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE_DELETE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );


		// Relazioni fra programma ed external files in read
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
       	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);

    	  	// Internal file già inserito anche nella Select di programma
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
    									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
    									   );

    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE_DELETE
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
		}
	
	}

	/*
     * Analisi statement Rewrite.
     * 
    */
	private void analyzeProcRewrite(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		Scanner scn = null;
		EntityObjectOption entityObjectOption = null;
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		DataItemCobolIdentifier fromIdentifier = null;
		InstructionCobolDataItem fromDataItem = null;
		ArrayList<DataItemCobolIdentifier> al_identifierFrom = null;
		ExceptionAmrita excp = null;
		String sourceInstr = null;
		String str = "";
		String strFrom = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String fileNameRewrite = "";
		String fromIoareaName = "";
		String recordNameRewrite = "";
		String ar_FileNameExternal[] = null;
		boolean ioSequential = false;
		boolean ioVsam = false;
		boolean isFileWithBinaryFields = false;
		int ar_pointersFromIoarea[] = null;
		int iFrom = 0;
		int pointerIoarea = 0;
		

		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(7).trim().toUpperCase(); 		// Elimino REWRITE
		scn = new Scanner(str);
		
		// Individuo la posizione delle parole chiave ed estraggo il nome del file
		iFrom = str.indexOf(" FROM ");

		recordNameRewrite = scn.next();
		
		fileNameRewrite = fileNameFromRecordName(instruction, recordNameRewrite);
		if (instruction.isSemanticError()) {
			return;
		}
		
		// Estrazione eventuale FROM identifier
		if (iFrom > 0) {
			strFrom = str.substring(iFrom + 6).trim();
			// Estraggo identificatore di input  
			al_identifierFrom = extractIdentifiers(instruction, strFrom); 
			// Errore di programma o sorgente corrotto
			if (al_identifierFrom.size() == 0) {
				instruction.setSemanticError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", strFrom, excp, new String[]{this.programName});
				return;
			}
			fromIdentifier = al_identifierFrom.get(0);
		} // end-if


		// FROM non specificato: si considera come ioarea il record name specificato
		if (iFrom == -1) {
			ar_pointersFromIoarea = this.programCobol.dataItemPointers(recordNameRewrite);
			// Errore di programma o sorgente corrotto
			if (ar_pointersFromIoarea == null) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", recordNameRewrite, excp, this.programName, recordNameRewrite);
				instruction.setSemanticError(true);
				return;
			}
			fromIdentifier = new DataItemCobolIdentifier();
			fromDataItem = this.programCobol.dataItemDefinition(ar_pointersFromIoarea[0]);
			fromIdentifier.setDataItem(fromDataItem);
			fromIdentifier.setNameIdentifier(fromDataItem.getDataName());
			fromIdentifier.setIdentifierType(EnumCobolReservedWords.DATA_DIV_DATA_ITEM);
			fromIdentifier.setNumInstr(fromDataItem.getNumInstr());
		} // end-if

		
		// Cerco external file name da relazionare in write
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameRewrite.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		// External file non individuati, Select non presente nel programma, source corrotto
		if (ar_FileNameExternal == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0040", recordNameRewrite, excp, this.programName, recordNameRewrite);
			return;
		}
		

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
      	instruction.rewriteSetFileNameInternal(fileNameRewrite);
    	instruction.rewriteSetFilesNameExternal(ar_FileNameExternal);
       	instruction.rewriteSetIoareFrom(fromIdentifier);
	   	
	   	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(recordNameRewrite, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	  	// Impostazione di tutti i sottocampi eventuali come symboli di input
	  	if (iFrom > 0) { 
	  		instruction.addSymbolInput(fromIoareaName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		  	addInstructionSymbolsUsedAndDefinedGroup(instruction, fromIdentifier, INSTR_USE_DATA_ITEM_INPUT);
		}
	  	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

		// Inserimento opzione di programma con files con dati binari
	  	pointerIoarea = fromIdentifier.getNumInstr();
	    if (this.programCobol.isDataItemGroupWithBynaryFields(pointerIoarea)) {
	    	isFileWithBinaryFields = true;
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_BINARY_FIELDS_FILES);
			analyzerDbInfo.addObjEntityOption(entityObjectOption);
		}

        // Relazioni fra programma ed internal file in update
  	    this.analyzerDbInfo.getAddObjectEntitled(fileNameRewrite, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
     								  , this.programName
				                      , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameRewrite
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , ioSequential
									  , ioVsam
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
				  					  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameRewrite
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE_UPDATE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );



		// Relazioni fra programma ed external files in insert
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
      	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
  									      , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
    									   );

    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE_UPDATE
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
        	
    	    if (isFileWithBinaryFields) {
    	   		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
						EnumObject.OBJECT_PGM_COBOL
					  , this.programName
					  ,	EnumObject.OBJECT_EXTERNAL_FILE
					  , fileNameExternal
					  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
					  , EnumRelation.PGM_EXTERNAL_FILE_BYNARY_FIELDS
					  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
					  , this.programName
					  , this.curNumDefProcDiv
					  , instruction.getRowStartSource()
					  , instruction.getRowEndSource()
					  , ""
					  , 0
					  , 0
					  , instruction.getTypeInstrCategory()
					  , this.activeDivisionArea
					  , false
					  , false
					  , false
					  , this.di.userExitInfoPgm
					   );
     		}
		}
	
	}

	/*
     * Analisi statement Write.
     * 
    */
	private void analyzeProcWrite(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		EntityObjectOption entityObjectOption = null;
		Scanner scn = null;
		Scanner scnWork = null;
		InstructionCobolDataItem fromDataItem = null;
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		DataItemCobolIdentifier fromIdentifier = null;
		ArrayList<DataItemCobolIdentifier> al_identifierFrom = null;
		ExceptionAmrita excp = null;
		String sourceInstr = null;
		String str = "";
		String strWork = "";
		String strFrom = "";
		String token = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String fileNameWrite = "";
		String recordNameWrite = "";
		String ar_FileNameExternal[] = null;
		String valAdvancingLines = "";
		boolean ioSequential = false;
		boolean ioVsam = false;
		boolean advancingPage = false;
		boolean advancingLines = false;
		boolean isFileWithBinaryFields = false;
		int ar_pointersFromIoarea[] = null;
		int pointerIoarea = 0;
		int iFrom = 0;
		int iAfter = 0;
		int iBefore = 0;
		int iAdvancing = 0;
		int iEndFrom = 0;


		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(6).trim().toUpperCase(); 		// Elimino WRITE
		scn = new Scanner(str);
		
		// Individuo la posizione delle parole chiave ed estraggo il nome del programma
		iFrom = str.indexOf(" FROM ");
		iBefore =  str.indexOf(" BEFORE ");
		iAfter =  str.indexOf(" AFTER ");
		iAdvancing =  str.indexOf(" ADVANCING ");
		iEndFrom = str.length() - 1;
		if (iBefore > 0) {
			iEndFrom = iBefore;
		}
		if (iAfter > 0) {
			iEndFrom = iAfter;
		}
		
		recordNameWrite = scn.next();
		
		fileNameWrite = fileNameFromRecordName(instruction, recordNameWrite);
		if (instruction.isSemanticError()) {
			return;
		}
		
		// Estrazione ADVANCING identifier
		if (iAdvancing > 0) {
			advancingLines = true;
			ioSequential = true;
			strWork = str.substring(iAdvancing + 11).trim();
			scnWork = new Scanner(strWork);
			token = scnWork.next();
			valAdvancingLines = token;
		}
		
		// Estrazione eventuale FROM identifier
		if (iFrom > 0) {
			strFrom = str.substring(iFrom + 6, iEndFrom + 1).trim();
			// Estraggo identificatore di input  
			al_identifierFrom = extractIdentifiers(instruction, strFrom); 
			// Errore di programma o sorgente corrotto
			if (al_identifierFrom.size() == 0) {
				instruction.setParsingError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", strFrom, excp, new String[]{this.programName});
				return;
			}
			fromIdentifier = al_identifierFrom.get(0);
		} // end-if

		// FROM non specificato: si considera come ioarea il record name specificato
		if (iFrom == -1) {
			ar_pointersFromIoarea = this.programCobol.dataItemPointers(recordNameWrite);
			// Errore di programma o sorgente corrotto
			if (ar_pointersFromIoarea == null) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", recordNameWrite, excp, this.programName, recordNameWrite);
				instruction.setSemanticError(true);
				return;
			}
			fromIdentifier = new DataItemCobolIdentifier();
			fromDataItem = this.programCobol.dataItemDefinition(ar_pointersFromIoarea[0]);
			fromIdentifier.setDataItem(fromDataItem);
			fromIdentifier.setNameIdentifier(fromDataItem.getDataName());
			fromIdentifier.setIdentifierType(EnumCobolReservedWords.DATA_DIV_DATA_ITEM);
			fromIdentifier.setNumInstr(fromDataItem.getNumInstr());
		} // end-if

		
		// Cerco external file name da relazionare in write
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameWrite.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		// External file non individuati, Select non presente nel programma, source corrotto
		if (ar_FileNameExternal == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0039", recordNameWrite, excp, this.programName, recordNameWrite);
			return;
		}
		

		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
	   	if (iBefore > 0) {
	   		instruction.addOption("BEFORE-ADVANCING");
		}
	   	if (iAfter > 0) {
	   		instruction.addOption("AFTER-ADVANCING");
		}
	   	if (advancingPage) {
	   		instruction.addOption("PAGE");
		}
      	instruction.writeSetFileNameInternal(fileNameWrite);
    	instruction.writeSetFilesNameExternal(ar_FileNameExternal);
       	instruction.writeSetIoareaFrom(fromIdentifier);
	   	
	   	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(recordNameWrite, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	  	if (iFrom > 0) { 
	  		// Ioarea from, può essere indexata
	  		addInstructionSymbolsUsedAndDefined(instruction, fromIdentifier, COBOL_DATA_ITEM_USED_INPUT);
	  		
		  	// Impostazione di tutti i sottocampi eventuali come symboli di input
		  	addInstructionSymbolsUsedAndDefinedGroup(instruction, fromIdentifier, INSTR_USE_DATA_ITEM_INPUT);
		}
	  	
        if (advancingLines) {
			if (StringService._isNumeric(valAdvancingLines)) {
				instruction.addSymbolInput(valAdvancingLines, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
				instruction.addSymbolDefinedInside(valAdvancingLines, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
			} else {
				instruction.addSymbolInput(valAdvancingLines, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			}
		}
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

		// Inserimento opzione di programma con files con dati binari
	  	pointerIoarea = fromIdentifier.getNumInstr();
	    if (this.programCobol.isDataItemGroupWithBynaryFields(pointerIoarea)) {
	    	isFileWithBinaryFields = true;
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_BINARY_FIELDS_FILES);
			analyzerDbInfo.addObjEntityOption(entityObjectOption);
		}

        // Relazioni fra programma ed internaò file in insert
 	    this.analyzerDbInfo.getAddObjectEntitled(fileNameWrite, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
     								  , this.programName
				                      , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameWrite
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , ioSequential
									  , ioVsam
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
				  					  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameWrite
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE_INSERT
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );



		// Relazioni fra programma ed external files in insert
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
     	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
     		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
    									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
    									   );

    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE_INSERT
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
        	
    	    if (isFileWithBinaryFields) {
    	   		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
						EnumObject.OBJECT_PGM_COBOL
					  , this.programName
					  ,	EnumObject.OBJECT_EXTERNAL_FILE
					  , fileNameExternal
					  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
					  , EnumRelation.PGM_EXTERNAL_FILE_BYNARY_FIELDS
					  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
					  , this.programName
					  , this.curNumDefProcDiv
					  , instruction.getRowStartSource()
					  , instruction.getRowEndSource()
					  , ""
					  , 0
					  , 0
					  , instruction.getTypeInstrCategory()
					  , this.activeDivisionArea
					  , false
					  , false
					  , false
					  , this.di.userExitInfoPgm
					   );
     		}
		}
	
	}

	/*
     * Analisi statement Start.
     * 
    */
	private void analyzeProcStart(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		InstructionCobol instrGeneric = null;
		InstructionCobolEnvironment instrEnvDivision = null;
		InstructionCobolDataItem keyDataItem = null;
		EnumExpressionItem en_condition = null;
		ExceptionAmrita excp = null;
		Scanner scn = null;
        String token = "";
		String sourceInstr = null;
		String str = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String fileNameStart = "";
		String ar_FileNameExternal[] = null;
		String keyDataName = "";
		int ar_pointerskeyDataName[] = null;

		en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_GREATER_EQUAL;
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(5).trim().toUpperCase(); 		// Elimino START
		scn = new Scanner(str);
		
		fileNameStart = scn.next();
		
		token = nextToken(scn);
		if (token.equals("KEY")) {
			token = nextToken(scn);
            if (token.equals("IS")) {
            	token = nextToken(scn);
			}
            // Inizio condizione Equal / =
			if (token.equals("EQUAL") || token.equals("=")) {
				en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_EQUAL;
			    token = nextToken(scn);
	            if (token.equals("TO")) {
	               token = nextToken(scn);
				}
				
			// Inizio condizione Greater / >
			} else if (token.equals("GREATER") || token.equals(">")) {
				en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_GREATER;
			    token = nextToken(scn);
	            if (token.equals("THEN")) {
	               token = nextToken(scn);
				}
				if (token.equals("OR")) {
					token = nextToken(scn);    // EQUAL
					token = nextToken(scn);
		            if (token.equals("TO")) {
			            token = nextToken(scn);
			            en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_GREATER_EQUAL;
					}
				}

			// Inizio condizione >=
			} else if (token.equals(">=")) {
				en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_GREATER_EQUAL;
			    token = nextToken(scn);

			// Inizio condizione Not <
			} else if (token.equals("NOT")) {
				en_condition = EnumExpressionItem.COBOL_OPRT_COMPARE_NOT_LESS;
				token = nextToken(scn);  // LESS o <
				token = nextToken(scn);  // THEN o data item
	            if (token.equals("THEN")) {
		            token = nextToken(scn);
				}
			}
			keyDataName = token;
		}

		// recupero istruzine di definizione key
		ar_pointerskeyDataName = this.programCobol.dataItemPointers(keyDataName);
		// Errore di programma o sorgente corrotto
		if (ar_pointerskeyDataName == null) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", keyDataName, excp, this.programName, keyDataName);
			instruction.setSemanticError(true);
			return;
		}
		keyDataItem = this.programCobol.dataItemDefinition(ar_pointerskeyDataName[0]);

		
		// Cerco external file name da relazionare in write
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameStart.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for


		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
    	if (!keyDataName.equals("")) {
			instruction.startSetCondition(en_condition);
			instruction.startSetKey(keyDataItem);
		}
       	instruction.startSetFileNameInternal(fileNameInternal);
    	instruction.startSetFilesNameExternal(ar_FileNameExternal);

    	
    	
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(fileNameStart, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	if (!keyDataName.equals("")) {
			instruction.addSymbolInput(keyDataName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

	    this.analyzerDbInfo.getAddObjectEntitled(fileNameStart, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     			                        EnumObject.OBJECT_PGM_COBOL
     								  , this.programName
				                      , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameStart
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
				                      , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameStart
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE_READ
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , true
									  , false
									  , this.di.userExitInfoPgm
									   );



		// Relazioni fra programma ed external files in insert
	    for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
	    	fileNameExternal = ar_FileNameExternal[i];
	    	
		  	// Internal file già inserito anche nella Select di programma
		    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
	     									EnumObject.OBJECT_PGM_COBOL
					  					  , this.programName
										  , EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
	
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , EnumRelation.PGM_EXTERNAL_FILE_INSERT
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
	    	
			}
	}
	
	
	/*
     * Analisi statement Evaluate.
     * 
    */
	private void analyzeProcEvaluate(InnerContextAnalysis ictx, InstructionCobolProcedure instruction) throws ExceptionAmrita {

        ArrayList<ExpressionCobol> al_expression = null;
        ExpressionCobol expression = null;
		String sourceInstr = instruction.getSourceInstr();
		String str = "";
		String strExpression = "";
		int iStart = 0;
		int iEnd = 0;
		
		// End-evaluate: aggiornamento tipo nodo
		if (ictx.activeTypeInstr == EnumCobolReservedWords.PROC_END_EVALUATE) {
			return;
		}
		
		// Elimino Evaluate
		str = sourceInstr.substring(8).trim();
		al_expression = new ArrayList<ExpressionCobol> ();
		
		// Le singole espressioni, anche separate da ALSO, vengono memorizzate
		// come oggetti ExpressionCobol, anche se contengono solo TRUE, FALSE, literal o un campo
		// per gestire il massimo della generalità
		
		// Setting ahead
		iStart = 0;
		iEnd = str.indexOf(" ALSO ");
		if (iEnd < 0) {
			iEnd = str.length() - 1;
			strExpression = str.substring(iStart, iEnd + 1).trim();
			iStart = -1;
		} else {
			strExpression = str.substring(iStart, iEnd).trim();
			iStart = iEnd + 6;
		}
		
		
		// Condizioni Evaluate  
		while (!strExpression.equals("")) {
			
			// Estrazione condizione di evaluate  
			expression = extractExpression(instruction, strExpression);
            if (instruction.isParsingError() || instruction.isSemanticError() ) {
				return;
			}
            al_expression.add(expression);
            
    		// Fine condizioni
    		if (iStart < 0) {
				break;
			}

            // Setting in loop per nuova condizione ALSO
    		iEnd = str.indexOf(" ALSO ", iStart);
    		if (iEnd < 0) {
    			iEnd = str.length() - 1;
    			strExpression = str.substring(iStart, iEnd + 1).trim();
    			iStart = -1;
    		} else {
    			strExpression = str.substring(iStart, iEnd).trim();
    			iStart = iEnd + 6;
    		}
		}

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////

		for (ExpressionCobol expr : al_expression) {
			addInstructionSymbolsExpressionInput(instruction, expr);
		}
		instruction.evaluateSetExpressions(al_expression);

	}


	/*
     * Analisi statement Search.
     * 
    */
	private void analyzeProcSearch(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		ArrayList<DataItemCobolIdentifier> al_identifier = null;
		DataItemCobolIdentifier tbNameIdentifier = null;
		DataItemCobolIdentifier varyingIdentifier = null;
		String sourceInstr = instruction.getSourceInstr();
		String tbName = "";
		String varying = "";
		String str = "";
		boolean isSeasrchAll = false;
		int iVarying = 0;

		// Elimino Search
		str = sourceInstr.substring(6).trim();
		
		// Searcj All
		if (str.startsWith("ALL")) {
			isSeasrchAll = true;
			tbName = str.substring(3).trim();
		}
        
		// Search normale o Varying
		if (!str.startsWith("ALL")) {
			isSeasrchAll = false;
			iVarying = str.indexOf(" VARYING ");
			if (iVarying < 0) {
			   tbName = str.trim();
			} else {
				tbName = str.substring(0, iVarying).trim();
				varying = str.substring(iVarying + 9).trim();
			}
		}

		// Estraggo identificatore nome tabella
		al_identifier = extractIdentifiers(instruction, tbName);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		tbNameIdentifier = al_identifier.get(0);
		
		// Estraggo identificatore indice varying
		if (!varying.equals("")) {
			al_identifier = extractIdentifiers(instruction, varying);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				return;
			}
			varyingIdentifier = al_identifier.get(0);
		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////

		if (isSeasrchAll) {
			instruction.addMapDescriptorObject("OPT$"+"ALL", "");
		}
		
		addInstructionSymbolsUsedAndDefined(instruction, tbNameIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		if (!varying.equals("")) {
			addInstructionSymbolsUsedAndDefined(instruction, varyingIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
		}

	}

	
	

	/*
     * Analisi statement Search/Evaluate When.
     * 
     * La gestione è unificata per When di evaluate e When di search
     * 
    */
	private void analyzeProcWhenEvaluateSearch(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
        ArrayList<ExpressionCobol> al_expression = null;
        ExpressionCobol expression = null;
		String sourceInstr = instruction.getSourceInstr();
		String str = "";
		String strExpression = "";
		int iStart = 0;
		int iEnd = 0;
		
		// Elimino When
		str = sourceInstr.substring(4).trim();
		
		// Evaluate When Other
		if (str.equals("OTHER")) {
			instruction.whenSetOther();
			instruction.whenSetConditions(new ArrayList<ExpressionCobol>());
			return;
		}
		
		
		al_expression = new ArrayList<ExpressionCobol> ();
		
		// Le singole espressioni, anche separate da ALSO, vengono memorizzate
		// come oggetti ExpressionCobol, anche se contengono solo TRUE, FALSE, literal o un campo
		// per gestire il massimo della generalità
		
		// Setting ahead
		iStart = 0;
		iEnd = str.indexOf(" ALSO ");
		if (iEnd < 0) {
			iEnd = str.length() - 1;
			strExpression = str.substring(iStart, iEnd + 1).trim();
			iStart = -1;
		} else {
			strExpression = str.substring(iStart, iEnd).trim();
			iStart = iEnd + 6;
		}
		   
		
		// Condizioni Evaluate  
		while (!strExpression.equals("")) {
			   
			// Estrazione condizione di evaluate o di search
			expression = extractExpression(instruction, strExpression);
            if (instruction.isParsingError() || instruction.isSemanticError() ) {
				return;
			}
            al_expression.add(expression);
            
    		// Fine condizioni
    		if (iStart < 0) {
				break;
			}

            // Setting in loop per nuova condizione ALSO
    		iEnd = str.indexOf(" ALSO ", iStart);
    		if (iEnd < 0) {
    			iEnd = str.length() - 1;
    			strExpression = str.substring(iStart, iEnd + 1).trim();
    			iStart = -1;
    		} else {
    			strExpression = str.substring(iStart, iEnd).trim();
    			iStart = iEnd + 6;
    		}
		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////

		for (ExpressionCobol expr : al_expression) {
			addInstructionSymbolsExpressionInput(instruction, expr);
		}
		instruction.whenSetConditions(al_expression);
		
	}


	/*
     * Analisi statement Set.
     * 
    */
	private void analyzeProcSet(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		ExceptionAmrita excp = null;
		Scanner scn = null;
		StringBuffer sbStrSet = null;
		ArrayList<String> al_strSet = null;
		ArrayList<DataItemCobolIdentifier> al_identifierBeforeToUpDown = null;
		ArrayList<DataItemCobolIdentifier> al_identifierAfterToUpDown = null;
		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		ArrayList<DataItemCobolIdentifier> al_identifierOutput = null;
		int[] al_pointerDef = null;
        String token = "";
		String str = "";
		String strBeforeToUpDown = "";
		String strAfterToUpDown = "";
		boolean isTypeSetAppended = false;
		// Posizione parole chiave
		int iTo = 0;
		int iUpBy = 0;
		int iDownBy = 0;
		int iEndLeftSide = 0;
		int iStartRightSide = 0;
		

		String sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(3).trim().toUpperCase();		// Elimino Set 
		str = replaceSpaceInLiteralWithUnderscore(instruction, str);
		scn = new Scanner(str);
		al_strSet = new ArrayList<String> ();	
 
		
		///////////////////////////////////////////////////////
		// Estrazione singole assegnazioni presenti
		///////////////////////////////////////////////////////
		
		// Ciclo generale
		token = nextToken(scn);
		while (!token.equals("")) {
			sbStrSet = new StringBuffer ();
			isTypeSetAppended = false;
			
			while (!token.equals("")) {
				sbStrSet.append(" " + token);

				// Flag di servizio
				if (token.equals("TO")) {
					isTypeSetAppended = true;
					token = nextToken(scn);
					continue;
				}
				if (token.equals("UP")
				||  token.equals("DOWN")) {
					isTypeSetAppended = true;
					token = nextToken(scn);			// BY
					sbStrSet.append(" " + token);
					token = nextToken(scn);
					continue;
				}
	
				// Ancora nessun controllo
				if (!isTypeSetAppended) {
					token = nextToken(scn);
					continue;
				}
				
			    // SET a valore singolo
				if (token.equals("ON") 
				||  token.equals("OFF") 
				||  token.equals("TRUE") 
				||  token.equals("FALSE") 
				||  token.equals("NULL")
				||  token.equals("NULLS")
				||  token.equals("SELF")
				||  token.equals("ENTRY")) {
					break;
				}
				
			    // SET a LENGTH OF o ADDRESS OF
				if (token.equals("LENGTH") || token.equals("ADDRESS") ) {
					token = nextToken(scn);					// OF
					sbStrSet.append(" " + token);
					token = nextToken(scn);					// identifier
					sbStrSet.append(" " + token);
					break;
				}
				
				// SET a literal
				if (StringService._isLiteral(token)) {
					break;
				}
				
				// SET a numeric
				if (StringService._isNumericInt(token)) {
					break;
				}
				
				// Può essere solo un identificatore
				al_pointerDef = this.programCobol.getXrefSymbolDefData(token);
				if (al_pointerDef == null) {
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
					instruction.setParsingError(true);
					return;
				}
				// TODO Gestione indexing eventuale
				break;
			}
			
			// Stringa completa di SET estratta
			al_strSet.add(sbStrSet.toString().trim());
			token = nextToken(scn);
		}
		
		
		//////////////////////////////////////////////////////////////
		// Analisi singole SET
		//////////////////////////////////////////////////////////////
		
		for (String strSet : al_strSet) {
			

			// Individuo pointers a parole chiave
			iTo = strSet.indexOf(" TO ");
			iUpBy = strSet.indexOf(" UP ");
			iDownBy = strSet.indexOf(" DOWN ");
			
			  
			// Individuo pointer di fine campi risultato dopo To
			if (iTo > 0) {
				iEndLeftSide = iTo;
				iStartRightSide = iTo + 4;
			} else if (iUpBy > 0) {
				iEndLeftSide = iUpBy;
				iStartRightSide = strSet.indexOf(" BY ", iUpBy + 3) + 3;
			} else {
				iEndLeftSide = iDownBy;
				iStartRightSide = strSet.indexOf(" BY ", iDownBy + 5) + 3;
			}
		
			// Estrazione stringhe con identificatori a sinistra (output) e a destra (input)
			strBeforeToUpDown = strSet.substring(0, iEndLeftSide).trim();
			strAfterToUpDown = strSet.substring(iStartRightSide).trim();
			
			// Estraggo identificatori di output
			al_identifierBeforeToUpDown = extractIdentifiers(instruction, strBeforeToUpDown);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				return;
			}
			  
			// Estraggo identificatori di input
	    	al_identifierAfterToUpDown = extractIdentifiers(instruction, strAfterToUpDown);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				return;
			}  
	 
			al_identifierInput = new ArrayList<DataItemCobolIdentifier> ();
			al_identifierOutput = new ArrayList<DataItemCobolIdentifier> ();

			  
			////////////////////////////////////////////////////////////////////
			// Caricamento Descriptor istruzione con opzioni e strutture dati
			////////////////////////////////////////////////////////////////////
			
			if (iUpBy > 0) {
				instruction.setSetToUpBy();
				instruction.setSetItemInput(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierInput.add(al_identifierAfterToUpDown.get(0));
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (iDownBy > 0) {
				instruction.setSetToDownBy();
				instruction.setSetItemInput(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierInput.add(al_identifierAfterToUpDown.get(0));
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (strAfterToUpDown.equals("ON")) {
				instruction.setSetToOn();
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (strAfterToUpDown.equals("OFF")) {
				instruction.setSetToOff();
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (strAfterToUpDown.equals("TRUE")) {
				instruction.setSetToTrue();
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (strAfterToUpDown.equals("NULL") || strAfterToUpDown.equals("NULLS")) {
				instruction.setSetToNull();
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else if (strBeforeToUpDown.indexOf("ADDRESS ") >= 0) {
				instruction.setSetAddressOfToPointer();
				instruction.setSetAreaAddressed(al_identifierBeforeToUpDown.get(0));
				instruction.setSetPointer(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemInput(al_identifierBeforeToUpDown.get(0));
				al_identifierInput.add(al_identifierAfterToUpDown.get(0));
				al_identifierInput.add(al_identifierBeforeToUpDown.get(0));
			} else if (strAfterToUpDown.indexOf("ADDRESS ") >= 0) {
				instruction.setSetPointerToAddressOf();
				instruction.setSetAreaAddressed(al_identifierAfterToUpDown.get(0));
				instruction.setSetPointer(al_identifierBeforeToUpDown.get(0));
				instruction.setSetItemInput(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierInput.add(al_identifierAfterToUpDown.get(0));
				al_identifierOutput.add(al_identifierBeforeToUpDown.get(0));
			} else if (al_identifierAfterToUpDown.get(al_identifierAfterToUpDown.size() - 1).getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_NUM) {
				instruction.setSetToValue();
				instruction.setSetItemInput(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			} else {
				instruction.setSetFieldToField();
				instruction.setSetItemInput(al_identifierAfterToUpDown.get(0));
				instruction.setSetItemsOutput(al_identifierBeforeToUpDown);
				al_identifierInput.add(al_identifierAfterToUpDown.get(0));
				al_identifierOutput.addAll(al_identifierBeforeToUpDown);
			}

			
			////////////////////////////////////////////////////////////////////
			// Caricamento campi definiti e utilizzati in input e output
			////////////////////////////////////////////////////////////////////
			
			// Identificatore di input
			for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
			}
			// Identificatore di output
			for (DataItemCobolIdentifier innerIdentifier : al_identifierOutput) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
			}
		
		}
		
		
		
		
		
		
	}

	/*
     * Analisi statement Initialize.
     * 
     * L'istruzione non viene codificata.
     * Vengono solo indicizzati i reference ai campi utilizzati in input e in output.
     * 
    */
	private void analyzeProcInitialize(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		ArrayList<DataItemCobolIdentifier> al_identifierOutput = null;
		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		InstructionCobolDataItem dataItem = null;
		
		// Stringhe con estratte da istruzione
		String sourceInstr = "";
		String str = "";
		String strIdentifierOutput = "";
		String strIdentifierInput = "";
		int iReplacing = 0;							// Posizione parole chiave
		int dataNameGroupPointer = 0;				// Pointer a definizione campo di gruppo
		int ar_pointerDefElementary[] = null;       // Pointers ale definizioni dei campòi elementari del gruppo
		int numInstrDef = 0;                        // Numero istruzione di definizione dati
		// Elimino Initialize  
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(10).trim().toUpperCase();
		
		// Eliminazione words 
		str = str.replace(" WITH ", " ");
		str = str.replace(" FILLER ", " ");
		str = str.replace(" ALL ", " ");
		str = str.replace(" TO ", " ");
		str = str.replace(" VALUE ", " ");
		str = str.replace(" THEN ", " ");
		str = str.replace(" DEFAULT", " ");
		str = str.replace(" DATA ", " ");
		str = str.replace(" BY ", " ");
		str = str.replace(" ALPHABETIC ", " ");
		str = str.replace(" ALPHANUMERIC ", " ");
		str = str.replace(" NUMERIC ", " ");
		str = str.replace(" ALPHANUMERIC-EDITED ", " ");
		str = str.replace(" NUMERIC-EDITED ", " ");
		str = str.replace(" DBCS ", " ");
		str = str.replace(" EGCS ", " ").trim();
		
		// Individuo pointers a parole chiave
		iReplacing = str.indexOf(" REPLACING ");
		
		// Estrazione identificatori di input e output
		if (iReplacing > 0) {
			strIdentifierOutput = str.substring(0, iReplacing).trim();
			strIdentifierInput = str.substring(iReplacing + 11).trim();
			al_identifierOutput = extractIdentifiers(instruction, strIdentifierOutput);
			al_identifierInput = extractIdentifiers(instruction, strIdentifierInput);
		} else {
			strIdentifierOutput = str.substring(0).trim();
			al_identifierInput = new ArrayList<DataItemCobolIdentifier> ();     // vuoto
			al_identifierOutput = extractIdentifiers(instruction, strIdentifierOutput);
		}
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////

		if (iReplacing > 0) {
			instruction.addMapDescriptorObject("$OP$"+"REPL", "");
		}
		
		
		// Identificatore di input (if any)
		for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}

		// Identificatore di output
		for (DataItemCobolIdentifier innerIdentifier : al_identifierOutput) {
			
			// Identificatore di precompilatore non definito nel programma
			if (innerIdentifier.getIdentifierType() == EnumCobolReservedWords.PRECOMPILER_CICS
			||  innerIdentifier.getIdentifierType() == EnumCobolReservedWords.PRECOMPILER_SQL	
			||  innerIdentifier.getIdentifierType() == EnumCobolReservedWords.PRECOMPILER_DL1) {
				continue;
			}

			// Replacing: non gestita l'indicizzazione in output pilotasta daltipo di dato
			if (iReplacing > 0) {
				continue;
			}
			
			// Campo elementare senza vincoli: sicuramente in output
			if (!innerIdentifier.getDataItem().isGroupField() && iReplacing < 0) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
				continue;
			}
			
			dataNameGroupPointer = innerIdentifier.getDataItem().getNumInstr();
			
			// Campo di gruppo: xref in output per tutti i campi elementari
			ar_pointerDefElementary = this.programCobol.dataItemsUnderGroupPointers(dataNameGroupPointer, DATA_ITEMS_ELEMENTARY_FIELDS);
			
			// Scan campi elementari del campo di gruppo
			for (int i = 0; i < ar_pointerDefElementary.length; i++) {
				
				numInstrDef = ar_pointerDefElementary[i];
				dataItem = this.programCobol.dataItemDefinition(numInstrDef);
				
				instruction.addSymbolOutput(dataItem.getDataName(), EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			}
		}
		
		
	}


	/*
     * Analisi statement Display.
     * 
    */
	private void analyzeProcDisplay(InstructionCobolProcedure instruction) throws ExceptionAmrita {

		ArrayList<DataItemCobolIdentifier> al_identifier = null;
		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		DataItemCobolIdentifier identifierToBeCloned = null;
		DataItemCobolIdentifier identifierUpon = null;
		
		String sourceInstr = instruction.getSourceInstr();
  
		// Stringhe con estratte da istruzione
		String str = "";
		String strIdentifierInput = "";
		String systemMnemonicEnvironmentName = "";
		
		// Posizione parole chiave
		int iUpon = 0;
		
		// Elimino Display  
		str = sourceInstr.substring(7).trim().toUpperCase();
		
		// Elimino key words non trattate
		str = str.replace(" WITH ", "");
		str = str.replace(" NO ", "");
		str = str.replace(" ADVANCING ", "");
		
		// Individuo eventuale UPON
		iUpon = str.indexOf(" UPON ");
		
		// Estrazione identificatori di cui fare display
		if (iUpon > 0) {
			strIdentifierInput = str.substring(0, iUpon).trim();
			systemMnemonicEnvironmentName = str.substring(iUpon + 6).trim();
			al_identifierInput = extractIdentifiers(instruction, strIdentifierInput);
		} else {
			strIdentifierInput = str.substring(0).trim();
			al_identifierInput = extractIdentifiers(instruction, strIdentifierInput);
		}
		if (instruction.isParsingError() || instruction.isSemanticError()) { 
			return;
		}
		
		
		// Estrazione identificatore Upon
		if (!systemMnemonicEnvironmentName.equals("")) {
			al_identifier = extractIdentifiers(instruction, systemMnemonicEnvironmentName);
			// Istruzione malformata
			if (instruction.isParsingError()) {
				return;
			}
			// Non Special register e non Environment name: è un mnemonic name dichiarato in Special-Names
			if (instruction.isSemanticError()) {
				instruction.setSemanticError(false);
				identifierToBeCloned = al_identifierInput.get(0);
				identifierUpon = (DataItemCobolIdentifier) identifierToBeCloned.clone();
				identifierUpon.setDataItem(null);
				identifierUpon.setNameIdentifier(systemMnemonicEnvironmentName);
				identifierUpon.setIdentifierType(EnumCobolReservedWords.MNEMONIC_NAME);
				identifierUpon.getQualifier().setSymbolValue(systemMnemonicEnvironmentName);
				identifierUpon.getQualifier().setSymbolType(EnumSymbolType.COBOL_SYMBOL_MNEMONIC_NAME);
			} else {
				identifierUpon = al_identifier.get(0);
			}
			al_identifierInput.add(identifierUpon);
		}

		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		instruction.displaySetIdentifiersInput(al_identifierInput);
		if (iUpon > 0) {
			instruction.displaySetWithUpon();
			instruction.displaySetIdentifierUpon(identifierUpon);
		}
		
		// Identificatore di input
		for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}

		
		
		
	}


	/*
     * Analisi statement Accept.
     * 
    */
	private void analyzeProcAccept(InstructionCobolProcedure instruction) throws ExceptionAmrita {

		ArrayList<DataItemCobolIdentifier> al_identifier = null;
		DataItemCobolIdentifier identifierOutput = null;
		DataItemCobolIdentifier identifierInput = null;

		String sourceInstr = instruction.getSourceInstr();

		// Stringhe con estratte da istruzione
		String str = "";
		String strIdentifierOutput = "";
		String systemMnemonicEnvironmentName = "";
		
		// Posizione parole chiave
		int iFrom = 0;
		
		// Elimino Accept  
		str = sourceInstr.substring(6).trim().toUpperCase();
		
		// Individuo eventuale UPON
		iFrom = str.indexOf(" FROM ");

		
		// Estrazione stringhe identificatori input/output
		if (iFrom > 0) {
			strIdentifierOutput = str.substring(0, iFrom).trim();
			systemMnemonicEnvironmentName = str.substring(iFrom + 5).trim();
		} else {
			strIdentifierOutput = str.substring(0).trim();
		}
		
		// Estrazione identificatore di output
		al_identifier = extractIdentifiers(instruction, strIdentifierOutput);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
		identifierOutput = al_identifier.get(0);
		
		// Estrazione identificatore di input
		if (!systemMnemonicEnvironmentName.equals("")) {
			al_identifier = extractIdentifiers(instruction, systemMnemonicEnvironmentName);
			// Istruzione malformata
			if (instruction.isParsingError()) {
				return;
			}
			// Non Special register e non Environment name: è un mnemonic name dichiarato in Special-Names
			if (instruction.isSemanticError()) {
				instruction.setSemanticError(false);
				identifierInput = (DataItemCobolIdentifier) identifierOutput.clone();
				identifierInput.setDataItem(null);
				identifierInput.setNameIdentifier(systemMnemonicEnvironmentName);
				identifierInput.setIdentifierType(EnumCobolReservedWords.MNEMONIC_NAME);
				identifierInput.getQualifier().setSymbolValue(systemMnemonicEnvironmentName);
				identifierInput.getQualifier().setSymbolType(EnumSymbolType.COBOL_SYMBOL_MNEMONIC_NAME);
			} else {
				identifierInput = al_identifier.get(0);
			}
			
		}
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore di Output
		addInstructionSymbolsUsedAndDefined(instruction, identifierOutput, COBOL_DATA_ITEM_USED_OUTPUT);
		
		// Nessun nome di sistema o di ambiente o mnemonico specificato
		if (systemMnemonicEnvironmentName.equals("")) {
			return;
		}
		
		// Simbolo in input
		addInstructionSymbolsUsedAndDefined(instruction, identifierInput, COBOL_DATA_ITEM_USED_INPUT);	
	}


	/*
     * Analisi generalizzata statement Add, Multiply, Subtract e Divide
     * 
    */
	private void analyzeProcAddSubMultDiv(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		Scanner scn = null;
		ArrayList<DataItemCobolIdentifier> al_identifier = null;
		ArrayList<DataItemCobolIdentifier> al_identifierBeforeToFromByInto = null;
		ArrayList<DataItemCobolIdentifier> al_identifierAfterToFromByInto = null;
		ArrayList<DataItemCobolIdentifier> al_identifierGiving = null;
		DataItemCobolIdentifier identifierRemainder = null;
		ExceptionAmrita excp = null;
        String token = "";
		String sourceInstr = "";
		String str = "";
		String strBeforeToFromByInto = "";
		String strAfterToFromByInto = "";
		String strGiving = "";
		String strRemainder = "";
		int lngToFromByInto = 0;
		int iToFromByInto = 0;
		int iGiving = 0;
		int iRemainder = 0;
		int iToFromByIntoEnd = 0;
		boolean isCorresponding = false;
		boolean isToByIntoFrom = false;					// Presente clusola TO o  BY o INTO o FROM
		
		sourceInstr = instruction.getSourceInstr();
		str = getSourceNormalized(sourceInstr);
		str = str.trim();
		
		// Elimino Add/Subtract/Multiply/Divide
		scn = new Scanner(str);
		token = scn.next();
		str = str.substring(token.length()).trim();
		scn = new Scanner(str);
		token = scn.next();
		if (token.equals("CORR") || token.equals("CORRESPONDING") ) {
			isCorresponding = true;
			str = str.substring(token.length());
		}
		
		// Individuo pointers a parole chiave
		iToFromByInto = str.indexOf(" TO ");
		lngToFromByInto = 3;
		if (iToFromByInto > 0) {
			isToByIntoFrom = true;
		}
		if (iToFromByInto < 0) {
			iToFromByInto = str.indexOf(" FROM ");
			lngToFromByInto = 6;
			if (iToFromByInto > 0) {
				isToByIntoFrom = true;
			}
		}
		if (iToFromByInto < 0) {
			iToFromByInto = str.indexOf(" BY ");
			lngToFromByInto = 4;
			if (iToFromByInto > 0) {
				isToByIntoFrom = true;
			}
		}
		if (iToFromByInto < 0) {
			iToFromByInto = str.indexOf(" INTO ");
			lngToFromByInto = 6;
			if (iToFromByInto > 0) {
				isToByIntoFrom = true;
			}
		}
		// Caso ADD senza TO con GIVING
		if (iToFromByInto < 0) {
		   iToFromByInto = str.indexOf(" GIVING ");
		   lngToFromByInto = 8;
		}
		iGiving = str.indexOf(" GIVING ");
		iRemainder = str.indexOf(" REMAINDER ");
		
		
		// Individuo pointer di fine stringa identificatori dopo To/From/By/Into
		if (iGiving > 0) {
			iToFromByIntoEnd = iGiving;
		}
		if (iGiving < 0 && iRemainder < 0) {
			iToFromByIntoEnd = str.length();
		}
		if (iGiving < 0 && iRemainder > 0) {
			iToFromByIntoEnd = iRemainder;
		}
		

		// Estrazione addendi/operandi e campi risultato di Giving 
		strBeforeToFromByInto = str.substring(0, iToFromByInto).trim();
		if (isToByIntoFrom) {
			strAfterToFromByInto = str.substring(iToFromByInto + lngToFromByInto, iToFromByIntoEnd).trim();
		}
		if (iGiving > 0 && iRemainder < 0) {
			strGiving = str.substring(iGiving + 8, str.length()).trim();
		}
		if (iGiving > 0 && iRemainder > 0) {
			strGiving = str.substring(iGiving + 8, iRemainder).trim();
		}
		
		// Estrazione Remainder
		if (iRemainder > 0) {
			strRemainder = str.substring(iRemainder + 11).trim();
		}
		
		// Estraggo identificatori di input  
		al_identifierBeforeToFromByInto = extractIdentifiers(instruction, strBeforeToFromByInto);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			instruction.setParsingError(true);
		}

		// Estraggo identificatori di output (o ancora di input se c'è GIVING)
		if (isToByIntoFrom) {
			al_identifierAfterToFromByInto = extractIdentifiers(instruction, strAfterToFromByInto);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
				instruction.setParsingError(true);
			}
		} else {
			al_identifierAfterToFromByInto = new ArrayList<DataItemCobolIdentifier> ();
		}

		// Estraggo identificatore Giving
		if (iGiving > 0) {
			al_identifierGiving = extractIdentifiers(instruction, strGiving);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
				instruction.setParsingError(true);
			}
		}
		
		// Estraggo identificatore Remainder
		if (iRemainder > 0) {
			al_identifier = extractIdentifiers(instruction, strRemainder);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
				instruction.setParsingError(true);
			}
			identifierRemainder = al_identifier.get(0);
		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
        
		if (isCorresponding) {
			instruction.addMapDescriptorObject("$OPT$" + "CORR", "");
		}
	    instruction.addMapDescriptorObject("$BEFORE$", al_identifierBeforeToFromByInto);
	    instruction.addMapDescriptorObject("$AFTER$", al_identifierAfterToFromByInto);
	    instruction.addMapDescriptorObject("$GIVING$", al_identifierGiving);
	    instruction.addMapDescriptorObject("$REMAINDER$", identifierRemainder);
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore di input
		for (DataItemCobolIdentifier innerIdentifier : al_identifierBeforeToFromByInto) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}
		if (iGiving > 0) {
			for (DataItemCobolIdentifier innerIdentifier : al_identifierAfterToFromByInto) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
			}
		}
		
		// Identificatori di Output
		if (iGiving > 0 ) {
			for (DataItemCobolIdentifier innerIdentifier : al_identifierGiving) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
			}
		} else {
			for (DataItemCobolIdentifier innerIdentifier : al_identifierAfterToFromByInto) {
				addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
			}
		}
		if (iRemainder > 0 ) {
			addInstructionSymbolsUsedAndDefined(instruction, identifierRemainder, COBOL_DATA_ITEM_USED_OUTPUT);
		}
	}

	

	/*
     * Analisi statement Compute.
     * 
    */
	private void analyzeProcCompute(InstructionCobolProcedure instruction) throws ExceptionAmrita {

		ArrayList<DataItemCobolIdentifier> al_identifierResult = null;
		ExpressionCobol expression = null;
		ExceptionAmrita excp = null;
		
		// Stringhe estratte da istruzione
		String sourceInstr = "";
		String str = "";
		String strResultItem = "";
		String strExpression = "";
		int iEqual = 0;					// Posizione parole chiave
 		int iExpressionStart = 0;		// Posizione inizio/fine operandi
		
 		sourceInstr = instruction.getSourceInstr();
 		
		// Elimino Compute  
		str = sourceInstr.substring(7).trim();
 
		// Normalizzazione
		str = str.replace("=", " = ");
		
		// Individuo pointers a inizio espressione
		iEqual = str.indexOf(" EQUAL ");
		if (iEqual > 0) {
			iExpressionStart = iEqual + 7;
		}
		if (iEqual < 0) {
			iEqual = str.indexOf(" = ");
			if (iEqual > 0) {
				iExpressionStart = iEqual + 3;
			}
		}
         
        // Istruzione malformata
        if (iEqual < 0) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			instruction.setParsingError(true);
			return;
		} 
        
		// Estrazione campo risultato ed espressione a destra del segno di uguale
		strResultItem = str.substring(0, iEqual).trim();
		strExpression = str.substring(iExpressionStart).trim();
		
		// Estraggo identificastori di output e espressione di input
		expression = extractExpression(instruction, strExpression); 
		if (instruction.isParsingError() || instruction.isSemanticError()) {  
			return;  
		}
		al_identifierResult = extractIdentifiers(instruction, strResultItem);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
        
		////////////////////////////////////////////////////////////////////
		// Valorizzazione strutture istruzione
		////////////////////////////////////////////////////////////////////
		
		instruction.computeSetExpressionAssigned(expression);
		instruction.computeSetResultIdentifier(al_identifierResult.get(0));
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore risultato di output
		for (DataItemCobolIdentifier innerIdentifier : al_identifierResult) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
		}
		addInstructionSymbolsExpressionInput(instruction, expression);

	}


	/*
     * Analisi statement Entry.
     * 
    */
	private void analyzeProcEntry(InstructionCobolProcedure instruction) throws ExceptionAmrita {
		
		Scanner scn = null;
		ArrayList<DataItemCobolIdentifier> al_identifierEntryUsing = null;
		
		String sourceInstr = instruction.getSourceInstr();
         
		// Stringhe estratte da istruzione
		String str = "";
		String entryName = "";
		String strEntryUsing = "";
		String token = "";
		
		// Elimino Entry  
		str = sourceInstr.substring(5).trim().toUpperCase();
        scn = new Scanner(str);
        entryName = scn.next();
		
        str = str.substring(entryName.length()).trim();
        scn = new Scanner(str);
        token = scn.next();
        if (token.equals("USING")) {
        	 str = str.substring(5).trim();
		}
        strEntryUsing = str;	
        
		// Estraggo di Using
		al_identifierEntryUsing = extractIdentifiers(instruction, strEntryUsing);

	
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		instruction.addSymbolInput(entryName, EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		
		// Identificatore campi di using in input
		for (DataItemCobolIdentifier innerIdentifier : al_identifierEntryUsing) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
		}
		
	}

	/*
     * Analisi statement Continue.
     * Non è necessaria nessuna operazione.
     * 
    */
	private void analyzeProcContinue(InstructionCobolProcedure instruction) {

	}


	/*
     * Analisi statement Goback.
     * Non è necessaria nessuna operazione.
     * 
    */
	private void analyzeProcGoback(InstructionCobolProcedure instruction) {

	}

	/*
     * Analisi statement Stop.
     * Non è necessaria nessuna operazione.
     * 
    */
	private void analyzeProcStop(InstructionCobolProcedure instruction) {

	}


	/*
     * Analisi statement Exit.
     * Non è necessaria nessuna operazione.
     * 
    */
	private void analyzeProcExit(InstructionCobolProcedure instruction) {
	}

	
	/*
     * Analisi generaslizzata statement Sort/Merge.
     * 
    */
	private void analyzeProcSortMerge(InstructionCobolProcedure instruction, String sortMerge) throws ExceptionAmrita, SQLException {

		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		ArrayList<DataItemCobolIdentifier> al_Identifier = null;
		ArrayList<DataItemCobolIdentifier> al_keyDataName = null;
		ArrayList<String> al_keyAscDesc = null;
		ArrayList<String> al_usingFile = null;
		ArrayList<String> al_givingFile = null;
		DataItemCobolIdentifier identifierKey = null;
		EnumRelation typeRelationSortMerge = null;
		
		Scanner scn = null;
 		String sourceInstr = null;
		String str = "";
		String strAscDesc = "";
		String token = "";
		String fileNameSortMerge = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String ar_FileNameExternal[] = null;
		String collatingSequenceAlphabet = "";
		String inputProcedure = "";
		String inputProcedureThru = "";
		String outputProcedure = "";
		String outputProcedureThru = "";
		boolean withDuplicates = false;
		boolean withDuplicatesInOrder = false;
		
		// Allocazioni vuote
		ar_FileNameExternal = new String[0];							// Vuoto di default
		al_Identifier = new ArrayList<DataItemCobolIdentifier> ();
		al_keyDataName = new ArrayList<DataItemCobolIdentifier> ();
		al_keyAscDesc = new ArrayList<String> ();
		al_usingFile = new ArrayList<String> ();
		al_givingFile = new ArrayList<String> ();
		
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(5).trim().toUpperCase(); 		// Elimino SORT
		
		// Elimino parole chiave non gestite e/o ininfluenti
		str = str.replace(" ON ", " ");
		str = str.replace(" IN ", " ");
		str = str.replace(" KEY ", " ");
		str = str.replace(" COLLATING ", " ");
		str = str.replace(" IS ", " ");
		str = str.replace(" WITH ", " ");
		str = str.replace(",", " , ");

		
		scn = new Scanner(str);
		
		// Estrazione nome del file
		fileNameSortMerge = nextToken(scn);
		token = nextToken(scn);
		
		
		// Scan token istruzione
		while (!token.equals("")) {
            
			// Virgola di separazione: bypass
			if (token.equals(",")) {
				token = nextToken(scn);
				continue;
			}
			
			// Ascending/Descending
			if (token.equals("ASCENDING") 
			||  token.equals("DESCENDING")) {
				strAscDesc = token;
				token = nextToken(scn);
				while (!token.equals("")
				  &&   !token.equals("ASCENDING")	
				  &&   !token.equals("DESCENDING")
				  &&   !token.equals("DUPLICATES")
				  &&   !token.equals("SEQUENCE")
				  &&   !token.equals("USING")
				  &&   !token.equals("INPUT")	
				  &&   !token.equals("GIVING")	
				  &&   !token.equals("OUTPUT")) {
					
					// Virgola di separazione: bypass
					if (token.equals(",")) {
						token = nextToken(scn);
						continue;
					}
					
					al_keyAscDesc.add(strAscDesc);
					al_Identifier = extractIdentifiers(instruction, token);
					if (instruction.isParsingError() || instruction.isSemanticError()) {
						return;
					}
					identifierKey = al_Identifier.get(0);
					al_keyDataName.add(identifierKey);
					token = nextToken(scn);				// next
				}
				continue;
			}

			// With Duplicates
			if (token.equals("DUPLICATES")) {
				withDuplicates = true;
				token = nextToken(scn);					 
				// Input procedure thru
				if (token.equals("ORDER")) {
					withDuplicatesInOrder = true;
					token = nextToken(scn);	
				}
				continue;
			}

			// Collating Sequence
			if (token.equals("SEQUENCE")) {
				collatingSequenceAlphabet = nextToken(scn);					 
				token = nextToken(scn);					 
				continue;
			}
			
			// Using file name
			if (token.equals("USING")) {
				token = nextToken(scn);
				while (!token.equals("")
				  &&   !token.equals("INPUT")	
				  &&   !token.equals("GIVING")	
				  &&   !token.equals("OUTPUT")) {

					// Virgola di separazione: bypass
					if (token.equals(",")) {
						token = nextToken(scn);
						continue;
					}

					al_usingFile.add(token);
					token = nextToken(scn);				// next
				}
				continue;
			}

			// Input Procedure
			if (token.equals("INPUT")) {
				token = nextToken(scn);					// PROCEDURE
				inputProcedure = nextToken(scn);		// Procedure name
				token = nextToken(scn);	
				// Input procedure thru
				if (token.equals("THRU") || token.equals("THROUGH")) {
					inputProcedureThru = nextToken(scn);
					token = nextToken(scn);	
				}
				continue;
			}

			// Giving file name
			if (token.equals("GIVING")) {
				token = nextToken(scn);
				while (!token.equals("")
				  &&   !token.equals("INPUT")	
				  &&   !token.equals("GIVING")	
				  &&   !token.equals("OUTPUT")) {

					// Virgola di separazione: bypass
					if (token.equals(",")) {
						token = nextToken(scn);
						continue;
					}

					al_givingFile.add(token);
					token = nextToken(scn);				// next
				}
				continue;
			}
			
			// Output Procedure
			if (token.equals("OUTPUT")) {
				token = nextToken(scn);					// PROCEDURE
				outputProcedure = nextToken(scn);		// Procedure name
				token = nextToken(scn);	
				// Input procedure thru
				if (token.equals("THRU") || token.equals("THROUGH")) {
					outputProcedureThru = nextToken(scn);
					token = nextToken(scn);	
				}
				continue;
			}
			
		} // end-while
		
		
		// Cerco external file name da relazionare in sort
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameSortMerge.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
     	instruction.sortMergeSetFileNameInternal(fileNameSortMerge);
    	instruction.sortMergeSetFromInputProcedure(inputProcedure);
    	instruction.sortMergeSetThruInputProcedure(inputProcedureThru);
    	instruction.sortMergeSetFromOutputProcedure(outputProcedure);
    	instruction.sortMergeSetThruOutputProcedure(outputProcedureThru);
    	if (!inputProcedure.equals("")) {instruction.sortMergeSetWithInputProcedure();}
    	if (!inputProcedureThru.equals("")) {instruction.sortMergeSetWithThruInputProcedure();}
    	if (!outputProcedure.equals("")) {instruction.sortMergeSetWithOutputProcedure();}
    	if (!outputProcedureThru.equals("")) {instruction.sortMergeSetWithThruOutputProcedure();}
    	instruction.sortMergeSetFileNamesExternal(ar_FileNameExternal);
       	instruction.addMapDescriptorObject("$ALPHABET$", collatingSequenceAlphabet);
       	instruction.addMapDescriptorObject("$DUPLICATES$", withDuplicates);
       	instruction.addMapDescriptorObject("$DUPLICATES_IN_ORDER$", withDuplicatesInOrder);
       	instruction.addMapDescriptorObject("$KEYS$", al_keyDataName);
       	instruction.addMapDescriptorObject("$KEYS_ORDER$", al_keyAscDesc);
       	instruction.addMapDescriptorObject("$USING-FILES$", al_usingFile);
       	instruction.addMapDescriptorObject("$GIVING-FILES$", al_givingFile);
    	
    	
    	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e  output
		////////////////////////////////////////////////////////////////////
		
    	// File name to sort/Merge
	  	instruction.addSymbolInput(fileNameSortMerge, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	
	  	// Keys
        for (DataItemCobolIdentifier dataItemidentifier : al_keyDataName) {
        	addInstructionSymbolsUsedAndDefined(instruction, dataItemidentifier, COBOL_DATA_ITEM_USED_INPUT);
		}
	  	
	  	// Input procedure
	  	if (!inputProcedure.equals("")) {
	  		instruction.addSymbolInput(inputProcedure, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
	  	if (!inputProcedureThru.equals("")) {
	  		instruction.addSymbolInput(inputProcedureThru, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
	  	
	    // Output procedure
	  	if (!outputProcedure.equals("")) {
	  		instruction.addSymbolInput(outputProcedure, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
	  	if (!outputProcedureThru.equals("")) {
	  		instruction.addSymbolInput(outputProcedureThru, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
	  	
	  	// Using file
	  	for (int i = 0; i < al_usingFile.size(); i++) {
	  		instruction.addSymbolInput(al_usingFile.get(i), EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
		}
	  	
	  	// Giving file
	  	for (int i = 0; i < al_givingFile.size(); i++) {
	  		instruction.addSymbolInput(al_usingFile.get(i), EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
		}
	  	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
        
	  	// Internal file già inserito anche nella Select di programma
	    this.analyzerDbInfo.getAddObjectEntitled(fileNameSortMerge, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameSortMerge
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
		
		if (sortMerge.equals("SORT")) {
			typeRelationSortMerge = EnumRelation.PGM_INTERNAL_FILE_SORT;
		} else {
			typeRelationSortMerge = EnumRelation.PGM_INTERNAL_FILE_MERGE;
		}
		
		// Relazione fra programma ed internal file in sort/merge
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  ,	EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameSortMerge
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , typeRelationSortMerge
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );


		// Relazioni fra programma ed external files sort/merge
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
    	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
    									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
   									   );

    		if (sortMerge.equals("SORT")) {
    			typeRelationSortMerge = EnumRelation.PGM_EXTERNAL_FILE_SORT;
    		} else {
    			typeRelationSortMerge = EnumRelation.PGM_EXTERNAL_FILE_MERGE;
    		}
    		
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											EnumObject.OBJECT_PGM_COBOL
										  , this.programName
										  ,	EnumObject.OBJECT_EXTERNAL_FILE
										  , fileNameExternal
										  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										  , typeRelationSortMerge
										  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										  , this.programName
										  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
										  , instruction.getTypeInstrCategory()
										  , this.activeDivisionArea
										  , false
										  , false
										  , false
										  , this.di.userExitInfoPgm
										   );
		}

	}


	/*
     * Analisi statement Use.
     * 
    */
	private void analyzeProcUse(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

	
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		ArrayList<String> al_fileName = null;
		ArrayList<String> al_fileNameExternal = null;
		ArrayList<String> al_procedureName = null;
		
		Scanner scn = null;
 		String sourceInstr = null;
		String str = "";
		String token = "";
		String fileNameInternal = "";
		String fileNameExt = "";
		String ar_fileNameExternal[] = null;
		String ar_fileName[] = null;
		String ar_procedureName[] = null;
		String typeEvent = "";						// Exception/Error/Beginning/Ending/Debugging
		String procedureOnFileMode = "";			// Input/Output/I-O/Extend
		String useTime = "";						// File/Reel/Unit
		boolean isLabelProcedure = false;
		boolean isDebuggingAllProcedures = false;
		
		
		// Allocazioni vuote
		ar_fileName = new String[0];							// Vuoto di default
		ar_fileNameExternal = new String[0];					// Vuoto di default
		ar_procedureName = new String[0];						// Vuoto di default
		al_fileName = new ArrayList<String> ();
		al_fileNameExternal = new ArrayList<String> ();
		al_procedureName = new ArrayList<String> ();
		
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(3); 			// Elimino USE  
		
		// Elimino parole chiave non gestite e/o ininfluenti
		str = str.replace(" GLOBAL ", " ");
		str = str.replace(" AFTER ", " ");
		str = str.replace(" STANDARD ", " ");
		str = str.replace(" ON ", " ");
		str = str.replace(" FOR ", " ");
		str = str.replace(",", " , ");

		
		scn = new Scanner(str);
		token = nextToken(scn);        

		// Exception/Error/Beginning/error/Debugging
		typeEvent = token;
		
		// Potrebbe essere Use After Label
		if (!token.equals("LABEL")) {
		    token = nextToken(scn); 
		}
        
		// File/Reel/Unit if asny
		if (token.equals("FILE")
		||  token.equals("REEL")
		||  token.equals("UNIT")) {
			useTime = token;
			token = nextToken(scn); 
		}
		
		// Label if Any
		if (token.equals("LABEL")) {
		   isLabelProcedure = true;
		   typeEvent = "";
		   token = nextToken(scn); 
		}

		// Procedure ...oppure file-names ...
		if (!typeEvent.equals("DEBUGGING")) {
			token = nextToken(scn); 				// Bypass Procedure
			if (token.equals("INPUT")
			||  token.equals("OUTPUT")		
			||  token.equals("I-O")		
			||  token.equals("EXTEND")) {
				procedureOnFileMode = token;
			} else {
				while (!token.equals("")) {
					if (token.equals(",")) {
						token = nextToken(scn); 
						continue;
					}
					al_fileName.add(token);
					token = nextToken(scn); 		
				}
				ar_fileName = new String[al_fileName.size()];
				ar_fileName = al_fileName.toArray(ar_fileName);
			}
		}

		// All Procedures ... oppure procedure names ...
		if (typeEvent.equals("DEBUGGING")) {
			token = nextToken(scn); 				// All Procedure o procedure-name ...
			if (token.equals("PROCEDURES")) {
				isDebuggingAllProcedures = true;
			} else {
				while (!token.equals("")) {
					if (token.equals(",")) {
						token = nextToken(scn); 
						continue;
					}
					al_procedureName.add(token);
					token = nextToken(scn); 		
				}
				ar_procedureName = new String[al_procedureName.size()];
				ar_procedureName = al_procedureName.toArray(ar_procedureName);
			}
		}
		
		
		// Scan files name e recupero external file name
        for (String fileNameUse : al_fileName) {

    		// Cerco external file name da relazionare 
    		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
    			
    			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
    			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
    			
    			// Select: verifica se lo stesso file
    			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
    				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
    				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
    				// E' lo stesso file: estraggo le dd names
    				if (fileNameUse.equals(fileNameInternal)) {
    					ar_fileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
    					for (String fileNameExternal : ar_fileNameExternal) {
							al_fileNameExternal.add(fileNameExternal);
						}
    					break;
    					
    				} // end-if
    				
    			} // end-if
    			
    		} // end-for

		} // end-for
        
        // Trasform in array
        ar_fileNameExternal = new String[al_fileNameExternal.size()];
        ar_fileNameExternal = al_fileNameExternal.toArray(ar_fileNameExternal);
		

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		instruction.addMapDescriptorObject("$OPT$" + "LABEL", isLabelProcedure);
		instruction.addMapDescriptorObject("$OPT$" + "DEBUG-ALL", isDebuggingAllProcedures);
		instruction.addMapDescriptorObject("$TYPE-EVENT$", typeEvent);
		instruction.addMapDescriptorObject("$PROC-ON-FILE-MODE$", procedureOnFileMode);
		instruction.addMapDescriptorObject("$USE-TIME$", useTime);
    	instruction.addMapDescriptorObject("$FILES$", ar_fileName);
    	instruction.addMapDescriptorObject("$PROCEDURES$", ar_procedureName);
    	instruction.addMapDescriptorObject("$DDNAMES$", ar_fileNameExternal);
    	
    	
    	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e  output
		////////////////////////////////////////////////////////////////////
		
       	// Files name internal
    	for (String fileInternal : ar_fileName) {
    		instruction.addSymbolInput(fileInternal, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
		}
    	
    	// Files name external
    	for (String fileExternal : ar_fileNameExternal) {
    		instruction.addSymbolInput(fileExternal, EnumSymbolType.COBOL_SYMBOL_EXTERNAL_FILE);
		}
    	
       	// Procedures name  
    	for (String file : ar_procedureName) {
    		instruction.addSymbolInput(file, EnumSymbolType.COBOL_SYMBOL_PROC_INTERNAL);
		}
	  	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

       	// Files name  
    	for (String fileInternal : ar_fileName) {
    	  	// Internal file già inserito anche nella Select di programma
       	    this.analyzerDbInfo.getAddObjectEntitled(fileInternal, EnumObject.OBJECT_INTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_INTERNAL_FILE
    									  , fileInternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_INTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
   									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
   									   );
		}

		


		// Relazioni fra programma ed external files in read
        for (int i = 0; i < ar_fileNameExternal.length; i++) {
			
        	fileNameExt = ar_fileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
       	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExt, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExt
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
   									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
   									   );

 		}
		
	}

	/*
     * Analisi statement Return.
     * 
    */
	private void analyzeProcReturn(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobolDataStruct instrCobolData = null;
		InstructionCobol instrGeneric = null;
		ArrayList<DataItemCobolIdentifier> al_Identifier = null;
		DataItemCobolIdentifier intoIdentifier = null; 
		InstructionCobolDataItem intoDataItem = null;
		ExceptionAmrita excp = null;
		
		Scanner scn = null;
 		String sourceInstr = null;
		String str = "";
		String strInto = "";
		String token = "";
		String fileNameReturn = "";
		String fileNameInternal = "";
		String fileNameFd = "";
		String fileNameExternal = "";
		String ar_FileNameExternal[] = null;
		
		// Allocazioni vuote
		ar_FileNameExternal = new String[0];							// Vuoto di default
		al_Identifier = new ArrayList<DataItemCobolIdentifier> ();
		
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(7).trim().toUpperCase(); 		// Elimino RETURN  
		
		
		scn = new Scanner(str);
		
		// Estrazione nome del file
		fileNameReturn = nextToken(scn);
		token = nextToken(scn);						// RECORD|INTO ?
		if (token.equals("RECORD")) {
			token = nextToken(scn);					// INTO ?
		}
		
		// Presente INTO opzionale
		if (token.equals("INTO")) {
			strInto = nextToken(scn);					// Into identifier

			// Istruzione malformata
			if (strInto.equals("")) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", token, excp, this.programName, token);
				instruction.setSemanticError(true);
				return;
			}
			
			// Into identifier
			al_Identifier = extractIdentifiers(instruction, strInto);
			if (instruction.isParsingError() || instruction.isSemanticError()) {
				return;
			}
			intoIdentifier = al_Identifier.get(0);
			intoDataItem = intoIdentifier.getDataItem();
		}
		
		
		// INTO non specificato: implicitamente si dichiara il primo 01 dopo FD
		if (!token.equals("INTO")) {
			// Cerco FD del file interno
			for (int i = 0; i < this.programCobol.entriesData().length; i++) {
				ProgramCobolEntry<? extends Instruction> entryData = this.programCobol.entriesData()[i];
				if (!(entryData.getInstruction() instanceof InstructionCobol)) {continue;}
				instrGeneric = (InstructionCobol) entryData.getInstruction();
				
				// FD: verifica se lo stesso file
				if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_FD) {
					
					instrCobolData = (InstructionCobolDataStruct) entryData.getInstruction();
					fileNameFd = (String) instrCobolData.getMapDescriptorObject("$FILE$");
					
					// Non è lo stesso file: cerca il prossimo
					if (!fileNameReturn.equals(fileNameFd)) {
						continue;
					}
					
					// Stesso file: l'istruzione successiva deve essere il livello 01 del record
					entryData = this.programCobol.entriesData()[++i];
					Instruction instGeneric = entryData.getInstruction();
					if (!(instGeneric instanceof InstructionCobolDataItem)) {
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
						instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0029", fileNameFd, excp, this.programName);
						instruction.setSemanticError(true);
						break;
					}
					
					// Istruzione di definizione del data item
					intoDataItem = (InstructionCobolDataItem) instGeneric;
					break;
					
				} // end-if
				
			} // end-for
			
		} // end-if

		
		// Cerco external file name da relazionare in sort
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameReturn.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for

		

		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		if (!strInto.equals("")) {
			instruction.addMapDescriptorObject("$OPT$" + "INTO", "");
		}
    	instruction.addMapDescriptorObject("$FILE$", fileNameReturn);
    	instruction.addMapDescriptorObject("$DDNAMES$", ar_FileNameExternal);
    	instruction.addMapDescriptorObject("$INTO$", intoDataItem);
    	
    	
    	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e  output
		////////////////////////////////////////////////////////////////////
		
    	// File name  
	  	instruction.addSymbolInput(fileNameReturn, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	if (intoIdentifier != null) {
		  	addInstructionSymbolsUsedAndDefined(instruction, intoIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}
	  	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
        
	  	// Internal file già inserito anche nella Select di programma
   	    this.analyzerDbInfo.getAddObjectEntitled(fileNameReturn, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameReturn
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
		


		// Relazioni fra programma ed external files in read
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
       	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
   									      , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
    									   );

 		}

	}

    /*
     * Analisi statement Release.
     * 
     */
	private void analyzeProcRelease(InstructionCobolProcedure instruction) throws ExceptionAmrita, SQLException {

		Scanner scn = null;
		Scanner scnWork = null;
		InstructionCobolDataItem fromDataItem = null;
		InstructionCobolEnvironment instrEnvDivision;
		InstructionCobol instrGeneric = null;
		DataItemCobolIdentifier fromIdentifier = null;
		ArrayList<DataItemCobolIdentifier> al_Identifier = null;
		ExceptionAmrita excp = null;
		String sourceInstr = null;
		String str = "";
		String strWork = "";
		String fileNameInternal = "";
		String fileNameExternal = "";
		String fileNameRelease = "";
		String fromIoareaName = "";
		String recordNameRelease = "";
		String ar_FileNameExternal[] = null;
		boolean ioSequential = false;
		boolean ioVsam = false;
		int ar_pointersFromIoarea[] = null;
		int iFrom = 0;

		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(7).trim().toUpperCase(); 		// Elimino RELEASE
		scn = new Scanner(str);
		
		// Individuo la posizione delle parole chiave  
		iFrom = str.indexOf(" FROM ");

		recordNameRelease = scn.next();
		
		fileNameRelease = fileNameFromRecordName(instruction, recordNameRelease);
		if (instruction.isSemanticError()) {
			return;
		}
		
		
		// Estrazione eventuale FROM identifier
		if (iFrom > 0) {
			strWork = str.substring(iFrom + 6).trim();
			scnWork = new Scanner(strWork);
			fromIoareaName = scnWork.next();
			ar_pointersFromIoarea = this.programCobol.dataItemPointers(fromIoareaName);
			// Errore di programma o sorgente corrotto
			if (ar_pointersFromIoarea == null) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", fromIoareaName, excp, this.programName, fromIoareaName);
				instruction.setSemanticError(true);
				return;
			}
			fromDataItem = this.programCobol.dataItemDefinition(ar_pointersFromIoarea[0]);
		} // end-if
        

		// FROM non specificato: si considera come ioarea il record name specificato
		if (iFrom == -1) {
			ar_pointersFromIoarea = this.programCobol.dataItemPointers(recordNameRelease);
			// Errore di programma o sorgente corrotto
			if (ar_pointersFromIoarea == null) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", recordNameRelease, excp, this.programName, recordNameRelease);
				instruction.setSemanticError(true);
				return;
			}
			fromDataItem = this.programCobol.dataItemDefinition(ar_pointersFromIoarea[0]);
		} // end-if

		
		// Cerco external file name da relazionare  
		for (int j = 0; j < this.programCobol.entriesEnvironment().length; j++) {
			
			ProgramCobolEntry<? extends Instruction> entryEnvironment = this.programCobol.entriesEnvironment()[j];
			instrGeneric = (InstructionCobol) entryEnvironment.getInstruction();
			
			// Select: verifica se lo stesso file
			if (instrGeneric.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instrEnvDivision = (InstructionCobolEnvironment) entryEnvironment.getInstruction();
				fileNameInternal = (String) instrEnvDivision.getMapDescriptorObject("$FILE$");
				// E' lo stesso file: estraggo le dd names
				if (fileNameRelease.equals(fileNameInternal)) {
					ar_FileNameExternal = (String[]) instrEnvDivision.getMapDescriptorObject("$DDNAMES$");
					break;
					
				} // end-if
				
			} // end-if
			
		} // end-for


		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
    	instruction.addMapDescriptorObject("$FILE$", fileNameRelease);
    	instruction.addMapDescriptorObject("$DDNAMES$", ar_FileNameExternal);
       	instruction.addMapDescriptorObject("$IOAREA$", fromDataItem);
	   	
	   	////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(recordNameRelease, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	  	if (iFrom > 0) { 
	  		instruction.addSymbolInput(fromIoareaName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	  		
		  	// Impostazione di tutti i sottocampi eventuali come symboli di output
			al_Identifier = extractIdentifiers(instruction, fromIoareaName);
			fromIdentifier = al_Identifier.get(0);
		  	addInstructionSymbolsUsedAndDefinedGroup(instruction, fromIdentifier, INSTR_USE_DATA_ITEM_INPUT);
		}
	  	
	  	
		////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

       // Relazioni fra programma ed internal file in update
   	    this.analyzerDbInfo.getAddObjectEntitled(fileNameRelease, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
     								  , this.programName
				                      , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameRelease
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefProcDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , ioSequential
									  , ioVsam
									  , false
									  , this.di.userExitInfoPgm
									   );



		// Relazioni fra programma ed external files 
        for (int i = 0; i < ar_FileNameExternal.length; i++) {
			
        	fileNameExternal = ar_FileNameExternal[i];
        	
    	  	// Internal file già inserito anche nella Select di programma
       	    this.analyzerDbInfo.getAddObjectEntitled(fileNameExternal, EnumObject.OBJECT_EXTERNAL_FILE);
    		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
         									EnumObject.OBJECT_PGM_COBOL
    				  					  , this.programName
    									  , EnumObject.OBJECT_EXTERNAL_FILE
    									  , fileNameExternal
    									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
    									  , EnumRelation.PGM_EXTERNAL_FILE
    									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
    									  , this.programName
    									  , this.curNumDefProcDiv
										  , instruction.getRowStartSource()
										  , instruction.getRowEndSource()
										  , ""
										  , 0
										  , 0
    									  , instruction.getTypeInstrCategory()
    									  , this.activeDivisionArea
    									  , false
    									  , false
    									  , false
										  , this.di.userExitInfoPgm
 									   );

 		}
	
		
	}


	/*
     * Analisi statement Declaratives.
     * 
     * Non è necessaria nessuna operazione.
     * 
     */
	private void analyzeProcDeclaratives(InstructionCobolProcedure instruction) {
	}

	/*
     * Analisi statement Invoke.
     * 
     * Si tratta dell'attivazione di metodi java.
     * 
     */
	private void analyzeProcInvoke(InstructionCobolProcedure instruction) {
		// TODO
	}

	
	private void analyzeProcTerminate(InstructionCobolProcedure instruction) {
		// TODO Auto-generated method stub
		
	}


	private void analyzeProcInitiate(InstructionCobolProcedure instruction) {
		// TODO Auto-generated method stub
		
	}
	
	private void analyzeProcInspect(InstructionCobolProcedure instruction) {
		// TODO Auto-generated method stub
		
	}



	private void analyzeProcTransform(InstructionCobolProcedure instruction) {
		// TODO Auto-generated method stub
		
	}


	/*
     * Analisi statement String.
     * 
     * Vengono solo indicizzatti i simboli utilizzati.
     * 
    */
	private void analyzeProcString(InstructionCobolProcedure instruction) {

		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		ArrayList<DataItemCobolIdentifier> al_identifierOutput = null;
		ExceptionAmrita excp = null;
		
		// Stringhe estratte da istruzione
		String sourceInstr = "";
		String str = "";
		String strIdentifierInput = "";
		String strIdentifierOutput = "";
		int iInto = 0;
		
		sourceInstr = instruction.getSourceInstr();
		
		// Elimino String  
		str = sourceInstr.substring(6).trim().toUpperCase();
		str = replaceSpaceInLiteralWithUnderscore(instruction, str);

		// elimino key words non gestite
		str = str.replace(" DELIMITED ", " ");
		str = str.replace(" BY ", " ");
		str = str.replace(" SIZE ", " ");
		str = str.replace(" SIZE,", " ");
		str = str.replace(" WITH ", " ");
		str = str.replace(" POINTER ", " ");
		
		iInto = str.indexOf(" INTO ");
		// Istruzione malformata
		if (iInto < 0) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			return;
		}
		
		// Estrazione stringhe identificatori di input e di output
		strIdentifierInput = str.substring(0, iInto).trim();
		strIdentifierOutput = str.substring(iInto + 6).trim();
		
		// Estrazione identificatori input
		al_identifierInput = extractIdentifiers(instruction, strIdentifierInput);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}

		// Estrazione identificatori output
		al_identifierOutput = extractIdentifiers(instruction, strIdentifierOutput);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}

	
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore campi input
		for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}
		
		// Identificatore campi Output
		for (DataItemCobolIdentifier innerIdentifier : al_identifierOutput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
		}

	}

	/*
     * Analisi statement Unstring.
     * 
     * Vengono solo indicizzati i simboli utilizzati.
     * 
    */
	private void analyzeProcUnstring(InstructionCobolProcedure instruction) {

		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		ArrayList<DataItemCobolIdentifier> al_identifierOutput = null;
		ExceptionAmrita excp = null;
		
		// Stringhe estratte da istruzione
		String sourceInstr = "";
		String str = "";
		String strIdentifierInput = "";
		String strIdentifierOutput = "";
		int iInto = 0;
		
		sourceInstr = instruction.getSourceInstr();
		
		// Elimino Unstring  
		str = sourceInstr.substring(8).trim().toUpperCase();

		// elimino key words non gestite
		str = str.replace(" DELIMITED ", " ");
		str = str.replace(" BY ", " ");
		str = str.replace(" ALL ", " ");
		str = str.replace(" OR ", " ");
		str = str.replace(" WITH ", " ");
		str = str.replace(" POINTER ", " ");
		str = str.replace(" IN ", " ");
		str = str.replace(" COUNT ", " ");
		str = str.replace(" TALLYNG ", " ");
		
		iInto = str.indexOf(" INTO ");
		// Istruzione malformata
		if (iInto < 0) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			return;
		}
		
		// Estrazione stringhe identificatori di input e di output
		strIdentifierInput = str.substring(0, iInto).trim();
		strIdentifierOutput = str.substring(iInto + 6).trim();
		
		// Estrazione identificatori input
		al_identifierInput = extractIdentifiers(instruction, strIdentifierInput);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}

		// Estrazione identificatori output
		al_identifierOutput = extractIdentifiers(instruction, strIdentifierOutput);
		if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}

	
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input e output
		////////////////////////////////////////////////////////////////////
		
		// Identificatore campi input
		for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}
		
		// Identificatore campi Output
		for (DataItemCobolIdentifier innerIdentifier : al_identifierOutput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_OUTPUT);
		}

		
	}


	private void analyzeProcExibit(InstructionCobolProcedure instruction) {
	}


	private void analyzeProcExamine(InstructionCobolProcedure instruction) {
	}



	private void analyzeProcAlter(InstructionCobolProcedure instruction) {
	}



	private void analyzeDirCompilerService(InstructionCobolProcedure instruction) {
	}


	
	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcInvalidKey(InstructionCobolProcedure instruction) {	

	}

	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcAtEop(InstructionCobolProcedure instruction) {

	}

	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcAtEndOfPage(InstructionCobolProcedure instruction) {

	}

	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcAtEnd(InstructionCobolProcedure instruction) {

	}


	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcOnException(InstructionCobolProcedure instruction) {

	}


	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcOnOverflow(InstructionCobolProcedure instruction) {

	}


	/*
     * Non è necessaria nessuna operazione.
    */
	private void analyzeProcOnSizeError(InstructionCobolProcedure instruction) {

	}

	
	
	/*
	 * 
	 * Viene analizzato lo statement Special-Names.
	 * 
	 */
	private void analyzeEnvSpecialNames(InstructionCobolEnvironment instruction) throws ExceptionAmrita {

		Scanner scn = null;
        Map<EnumCobolReservedWords, String> map_environment = null;  // Key=environment name, data=mnemonic name
        Map<String, String> map_alphabet = null;  					 // Key=alphabet name, data=STANDARD-1, STANDARD-2, NATIVE, EBCDIC
        Map<String, String> map_symbolicChar = null;  				 // Key=symbolic char, data=alphabet name
        Map<String, String> map_class = null;  						 // Key=class name, data=literalFrom space literalTo
        Map<String, String> map_currency = null;  					 // Key=currency sign, data=picture symbol
        LiteralCobol literalCobol = null;                            //
        
        String alphabetName = "";
        String alphabetValue = "";
        String className = "";
        String classLiteralFrom = "";
        String classLiteralThru = "";
        String currencySignLiteral = "";
        String currencyPictureSymbol = "";
        String environmentName = "";
        String symbolicName = "";
        String symbolicNameAlphabet = "";
        EnumCobolReservedWords en_environmentName = null;			 // Tabellato come C01,C02 etc 
        String mnemonicName = "";									 // Per esempio NEW-PAGE, usato nelle istruzioni
        boolean isDecimalPointComma = false;
		boolean isAlphabetEbcdic = true;
		
        map_alphabet = new HashMap<String, String> ();  	
        map_symbolicChar = new HashMap<String, String> ();  	
        map_class = new HashMap<String, String> ();  			
        map_currency = new HashMap<String, String> ();  		
        map_environment = new HashMap<EnumCobolReservedWords, String> ();  		
        literalCobol = new LiteralCobol();
        
		String sourceInstr = null;
		String str = "";
		String token = "";
		
		sourceInstr = instruction.getSourceInstr();
		
		// Special-names vuoto: nessuna operazione
		if (sourceInstr.trim().equals("SPECIAL-NAMES")) {
			return;
		}

		str = sourceInstr.substring(14).toUpperCase(); 		// Elimino SPECIAL-NAMES
		
		
		// Elimino le parole opzionali per comodita di gestione
		str = str.replace(" ARE "," ");
		str = str.replace(" IS "," ");
		str = str.replace(" THRU "," ");
		str = str.replace(" THROUGH "," ");
		str = str.replace(" SIGN "," ");
		str = str.replace(" WITH "," ");
		str = str.replace(" STATUS "," ");
		str = str.replace(" CHARACTERS "," ");
		  
        str = str.trim();
        str = replaceSpaceInLiteralWithUnderscore(instruction, str);
        if (instruction.isParsingError()) {
			return;
		}
        
		scn = new Scanner(str);
		token = nextToken(scn);
	   
 		// Scan words
		while (!token.equals("")) {
			
  			// Decimal point  is comma
			if (token.equals("DECIMAL-POINT")) {
				isDecimalPointComma = true;
				token = nextToken(scn);
				continue;
			}

 			// Currency
			if (token.equals("CURRENCY")) {
				currencySignLiteral = nextToken(scn);	    // Currency sign come $, EUR, CHF, JPY, HK$, HKD,etc
				token = nextToken(scn);                     // PICTURE
				token = nextToken(scn);                     // SYMBOL
				currencyPictureSymbol = nextToken(scn);		// Symbol value da mettere nella picture
				map_currency.put(currencySignLiteral.replace('_', ' '), currencyPictureSymbol);
				token = nextToken(scn);
				continue;
			}
 
 			// Class
			if (token.equals("CLASS")) {
				isDecimalPointComma = true;
				className = nextToken(scn);					// Class name
				classLiteralFrom = nextToken(scn);			// Literal from
				literalCobol.parseLiteral(classLiteralFrom+" ", 0);
				// Scan coppie literal thru literal
				while (!classLiteralFrom.equals("") 
				   && (literalCobol.isLiteralString() || literalCobol.isLiteralNum())) {
					classLiteralThru = nextToken(scn);
                    map_class.put(className, classLiteralFrom + " " + classLiteralThru);
    				classLiteralFrom = nextToken(scn);			// Literal from In cliclo
    				literalCobol.parseLiteral(classLiteralFrom+" ", 0);
				}
			    token = classLiteralFrom;
				continue;
			}

			// Alphabet
			if (token.equals("ALPHABET")) {
				alphabetName = nextToken(scn);				// Alphabet name
				alphabetValue = nextToken(scn);				// Alphabet value
				map_alphabet.put(alphabetName, alphabetValue);
				if (!alphabetValue.equals("EBCDIC")) {
					isAlphabetEbcdic = false;
				}
				token = nextToken(scn);
				continue;
			}

			// Symbolic character
			if (token.equals("SYMBOLIC")) {
				symbolicName = nextToken(scn);				// Symbolic name
				token = nextToken(scn);
				symbolicNameAlphabet = "";
				if (token.equals("IN")) {
					symbolicNameAlphabet = nextToken(scn);
				}
				map_symbolicChar.put(symbolicName, symbolicNameAlphabet);
				token = nextToken(scn);
				continue;
			}

			// Environment name
			en_environmentName = null;
			if (map_ReservedWords.get(token) != null&&  map_ReservedWords.get(token).get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_ENVIRONMENT_NAME) {
				en_environmentName = map_ReservedWords.get(token).get(0).en_WordReservedOwner;
				
				// Scan coppie envName IS mnemonicName
				while (en_environmentName != null ) {
					mnemonicName = nextToken(scn);
                    map_environment.put(en_environmentName, mnemonicName);
                    
                    environmentName = nextToken(scn);
                    if (environmentName.equals("")) {break;}
        			en_environmentName = null;
        			if (map_ReservedWords.get(environmentName) != null &&  map_ReservedWords.get(token).get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_ENVIRONMENT_NAME) {
        				en_environmentName = map_ReservedWords.get(token).get(0).en_WordReservedOwner;
        			}
				}
			    token = environmentName;
			    continue;
			}
			
            // token residuo di qualche clausola non gestito
			token = nextToken(scn);
		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		// Coppie di informazioni classificate
		instruction.specialNamesSetEnvironment(map_environment);
		instruction.specialNamesSetAlphabet(map_alphabet);
		instruction.specialNamesSetSymbolicChar(map_symbolicChar);
		instruction.specialNamesSetClass(map_class);
		instruction.specialNamesSetCurrency(map_currency);

		// Opzioni
		instruction.specialNamesSetDecimalPointComma(isDecimalPointComma);
		instruction.specialNamesSetAlphabetEbcdic(isAlphabetEbcdic);
		

	    // Impostazione flag generali nell'oggetto programma cobol
		this.programCobol.setDecimalPointComma(isDecimalPointComma);
		this.programCobol.setAlphabetEbcdic(isAlphabetEbcdic);
		this.programCobol.setSpecialNamesInfo(instruction);
		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
	  	
        // Scan Environment
	  	for (Entry<EnumCobolReservedWords, String> entry_environment : map_environment.entrySet()) {
	  		instruction.addSymbolInput(entry_environment.getKey().toString(), EnumSymbolType.COBOL_SYMBOL_ENVIRONMENT_NAME);
	  		instruction.addSymbolInput(entry_environment.getValue(), EnumSymbolType.COBOL_SYMBOL_MNEMONIC_NAME);
		}
		
        // Scan Alphabet
	  	for (Entry<String, String> entry_alphabet : map_alphabet.entrySet()) {
	  		instruction.addSymbolInput(entry_alphabet.getKey(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
	  		instruction.addSymbolInput(entry_alphabet.getValue(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		}

	  	// Scan Symbolic Char
	  	for (Entry<String, String> entry_symbolicChar : map_symbolicChar.entrySet()) {
	  		instruction.addSymbolInput(entry_symbolicChar.getKey(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
	  		instruction.addSymbolInput(entry_symbolicChar.getValue(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		}

	  	// Scan Class
	  	for (Entry<String, String> entry_class : map_class.entrySet()) {
	  		instruction.addSymbolInput(entry_class.getKey(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
	  		instruction.addSymbolInput(entry_class.getValue(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		}

	  	// Scan Currency
	  	for (Entry<String, String> entry_currency : map_currency.entrySet()) {
	  		instruction.addSymbolInput(entry_currency.getKey(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
	  		instruction.addSymbolInput(entry_currency.getValue(), EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		}

	}

	
	/*
	 * 
	 * Viene analizzato lo statement Repository.
	 * 
	 * Si tratta delle definizioni delle classi java utilizzate.
	 * 
	 */
	private void analyzeEnvRepository(InstructionCobolEnvironment instruction) throws ExceptionAmrita {
		// TODO analyzeEnvRepository
	}
	

	/*
	 * 
	 * Viene analizzato lo statement Select.
	 * 
	 */
	private void analyzeEnvSelect(InstructionCobolEnvironment instruction) throws ExceptionAmrita, SQLException {
		
		Scanner scn = null;
		ExceptionAmrita excp = null;  
	   	String ar_FileNameExternal[] = null;

		String sourceInstr = null;
		String str = "";
		String token = "";
		
		String fileNameInternal = "";
		String fileNamesExternal = "";
		String fileStatus1 = "";
		String fileStatus2 = "";
		String recordKey = "";
		String relativeKey = "";

		boolean isOrganizationIndexed = false;
		boolean isOrganizationSequential = false;
		boolean isOrganizationRelative = false;
		boolean isOrganizationLineSequential = false;
		boolean isAccessSequential = false;
		boolean isAccessRandom = false;
		boolean isAccessDynamic = false;

		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(6).toUpperCase(); 		// Elimino SELECT
		
		// Elimino le parole opzionali per comodita di gestione
		str = str.replace(" OPTIONAL "," ");
		str = str.replace(" ORGANIZATION "," ");
		str = str.replace(" TO "," ");
		str = str.replace(" IS "," ");
		str = str.replace(" KEY "," ");
		str = str.replace(" WITH "," ");
		str = str.replace(" FILE "," ");
		str = str.replace(" CHARACTER "," ");
		str = str.replace(" MODE "," ");
		str = str.replace(" WITH "," ");
        str = str.trim();
		scn = new Scanner(str);

        // Il file name inizia la stringa
		fileNameInternal = scn.next();								// Nome file interno
		str = str.substring(fileNameInternal.length()).trim();

        
		scn = new Scanner(str);
		token = nextToken(scn);
	
		// Scan words
		while (!token.equals("")) {

			// Clausola ASSIGN TO elenco external files
			if (token.equals("ASSIGN")) {
			    token = nextToken(scn);                 // Primo external name
                
			    if (token.startsWith("'")) {
					token=token.substring(1);
					token=token.substring(0, token.length() -1);
				}
			    
				// DYNAMIC
				if (token.equals("DYNAMIC")) {
					token = nextToken(scn);
				}

			    // Scan data record names
				while (!token.equals("")) {
					fileNamesExternal = fileNamesExternal + token + " ";
					token = nextToken(scn);
					// Parole di inizio clausole
					if (token.equals("STATUS")
					||  token.equals("RESERVE")	
					||  token.equals("ACCESS")	
					||  token.equals("PASSWORD")
					||  token.equals("RECORD")	
					||  token.equals("PADDING")	
					||  token.equals("SEQUENTIAL")	
					||  token.equals("INDEXED")	
					||  token.equals("RELATIVE")
					||  token.equals("LINE")
					||  token.equals("ALTERNATE")) {
					    break;
					}
				}
				ar_FileNameExternal = fileNamesExternal.split(" +");  // Regular expression
				continue;
			} 

			// Clausola ORGANIZATION IS SEQUENTIAL 
			if (token.equals("SEQUENTIAL")) {
				isOrganizationSequential = true;
				token = nextToken(scn);
				continue;
			}
			// Clausola ORGANIZATION IS INDEXED 
			if (token.equals("INDEXED")) {
				isOrganizationIndexed = true;
				token = nextToken(scn);
				continue;
			}
			// Clausola ORGANIZATION IS INDEXED 
			if (token.equals("RELATIVE")) {
				isOrganizationIndexed = true;
				token = nextToken(scn);
				continue;
			}
			// Clausola ORGANIZATION IS LINE SEQUENTIAL 
			if (token.equals("LINE")) {
				isOrganizationLineSequential = true;
				token = nextToken(scn);
				// Sorgente errato
				if (!token.equals("SEQUENTIAL")) {
					instruction.setParsingError(true);
                    break;
				}
				token = nextToken(scn);
				continue;
			}

			// Clausola ACCESS MODE
			if (token.equals("ACCESS")) {
				token = nextToken(scn);
				// SEQUENTIAL
				if (token.equals("SEQUENTIAL")) {
					isAccessSequential = true;
				}
				// RANDOM
				if (token.equals("RANDOM")) {
					isAccessRandom = true;
				}
				// DYNAMIC
				if (token.equals("DYNAMIC")) {
					isAccessDynamic = true;
				}
				token = nextToken(scn);
				// RELATIVE KEY
				if (token.equals("RELATIVE")) {
					token = nextToken(scn);
					relativeKey = token;
					token = nextToken(scn);
				}
				continue;
			}
			
			// Clausola FILE STATUS
			if (token.equals("STATUS")) {
				token = nextToken(scn);      // STATUS
				fileStatus1 = token;
				token = nextToken(scn);
				// Parole di inizio clausole
				if (token.equals("RESERVE")
				||  token.equals("ACCESS")	
				||  token.equals("PASSWORD")
				||  token.equals("RECORD")	
				||  token.equals("PADDING")	
				||  token.equals("SEQUENTIAL")	
				||  token.equals("INDEXED")	
				||  token.equals("RELATIVE")
				||  token.equals("LINE")
				||  token.equals("ALTERNATE")) {
				    token = nextToken(scn);
				    continue;
				}
				fileStatus2 = token;
				token = nextToken(scn);
				continue;
			}
	
			// Clausola RECORD KEY
			if (token.equals("RECORD")) {
				recordKey = nextToken(scn);
				token = nextToken(scn);
				continue;
			}
			
			// TODO alternateRecordKey

			
			// Non è l'inizio di una clausola gestita: skip
			token = nextToken(scn);
			 
		}
		
		
		// Errori di parsing
		if (instruction.isParsingError()) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_ENV_DIVISION);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
			return;

		}
		
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		// Nomi files interni ed esterni
		instruction.selectSetFileNameInternal(fileNameInternal);
		instruction.selectSetFileNamesExternal(ar_FileNameExternal);

		// File status
		instruction.selectSetFileStatus1(fileStatus1);
		instruction.selectSetFileStatus2(fileStatus2);

		// Opzioni
		instruction.selectSetOrganizationIndexed(isOrganizationIndexed);
		instruction.selectSetOrganizationSequential(isOrganizationSequential);
		instruction.selectSetOrganizationLineSequential(isOrganizationLineSequential);
		instruction.selectSetOrganizationLineSequential(isOrganizationLineSequential);
		instruction.selectSetOrganizationRelative(isOrganizationRelative);
		instruction.selectSetAccessSequential(isAccessSequential);
		instruction.selectSetAccessDynamic(isAccessDynamic);
		instruction.selectSetAccessRandom(isAccessRandom);
 		
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(fileNameInternal, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	if (!fileStatus1.equals("")) {
		  	instruction.addSymbolInput(fileStatus1, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	if (!fileStatus2.equals("")) {
		  	instruction.addSymbolInput(fileStatus2, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	if (!recordKey.equals("")) {
	  		instruction.addSymbolInput(recordKey, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	if (!relativeKey.equals("")) {
	  		instruction.addSymbolInput(relativeKey, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	// Scan external files
	  	for (int i = 0; i < ar_FileNameExternal.length; i++) {
	  		instruction.addSymbolInput(ar_FileNameExternal[i], EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
	  	
	  	
	  	////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
	  	this.analyzerDbInfo.getAddObjectEntitled(fileNameInternal, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameInternal
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefEnvDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );

	  	// Scan external files
	  	for (int i = 0; i < ar_FileNameExternal.length; i++) {
	  		    
	  		    // Potrebbe non essere stato definito nel programma (aggiunto dal compilatore)
	  		    hashSet_ImplicitData.add(ar_FileNameExternal[i]);
	  		     
	  		    // Relazione pgm --> External file
	       	    this.analyzerDbInfo.getAddObjectEntitled(ar_FileNameExternal[i], EnumObject.OBJECT_EXTERNAL_FILE);
				this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
												EnumObject.OBJECT_PGM_COBOL
											  , this.programName
										      , EnumObject.OBJECT_EXTERNAL_FILE
										      , ar_FileNameExternal[i]
										      , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
										      , EnumRelation.PGM_EXTERNAL_FILE
										      , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
										      , this.programName
										      , this.curNumDefEnvDiv
											  , instruction.getRowStartSource()
											  , instruction.getRowEndSource()
											  , ""
											  , 0
											  , 0
										      , instruction.getTypeInstrCategory()
										      , this.activeDivisionArea
										      , false
										      , false
										      , false
											  , this.di.userExitInfoPgm
										     );  
                
	  	}
		return;
	}


	
	/**
	 * 
	 * Analizza una singola istruzione di definizione dati fornita in input.<br>
	 * <p>
	 * Il metodo è concepito per essere attivato im modo generale da qualsiasi contesto.
	 * Infatti riceve come parametro un oggetto {@link InstructionCobolDataItem} con il sorgente
	 * dell'istruzione da parsare, che viene aggiornato con tutte le informazioni parsate.
	 * Eventuali anomalie ed errori di parsing vengono inseriti nell'istruzione e trattati dal chiamante.
	 * 
	 * 
	 * <p>
	 * @param InstructionCobolDataItem instruction
	 * @throws ExceptionAmrita 
	 */
	private void analyzeDataItemStmt(InstructionCobolDataItem instruction) throws ExceptionAmrita {
		
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;  			  // Mappato da una parola riservata Cobol
		ArrayList<InstructionCobolDataItem.InnerOccursKeyEntry> al_OccursKeyEntry = null; // Ascending key dataName1 Descending key dataName2 ... 
		ArrayList<String> al_OccursDataNameKey = null;                		   		 	  // Ascending/Descending key Is data-name1...data-namen
		ArrayList<String> al_OccursIndexName  = null;	    	  	           		  	  // Indexed By Index-name1 Index-name2 .....
		InstructionCobolDataItem.InnerOccursKeyEntry occursKey  = null;                   // Di servizio		
		ExceptionAmrita excp = null;													  // Per StackTrace suu parsing error	
        EnumCobolReservedWords en_ReservedWordExtracted = null;                           // Parola riservata cobol
        
		// Allocazione ArrayList di servizio
		al_OccursKeyEntry = new ArrayList<InstructionCobolDataItem.InnerOccursKeyEntry>();
		al_OccursDataNameKey = new ArrayList<String>();
		al_OccursIndexName = new  ArrayList<String>();
        
		LiteralCobol literalCobol = null;           // Descrittore e gestore literal cobol
		Scanner scn = null;							// Oggetto scanner per analisi parole
		String token = "";							// Token alfanumerico
		String sourceInstr = "";					// Sorgente istruzione
		String sourceAfterValue = "";				// Stringa dopo la parola riservata Value
		String stringValue = "";				    // Value con apici iniziali e finali
		int tokenInt = 0;							// Token numerico
		int iAfterLiteral = 0;                      // Prima posizione utile das parsare dopo literal alfanumerica 
		int iValue = 0;                             // Posizione inizio VALUE nell'istruzione
		int iLiteral = 0;                           // Posizione inizio literl ',"",X' etc. dopo VALUE o VALUE ALL
		int levelNumber = 0;						// Numero livello dsata item
		int i = 0;                                  // Di servizio

		
		sourceInstr = instruction.getSourceInstr();
		sourceInstr = replaceSpaceInLiteralWithUnderscore(instruction, sourceInstr);  	// Rendo le literal un unico token per una corretta gestione a token delle literal
 		sourceInstr = normalizeDataItemSource(instruction, sourceInstr);  
 		
 		//////////////////////////////// PROVVISORIO
 		sourceInstr=sourceInstr.replace("''", "");		
 		//////////////////////////////////////////
 		
 		// Elimina spazi fra parentesi
		scn = new Scanner(sourceInstr);
        

		/////////////////////////////////////////////////////////////////////////////
		// Analisi tokens istruzione di definizione dati
		/////////////////////////////////////////////////////////////////////////////
		
		// Numero e tipologia livello definizione dati
		levelNumber = scn.nextInt();					 
		instruction.setLevelNumber(levelNumber);
		switch (levelNumber) {
				case 77:
					instruction.setLevelType(EnumDataItemLevel.COBOL_DATA_ITEM_LEVEL_77);
					break;
				case 88:
					instruction.setLevelType(EnumDataItemLevel.COBOL_DATA_ITEM_LEVEL_88);
					break;
				case 66:
					instruction.setLevelType(EnumDataItemLevel.COBOL_DATA_ITEM_LEVEL_66);
					break;
				default:
					instruction.setLevelType(EnumDataItemLevel.COBOL_DATA_ITEM_LEVEL_OTHER);
					break;
		}
		
		
		// Definizione minimale, c'è solo il numero di livello e non può essere che un campo di gruppo
		if (!scn.hasNext()) {
			instruction.setGroupField(true);
			instruction.setItemType(EnumDataItemType.COBOL_GROUP);
			instruction.setUsage(EnumCobolUsage.USAGE_DISPLAY);
			return;
		} 
		
		// Data name o prima clausola, il data name può essere omesso
		token = nextToken(scn);

		// Se livello 88 si tratta certamente di un condition-name: viene analizzato separatamente
		if (levelNumber == 88) {
			instruction.setDataName(token);
			instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			analyzeDataItemStmtTokensConditionName(instruction, scn);
			instruction.setConditionClause(true);
			instruction.setItemType(EnumDataItemType.COBOL_CONDITION_NAME);
			return;
		}
		
		// recupero eventuale codifica come parola riservata
        al_reservedWordEntry = this.map_ReservedWords.get(token);
        en_ReservedWordExtracted = null;
        if (al_reservedWordEntry != null) {
        	en_ReservedWordExtracted = al_reservedWordEntry.get(0).en_WordReservedOwner;
		}
        
        // E' un data name, ovvero non è una parola riservata di inizio clausola
    	if (en_ReservedWordExtracted == null
    	||  en_ReservedWordExtracted.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_DATA_ITEM) {
			instruction.setDataName(token);
			instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			token = nextToken(scn);
			// Non ci sono altre clausole: campo di Gruppo
			if (token.equals("")) {
				instruction.setGroupField(true);
				instruction.setItemType(EnumDataItemType.COBOL_GROUP);
				return;
			}
		}

		
		
		// Scan Data Item Tokens
		
		do {

			// Il token è una virgola di separazione: bypass
			if (token.equals(",")) {
				continue;
			}
			

			//////////////////////////////////////////////////////////
			// Parsing Main clauses
			//////////////////////////////////////////////////////////
			
			// Redefines
			if (token.equals("REDEFINES")) {
				if (!scn.hasNext()) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				} 
				token = scn.next();
				instruction.setRedefinesClause(true);
				instruction.setRedefinesDataName(token);
				instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
				// Analisi copy trovato dentro un programma: deve esistere il campo ridefinito
				if ((this.programCobol != null)) {
					// Campo ridefinito non definito precedentemente: segnalazione errore
					if (!this.programCobol.isSymbolDataItem(token)) {
						instruction.setSemanticError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
						return;
					}
				}
				token = nextToken(scn);
			    continue;	
			}
	
			// Renames
			if (token.equals("RENAMES")) {
				if (!scn.hasNext()) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				} 
				token = scn.next();
				instruction.setRenamesClause(true);
				instruction.setRenamesDataName(token);
				// Analisi copy trovato dentro un programma: deve esistere il campo rinominatp
				if ((this.programCobol != null)) {
					// Campo rinominato non definito precedentemente: segnalazione errore
					if (!this.programCobol.isSymbolDataItem(token)) {
						instruction.setSemanticError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp,
								new String[] { this.programName });
						return;
					}
				}
				token = nextToken(scn);
				if (token.equals("THRU") || token.equals("THROUGH")) {
					token = nextToken(scn);
					instruction.setRenamesDataNameThru(token);
					instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
					// Analisi copy trovato dentro un programma: deve esistere il campo rinominatp
					if ((this.programCobol != null)) {
						// Campo rinominato non definito precedentemente: segnalazione errore
						if (!this.programCobol.isSymbolDataItem(token)) {
							instruction.setSemanticError(true);
							excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
							instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
							return;
						}
					}
					token = nextToken(scn);
				}
				continue;
			}  

			// Picture
			if (token.equals("PICTURE") 
			||  token.equals("PIC")  ) {
				if (!scn.hasNext()) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				} 
				token = scn.next();											// IS ?
				if (token.equals("IS")) {
					token = scn.next();
				}
				instruction.setPictureClause(true);
				instruction.setPicture(token);
				extractAndSetPictureInfo(instruction, token);
				// Errore nel parsing della picture
				if (instruction.isParsingError()) {
					return;
				}
				token = nextToken(scn);
				continue;
				 
			} // end-if picture
	      
			// Value
			if (token.equals("VALUE") || token.equals("VALUES")) {
				sourceInstr = sourceInstr + " ";
				iValue = sourceInstr.lastIndexOf(" VALUE");
				iLiteral = iValue + 6;
				if (token.equals("VALUES")) {iLiteral++;}
				iLiteral = StringService._firstNoSpace(sourceInstr, iLiteral);
				instruction.setValueClause(true);
				// Definizione incompleta
				if (!scn.hasNext()) {
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				} 
				token = scn.next();  
				// ALL
				if (token.equals("ALL")) {
					i = StringService._firstNoSpace(sourceInstr, iLiteral);
					iLiteral = i + 3;
					iLiteral = StringService._firstNoSpace(sourceInstr, iLiteral);
					instruction.setValueType(EnumCobolValueType.VALUE_LITERAL_ALPHA_ALL);
					token = nextToken(scn);
				// IS
				} else if (token.equals("IS")) {
					i = StringService._firstNoSpace(sourceInstr, iLiteral);
					iLiteral = i + 2;
					iLiteral = StringService._firstNoSpace(sourceInstr, iLiteral);
					token = nextToken(scn);
				}
				
				sourceAfterValue = sourceInstr.substring(iLiteral).trim() + "  ";
				literalCobol = new LiteralCobol();
				iAfterLiteral = literalCobol.parseLiteral(sourceInstr, iLiteral) + 1;
				  
				// Literal alfanumerica o esadecimale
				if (literalCobol.isLiteralString()) {
					// Literal non chiusa correttamente: value literal errata
					if (!literalCobol.isLiteralGood()) {
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", sourceAfterValue, excp, new String[]{"Value"});
						return;
					}   
					stringValue = sourceInstr.substring(iLiteral, iAfterLiteral);  
 					if (instruction.getValueType() != EnumCobolValueType.VALUE_LITERAL_ALPHA_ALL) {
						instruction.setValueType(literalCobol.getLiteralType());
					}
					// Ripristino lo scanner dal token dopo la literal di Value
					sourceAfterValue = sourceInstr.substring(iAfterLiteral).trim();
					scn = new Scanner(sourceAfterValue);
					instruction.setValueString(stringValue.replace('_', ' '));
					instruction.addSymbolDefinedInside(stringValue, EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
					token = nextToken(scn);
					continue;
				}
				// Literal numerica
				if (literalCobol.isLiteralNum() && literalCobol.isLiteralGood()) {
					instruction.setValueType(literalCobol.getLiteralType());
					instruction.setValueString(literalCobol.getLiteralInput());
					instruction.setValueNumeric(literalCobol.getValueInt());
					instruction.addSymbolDefinedInside(literalCobol.getLiteralInput(), EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
					token = nextToken(scn);
					continue;
				}
				
				// Può essere solo una costante figurativa
	            al_reservedWordEntry = this.map_ReservedWords.get(token);
	            en_ReservedWordExtracted = null;
	            if (al_reservedWordEntry != null) {
	            	en_ReservedWordExtracted = al_reservedWordEntry.get(0).en_WordReservedOwner;
				}
				// Token non trovato: sorgente corrotto
				if (en_ReservedWordExtracted == null) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{"Value"});
					return;
				}
				// Token non costante figurativa: sorgente corrotto
				if (en_ReservedWordExtracted.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_FIGURATIVE) {
					// Espressione costante figurativa errata
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Figurative Constant"});
					return;
				}
				// Costante figurativa corretta
				instruction.setValueType(EnumCobolValueType.VALUE_FIGURATIVE);
				instruction.setValueFigurative(en_ReservedWordExtracted.getCobolFigurative());
				instruction.setValueString(token);
				instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_FIGURATIVE);
				token = nextToken(scn);
				continue;
				
			} // end-if value
	
			
	
			//////////////////////////////////////////////////////////
			// Parsing Usage clause
			//////////////////////////////////////////////////////////
			
			// Usage
			if (token.equals("USAGE")) {
				if (!scn.hasNext()) {
					// Dati incompleti
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{""});
					return;
				}
	            token = scn.next();
				// Is è opzionale
				if (token.equals("IS")) {
					if (!scn.hasNext()) {
						// Dati incompleti
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{""});
						return;
					}
	                token = scn.next();
				}
				// Recupero enumerazione parola riservata tipologia usage
	            al_reservedWordEntry = this.map_ReservedWords.get(token);
	            en_ReservedWordExtracted = null;
	            if (al_reservedWordEntry != null) {
	            	en_ReservedWordExtracted = al_reservedWordEntry.get(0).en_WordReservedOwner;
				}
				// Clausola non trovata: sorgente corrotto
				if (en_ReservedWordExtracted == null) {
					// Clausola trovata errata: sorgente corrotto
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Usage"});
					return;
				}
				// Clausola trovata non è una usage: sorgente corrotto
				if (en_ReservedWordExtracted.getCobolUsage() == EnumCobolUsage.NOT_ASSIGNED) {
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Usage"});
					return;
				}
				// Valorizzazione clausola usage in definizione item
				instruction.setUsage(en_ReservedWordExtracted.getCobolUsage());
				instruction.setUsageClause(true);
				setItemTypeFromUsage(instruction);
				token = nextToken(scn);
				if (token.equals("NATIVE")) {
					token = nextToken(scn);
				}
				continue;
				
			} // end-if usage
	
			// Usage senza precedente keyword Usage
	        al_reservedWordEntry = this.map_ReservedWords.get(token);
	        en_ReservedWordExtracted = null;
	        if (al_reservedWordEntry != null) {
	        	en_ReservedWordExtracted = al_reservedWordEntry.get(0).en_WordReservedOwner;
	        	// Usage
	        	if (en_ReservedWordExtracted.getCobolUsage() != EnumCobolUsage.NOT_ASSIGNED ) {
					// Valorizzazione clausola usage in definizione item
					instruction.setUsage(en_ReservedWordExtracted.getCobolUsage());
					setItemTypeFromUsage(instruction);
					token = nextToken(scn);
					if (token.equals("NATIVE")) {
						token = nextToken(scn);
					}
					continue;
				}
			}
			
			
			//////////////////////////////////////////////////////////
			// Parsing Occurs clause
			//////////////////////////////////////////////////////////
			
			// Occurs
			if (token.equals("OCCURS")) {
				instruction.setOccursClause(true);
				if (!scn.hasNextInt()) {
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				}
				tokenInt = scn.nextInt();
				 
				instruction.setOccursNumber(tokenInt);
				instruction.addSymbolDefinedInside(tokenInt+"", EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
				instruction.addSymbolInput(tokenInt+"", EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
				
				token = nextToken(scn);
				// To opzionale
				if (token.equals("TO")) {
					if (!scn.hasNextInt()) {
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
						return;
					}
					tokenInt = scn.nextInt();
					instruction.setOccursNumberFrom(instruction.getOccursNumber());
					instruction.setOccursNumberTo(tokenInt);
					instruction.setOccursNumber(0);
					instruction.addSymbolDefinedInside(tokenInt+"", EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
					instruction.addSymbolInput(tokenInt+"", EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
					token = nextToken(scn);
				}
				// Times
				if (token.equals("TIMES") ) {
					token = nextToken(scn);
				}
				continue;
					
			} // end-if Occurs
	
			
			
			//////////////////////////////////////////////////////////
			// Parsing Depending On clause (di Occurs)
			//////////////////////////////////////////////////////////
			
			if (token.equals("DEPENDING")) {
				token = nextToken(scn);
				if (token.equals("ON") ) {
					token = nextToken(scn);
				}
				if (token.equals("")) {
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				}
				instruction.setOccursDependingOnDataName(token);
				instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
				token = nextToken(scn);
				if (token.equals("OF")) {
					token = nextToken(scn);
					token = nextToken(scn);
				}
				
				continue;
				
			}
				
			
			//////////////////////////////////////////////////////////
			// Parsing Ascending/Desecending key clause (di Occurs)
			//////////////////////////////////////////////////////////
			
			if (token.equals("ASCENDING") || token.equals("DESCENDING")) {
				
			    // Ascending/descending key is data-name1 data-name2 ...
	            while (token.equals("ASCENDING") || token.equals("DESCENDING")) {
	            	
	            	occursKey = instruction.new InnerOccursKeyEntry();
	            	
				    // Ascendinng
					if (token.equals("ASCENDING")) {
						occursKey.orderType = COBOL_OCCURS_ASCENDING_KEY;
						token = nextToken(scn);
					}
	   				if (token.equals("DESCENDING")) {
						occursKey.orderType = COBOL_OCCURS_DESCENDING_KEY;
						token = nextToken(scn);
					}
	 				if (token.equals("KEY")) {
						token = nextToken(scn);
	    				if (token.equals("IS")) {
	    					token = nextToken(scn);
	    				}
					}
					if (token.equals("IS")) {
						token = nextToken(scn);
					}
					token = deleteTrailingCharIfAny(token, ",");
	                while (!token.equals("") && !isStartDataItemClause(token)) {
	
	                	al_OccursDataNameKey.add(token);
	                	instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	                	token = nextToken(scn);
	                	token = deleteTrailingCharIfAny(token, ",");
	                	
					} // end-while  data-name1 data-name2 ...
	                
	                 occursKey.al_dataNameKey = al_OccursDataNameKey;
	              
	                 al_OccursKeyEntry.add(occursKey);
	                
				} // end-whileAscending/descending key
	            
	            instruction.setOccursKeys(al_OccursKeyEntry);
	            
	            continue;
			}
				
			//////////////////////////////////////////////////////////
			// Parsing Indexed By (di Occurs)
			//////////////////////////////////////////////////////////
			
			// Indexed By
			if (token.equals("INDEXED")) {
				token = nextToken(scn);
				if (token.equals("BY")) {
					token = nextToken(scn);
				}
				token = deleteTrailingCharIfAny(token, ",");
	            while (!token.equals("") && !isStartDataItemClause(token)) {
	            	
	            	al_OccursIndexName.add(token);
	            	instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	               	instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
	           	    token = nextToken(scn);
	           	    token = deleteTrailingCharIfAny(token, ",");
	             	
				} // end-while Indexed By
	            
	            instruction.setOccursIndexNames(al_OccursIndexName);
	            
	            continue;
	            
			} // end-if Indexed By
				
			
			
			//////////////////////////////////////////////////////////
			// Parsing Optional clauses
			//////////////////////////////////////////////////////////
			
			// Blank when zero
			if (token.equals("BLANK")) {
				if (!scn.hasNext()) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
					return;
				} 
				token = scn.next();
				if (token.equals("WHEN")) {
					if (!scn.hasNext()) {
						// Definizione incompleta
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
						return;
					} 
					token = scn.next();
				}
				instruction.setBlankWhenZeroClause(true);
				if (token.equals("ZERO") 
				||  token.equals("ZEROS") 
				||  token.equals("ZEROES")
				   ) {
					token = nextToken(scn);
					continue;
				}
				
			}
			
			// External
			if (token.equals("EXTERNAL")) {
				instruction.setExternalClause(true);
				token = nextToken(scn);
				continue;
			}
			
			// Global
			if (token.equals("GLOBAL")) {
				instruction.setGlobalClause(true);
				token = nextToken(scn);
				continue;
			}
			
			// Justified
			if (token.equals("JUSTIFIED")
			||  token.equals("JUST")) {
				token = nextToken(scn);
				instruction.setJustifiedClause(true);
				if (token.equals("RIGHT")) {
					instruction.setJustifiedType(COBOL_JUSTIFIED_RIGHT);
					token = nextToken(scn);
				}
				continue;
			}
	        
			// Sign
			if (token.equals("SIGN")
			||  token.equals("LEADING")
			||  token.equals("TRAILING") ) {
				instruction.setSignClause(true);
				if (token.equals("SIGN")) {
					if (!scn.hasNext()) {
						// Definizione incompleta
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
						return;
					} 
					token = scn.next();
					if (token.equals("IS")) {
						if (!scn.hasNext()) {
							// Definizione incompleta
							instruction.setParsingError(true);
							excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
							instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
							return;
						} 
						token = scn.next();
					}
				}
				if (token.equals("LEADING")) {
					instruction.setSignType(COBOL_SIGN_LEADING);
				}
				if (token.equals("TRAILING")) {
					instruction.setSignType(COBOL_SIGN_TRAILING);
				}
				token = nextToken(scn);
				if (token.equals("SEPARATE")) {
					instruction.setSignSeparateCharacter(true);
					token = nextToken(scn);
					if (token.equals("CHARACTER")) {
						token = nextToken(scn);
					}
				}
				continue;
			}
			
			// Syncronized
			if (token.equals("SYNCRONIZED")
			||  token.equals("SYNC") ) {
				instruction.setSincronizedClause(true);
				token = nextToken(scn);
				if (token.equals("LEFT") ) {
					instruction.setSincronizedType(COBOL_SYNCRONIZED_LEFT);
					token = nextToken(scn);
				}
				if (token.equals("RIGHT") ) {
					instruction.setSincronizedType(COBOL_SYNCRONIZED_RIGHT);
					token = nextToken(scn);
				}
				continue;
			}
			
	        // Parola chiave non riconosciuta: istruzione incompleta o malformata
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
			return;
			
		} while (!token.equals(""));  // end-for Scan Data Item Tokens
		
		
	  	// Fine parsing senza errori

		
        
		// Update size campo in bytes campo numerico
		if (instruction.getUsage() != EnumCobolUsage.USAGE_DISPLAY
		&&  instruction.getUsage() != EnumCobolUsage.USAGE_DISPLAY_1) {
			instruction.setSizeBytes(instruction.getUsage().getLengthBytes(instruction.getNumInt() + instruction.getNumDec()));
		} else {
			// Campo zoned usage display, la dimensione è data dalla picture
			if (instruction.getNumInt() > 0 || instruction.getNumDec() > 0) {
				instruction.setSizeBytes(instruction.getNumInt() + instruction.getNumDec());
			}
		}
		
		// Non può essere un campo di gruppo
		if (instruction.isPictureClause()
		||  instruction.isUsageClause()		
		||  instruction.isValueClause()) {
			return;
		}
		
		// E' un campo di gruppo, anche se con occurs e/o redefines
		instruction.setGroupField(true);
		return;
	}
	
	
    /*
     * Impostazione tipologia generale item in base alla usage Cobol
     * 
     */
	private void setItemTypeFromUsage(InstructionCobolDataItem instr) {

		switch (instr.getUsage()) {
		case USAGE_DISPLAY:
			instr.setItemType(EnumDataItemType.COBOL_DISPLAY);
			break;
		case USAGE_DISPLAY_1:
			instr.setItemType(EnumDataItemType.COBOL_DISPLAY);
			break;
		case USAGE_INDEX:
			instr.setItemType(EnumDataItemType.COBOL_INDEX);
			break;
		case USAGE_POINTER:
			instr.setItemType(EnumDataItemType.COBOL_POINTER);
			break;
		case USAGE_FUNCTION_POINTER:
			instr.setItemType(EnumDataItemType.COBOL_POINTER);
			break;
		case USAGE_PROCEDURE_POINTER:
			instr.setItemType(EnumDataItemType.COBOL_POINTER);
			break;
		case USAGE_BINARY:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMPUTATIONAL:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMPUTATIONAL_1:
			instr.setItemType(EnumDataItemType.COBOL_FLOATING);
			break;
		case USAGE_COMP_1:
			instr.setItemType(EnumDataItemType.COBOL_FLOATING);
			break;
		case USAGE_COMPUTATIONAL_2:
			instr.setItemType(EnumDataItemType.COBOL_FLOATING);
			break;
		case USAGE_COMP_2:
			instr.setItemType(EnumDataItemType.COBOL_FLOATING);
			break;
		case USAGE_COMPUTATIONAL_3:
			instr.setItemType(EnumDataItemType.COBOL_PACKED);
			break;
		case USAGE_COMP_3:
			instr.setItemType(EnumDataItemType.COBOL_PACKED);
			break;
		case USAGE_PACKED_DECIMAL:
			instr.setItemType(EnumDataItemType.COBOL_PACKED);
			break;
		case USAGE_COMPUTATIONAL_4:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMP_4:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMPUTATIONAL_5:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMP_5:
			instr.setItemType(EnumDataItemType.COBOL_BINARY);
			break;
		case USAGE_COMP_X:
			instr.setItemType(EnumDataItemType.COBOL_ZONED);
			break;

		default:
			break;
		}
		
		return;
	}


	/*
	 * --------------------------------------------------
	 *  Analisi definizione di condition name Cobol
	 * --------------------------------------------------
	 * 
	 *  Gestisce 88 cond-name value A B C 
	 *  Gestisce 88 cond-name value A B, C Thru D E F G THRU H
	 * 
	 */	
	private void analyzeDataItemStmtTokensConditionName(InstructionCobolDataItem instruction, Scanner scn) throws ExceptionAmrita {
	    
		ExceptionAmrita excp = null;  
		
		InstructionCobolDataItem.InnerConditionValueEntry conditionValueEntry = null;     			// Singolo condition name in livello 88
		ArrayList<InstructionCobolDataItem.InnerConditionValueEntry> al_ConditionValueEntry = null;	// Condizioni livelli 88        

	    String token = "";
		String token2 = "";
		
		al_ConditionValueEntry = new ArrayList<InstructionCobolDataItem.InnerConditionValueEntry> ();
		
		// Value/Values
		if (!scn.hasNext()) {
			// Definizione incompleta
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			return;
		} 
		token = scn.next();
		
		
		if (!token.equals("VALUE") && !token.equals("VALUES") ) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Value/Values Condition name"});
            return;											 
		}
		
		if (!scn.hasNext()) {
			// Definizione incompleta
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
			return;
		} 
		token = scn.next();
		
		// Is / Are
		if (token.equals("IS") || token.equals("ARE") ) {
			if (!scn.hasNext()) {
				// Definizione incompleta
				instruction.setParsingError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
				return;
			} 
			token = scn.next();
		}
		
		// Ora è disponibile la prima literal condizione
		 
		// Scan Data Item condition names Tokens
		while (!token.equals("")) {
			
			    if (token.equals(",")) {
			    	token = nextToken(scn);
					continue;
				}
		    
			    token = deleteTrailingCharIfAny(token, ",");
			    token = deleteLeadingCharIfAny(token, ",");

			    conditionValueEntry = instruction.new InnerConditionValueEntry();
			    
			    token2 = nextToken(scn);
			    
			    // Caso A Thru B
			    if (token2.equals("THRU") || token2.equals("THROUGH")) {
					if (!scn.hasNext()) {
						// Definizione incompleta
						instruction.setParsingError(true);
						excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
						instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", "", excp, new String[]{this.programName});
						return;
					} 
					token2 = scn.next();
                    token2 = deleteTrailingCharIfAny(token2, ",");
					
			    	// Analizza e Memorizza entry A thru B
				    storeEntryCondition(instruction, COBOL_CONDITION_NAME_FROM, token, conditionValueEntry);
				    if (instruction.isParsingError()) {return;};
				    storeEntryCondition(instruction, COBOL_CONDITION_NAME_TO,  token2, conditionValueEntry);
				    if (instruction.isParsingError()) {return;};
				    al_ConditionValueEntry.add(conditionValueEntry);
			    	token = nextToken(scn);
			    	token = deleteTrailingCharIfAny(token, ",");
			    	continue;
				}

			    // Memorizza entry singolo A relativo a token
			    storeEntryCondition(instruction, COBOL_CONDITION_NAME_FROM, token, conditionValueEntry);
			    
			    // token2 diventa il nuovo token in ciclo
			    token = token2;
		}
		
		// Memorizzo i nomi condizione nel data item in corso di analisi
		instruction.setConditionValues(al_ConditionValueEntry);
		return;
	}

	
	/*
	 * 
	 * Viene analizzato lo statement Fd/Sd.
	 */
    private void analyzeDataFdSd(String typeInstr, InstructionCobolDataStruct instruction) throws ExceptionAmrita, SQLException {

		Scanner scn = null;
		ArrayList<String> al_dataRecord = null;
		ArrayList<DataItemCobolIdentifier> al_identifierInput = null;
		ArrayList<DataItemCobolIdentifier> al_identifierWork = null;

		String sourceInstr = null;
		String str = "";
		String token = "";
		String fileNameInternal = "";
		String recordBytesFrom = "";
		String recordBytesTo = "";
		String recordBytesDependingOn = "";
		String recordingMode = "";
        String blockFrom = "";
        String blockTo = "";
		boolean isExternal = false;
		boolean isGlobal = false;
		boolean isBlockCharacters = false;
		boolean isBlockRecords = false;

		
		al_dataRecord = new ArrayList<String> ();
		al_identifierInput = new ArrayList<DataItemCobolIdentifier> ();
		al_identifierWork = new ArrayList<DataItemCobolIdentifier> ();
        
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(2).trim().toUpperCase(); 		// Elimino FD/SD
		str = str.replace(","," ");									// Elimino eventuali virgole

		scn = new Scanner(str);
		fileNameInternal = scn.next();
		str = str.substring(fileNameInternal.length()).trim();

		// Elimino le parole opzionali per comodita di gestione e normalizzo ,
		str = str.replace(" CONTAINS "," ");
		str = str.replace(" MODE "," ");
		str = str.replace(" IS "," ");
		str = str.replace(" ARE "," ");
		str = str.replace(" IN "," ");
		str = str.replace(" ON "," ");
		str = str.replace(" SIZE "," ");
		str = str.replace(" FROM "," ");
        str = str.trim();
        
		scn = new Scanner(str);
		token = nextToken(scn);
		
		// Scan words
		while (!token.equals("")) {
			
			// Clausola EXTERNAL 
			if (token.equals("EXTERNAL")) {
				token = nextToken(scn);
				isExternal = true;
				continue;
			}

			// Clausola GLOBAL 
			if (token.equals("GLOBAL")) {
				token = nextToken(scn);
				isGlobal = true;
				continue;
			}

			// Clausola LABEL: non viene gestita
			if (token.equals("LABEL")) {
				token = nextToken(scn);                 // Record o Records 
				token = nextToken(scn);   	            // Standard/Omitted
				token = nextToken(scn); 
				continue;
			}
			
			// Clausola BLOCK
			if (token.equals("BLOCK")) {
				blockFrom = nextToken(scn);             // 
				token = nextToken(scn); 				// Eventuale To o Characters o Records
				if (token.equals("TO")) {
					blockTo = nextToken(scn);           // 
					token = nextToken(scn); 
				}
				if (token.equals("CHARACTERS")) {
					isBlockCharacters = true;
				}
				if (token.equals("RECORDS")) {
					isBlockRecords = true;
				}
				token = nextToken(scn); 				// Next word da trattare
				continue;
			}
			
			// Clausola RECORD
			if (token.equals("RECORD")) {
				token = nextToken(scn);                 // Bypass Record
				// Record Varying
			    if (token.equals("VARYING")) {
				    token = nextToken(scn);
				    // Clausola Varying senza parametri
				    if (!StringService._isNumeric(token) && !token.equals("DEPENDING")) {
						continue;
					}
				    // Varying From integer
				    if (StringService._isNumeric(token)) {
				    	recordBytesFrom = token;
					  	al_identifierWork = extractIdentifiers(instruction, recordBytesFrom);
					  	al_identifierInput.addAll(al_identifierWork);
					}
				    token = nextToken(scn);             // Eventuale To o Depending
				    if (token.equals("TO")) {
				    	recordBytesTo = nextToken(scn); 
					  	al_identifierWork = extractIdentifiers(instruction, recordBytesTo);
					  	al_identifierInput.addAll(al_identifierWork);
				    	token = nextToken(scn);
					}
					if (token.equals("DEPENDING")) {
					    recordBytesDependingOn = nextToken(scn); 
					  	al_identifierWork = extractIdentifiers(instruction, recordBytesDependingOn);
					  	al_identifierInput.addAll(al_identifierWork);
					    token = nextToken(scn);
				    }
					continue;				// Riesamina in ciclo
				} 
			    // Record Contains
			    recordBytesFrom = token;
			  	al_identifierWork = extractIdentifiers(instruction, token);
			  	al_identifierInput.addAll(al_identifierWork);
			    token = nextToken(scn);
			    if (token.equals("TO")) {
			    	recordBytesTo = nextToken(scn);
				  	al_identifierWork = extractIdentifiers(instruction, recordBytesTo);
				  	al_identifierInput.addAll(al_identifierWork);

			    	token = nextToken(scn);
				}
			    continue;   // Rianalizza in ciclo
			    
			}

			// Clausola RECORDING MODE: viene gestita
			if (token.equals("RECORDING")) {
				recordingMode = nextToken(scn);         // F/V
			    token = nextToken(scn);                 // Next Word
				continue;								// Rianalisi in ciclo
			} 

			// Clausola DATA RECORD / RECORDS: viene gestita
			if (token.equals("DATA")) {
				token = nextToken(scn);                 // Record/Records
			    token = nextToken(scn);                 // Primo data record
			    
			    // Scan data record names
				while (!token.equals("")) {
					al_dataRecord.add(token);
				  	al_identifierWork = extractIdentifiers(instruction, token);
				  	al_identifierInput.addAll(al_identifierWork);
					token = nextToken(scn);
					// Parole di inizio clausole
					if (token.equals("LINAGE")
					||  token.equals("BLOCK")
					||  token.equals("RECORD")
					||  token.equals("LABEL")
					||  token.equals("VALUE")
					||  token.equals("LINES")
					||  token.equals("LINAGE")
					||  token.equals("CODE-SET")
					||  token.equals("RECORDING")) {
					    break;					// Torna nel ciclo principale
					}
				}
				continue;
			} 
			
			// Non è l'inizio di una clausola gestita: skip
			token = nextToken(scn);
			 
		}
		
		// I campi indicati non sono ancora stati definiti
		instruction.setSemanticError(false);				
		
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
    	if (isExternal) {
			instruction.fdSetExternal(true);
		}
    	if (isGlobal) {
			instruction.fdSetGlobal(true);
		}
     	if (!recordingMode.equals("")) {
			instruction.fdSetRecordingMode(recordingMode);
			instruction.addSymbolInput(recordingMode, EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
		}
     	if (!recordBytesFrom.equals("")) {
     		instruction.fdSetRecordBytesFrom(recordBytesFrom);
			instruction.addSymbolInput(recordBytesFrom, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
		}
     	if (!recordBytesTo.equals("")) {
	   		instruction.fdSetRecordBytesTo(recordBytesTo);
			instruction.addSymbolInput(recordBytesTo, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
		}
    	if (!recordBytesDependingOn.equals("")) {
	   		instruction.fdSetRecordBytesDependingOn(recordBytesDependingOn);
			instruction.addSymbolInput(recordBytesDependingOn, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
    	if (!blockFrom.equals("")) {
    		instruction.fdSetBlockFrom(blockFrom);
    		if (StringService._getNumericInt(blockFrom) == 0) {
    			instruction.fdSetBlockZero(true);
			}
			instruction.addSymbolInput(blockFrom, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
		}
    	if (!blockTo.equals("")) {
    		instruction.fdSetBlockTo(blockTo);
			instruction.addSymbolInput(blockTo, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
		}
    	if (isBlockCharacters) {
	   		instruction.fdSetBlockChar(isBlockCharacters);
		}
    	if (isBlockRecords) {
    		instruction.fdSetBlockRecords(isBlockRecords);
		}
    	// Array di nomi di Data Records definiti per il file
    	instruction.fdSetDataRecords(al_dataRecord);
       	instruction.fdSetFileNameInternal(fileNameInternal);
   
    	
		////////////////////////////////////////////////////////////////////
		// Caricamento campi definiti e utilizzati in input 
		////////////////////////////////////////////////////////////////////
		
	  	instruction.addSymbolInput(fileNameInternal, EnumSymbolType.COBOL_SYMBOL_INTERNAL_FILE);
	  	
	  	// Scan identificatori intercettati
		for (DataItemCobolIdentifier innerIdentifier : al_identifierInput) {
			addInstructionSymbolsUsedAndDefined(instruction, innerIdentifier, COBOL_DATA_ITEM_USED_INPUT);
		}

	  	
	  	////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////

	  	this.analyzerDbInfo.getAddObjectEntitled(fileNameInternal, EnumObject.OBJECT_INTERNAL_FILE);
		this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
     									EnumObject.OBJECT_PGM_COBOL
				  					  , this.programName
									  , EnumObject.OBJECT_INTERNAL_FILE
									  , fileNameInternal
									  , EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED
									  , EnumRelation.PGM_INTERNAL_FILE
									  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
									  , this.programName
									  , this.curNumDefDataDiv
									  , instruction.getRowStartSource()
									  , instruction.getRowEndSource()
									  , ""
									  , 0
									  , 0
									  , instruction.getTypeInstrCategory()
									  , this.activeDivisionArea
									  , false
									  , false
									  , false
									  , this.di.userExitInfoPgm
									   );
 		return;
	}

     
	/*
	 * -------------------------------------------------------
	 * Viene analizzato lo statement di precompilatore Cics.
	 * -------------------------------------------------------
	 * 
	 * 
	 * L'istruzione viene analizzata e tutti gli operandi, le opzioni e condizioni
	 * aggiornano l'oggetto InstructionPrecompiler fornito in input.
	 * Vengono anche aggiornate le strutture dell'istruzione con i simboli
	 * in input, output e definiti inside.
	 * 
	 * I cross reference ai simboli sono aggiornati solo per gli operandi utili
	 * all'inserimento di oggetti e relazioni.
	 * 
	 */
 	private void analyzePrecompilerCics(InstructionCics instruction) throws ExceptionAmrita, SQLException {
      	
    	DataItemCobolIdentifier ar_identifierInput[] = null;                // Identificatori operanfì di di input nell'istruzione
    	DataItemCobolIdentifier ar_identifierOutput[] = null;               // Identificatori operanfì di di output nell'istruzione
    	
 		// Opzione di programma con codice Cics
		EntityObjectOption entityObjectOption = new EntityObjectOption();
		entityObjectOption.setSystem(this.di.systemInput);
		entityObjectOption.setSubSystem(this.di.subSystemInput);
		entityObjectOption.setIdObject(this.pgmNameUnderParsing);
		entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
		entityObjectOption.setOption(EnumObjectOption.PGM_CICS);
		analyzerDbInfo.addObjEntityOption(entityObjectOption);

        // Indicazione di programma Cics
		this.programCobol.setCicsProgram(true);		
		
    	// Il parsing è gestito dall'analizzatore specializzato
		// Se l'istruzione è dinamica dopo l'analisi formale dell'istruzione
		// vengono inseriti gli estremi nella tabella EntityDynamicField (DFLD)
    	this.analyzerCics.analyzeCicsInstruction(instruction);

       	// Operando non definito, errore sintassi o semantico
       	if (instruction.isParsingError() || instruction.isSemanticError()) {
			return;
		}
       	
       	// Soluzione istruzione solo se statica, inserimento oggetti e relazioni su db.
       	// Se istruzione dinamica la soluzione viene effettuata SOLO a fine analisi in quanto 
       	// per l'analisi dinamica tutte le istruzioni del programma devono essere analizzate.
       	if (!instruction.isDynamic()) {
       		instruction.setNumInstr(this.curNumDefProcDiv);
       	    this.analyzerCics.solveInstruction(instruction, LOGIC_DYNAMIC_SAME_PGM);	
		}   	
 
       	// Operando incongruente, come Cics Start Map(..) 
       	if (instruction.isSemanticError()) {
			return;
		}

       	// Estrazione identificatori utilizzati in input e in output
      	ar_identifierInput = instruction.getOperandsInput();
      	ar_identifierOutput = instruction.getOperandsOutput();
       	
      	// Scan operandi in input e inserimento XREF campo ed eventiuali sottocampi
      	for (DataItemCobolIdentifier identifierInput : ar_identifierInput) {
      		addInstructionSymbolsUsedAndDefined(instruction, identifierInput, COBOL_DATA_ITEM_USED_INPUT);
      		addInstructionSymbolsUsedAndDefinedGroup(instruction, identifierInput, INSTR_USE_DATA_ITEM_INPUT);
		}
       	
      	// Scan operandi in output e inserimento XREF campo ed eventiuali sottocampi
      	for (DataItemCobolIdentifier identifierOutput : ar_identifierOutput) {
      		addInstructionSymbolsUsedAndDefined(instruction, identifierOutput, COBOL_DATA_ITEM_USED_OUTPUT);
      		addInstructionSymbolsUsedAndDefinedGroup(instruction, identifierOutput, INSTR_USE_DATA_ITEM_OUTPUT);		
		}
       	
 		return;
	}

    
	/* -----------------------------------------------------
	 * Viene analizzato lo statement di precompilatore Sql
	 * -----------------------------------------------------
	 * 
	 * Viene analizzata solo Exec SQl Include, assimilandola a una copy.
	 * Le altre istruzioni sql vengono analizzate dall'analizzatore Sql
	 * specifico.
	 * 
	 */
    private void analyzePrecompilerSql(InstructionSql instruction) throws ExceptionAmrita, SQLException {
    	
    	Scanner scn = null;
     	String token = "";
     	String token1 = "";
       	String sourceInstr = "";
       	String sourceInstrOrigin = "";
    	String includeName = "";   	
    	
		// Indicazione di programma Sql
       if (this.programCobol != null) {
			this.programCobol.setSqlProgram(true);
			// Opzione di programma con codice dinamico
			EntityObjectOption entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.pgmNameUnderParsing);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_DB2);
			analyzerDbInfo.addObjEntityOption(entityObjectOption);
		}
		sourceInstr = instruction.getSourceInstr().trim();
    	
    	scn = new Scanner(sourceInstr);
    	token = nextToken(scn);					// EXEC
    	token = nextToken(scn);					// SQL
    	token = nextToken(scn);					// INCLUDE ? BEGIN/END ?
    	token1 = nextToken(scn);			    // TableName ? DECLARE ?
    	
    	// INCLUDE è gestito come un copy
    	if (token.equals("INCLUDE")) {
    	   	instruction.setTypeInstrPrecompiler(EnumPrecompilerReservedWords.SQL_INCLUDE);
    	   	instruction.setTypePrecompiler(EnumInstrDataCategory.SQL_PRECOMPILER);;
           	includeName = token1;						// nameInclude
           	if (includeName.startsWith("'")) {
           		includeName = includeName.substring(1);
           		includeName = includeName.substring(0, includeName.length() - 1);
			}
           	instruction.sqlIncludeSetName(includeName);
			return;
		}
        
    	
    	sourceInstrOrigin = sourceInstr;										// Save 
    	
    	// Eliminazione EXEC SQL e END-EXEC
    	sourceInstr = sourceInstr.substring(5).trim();							// Elimino EXEC
    	sourceInstr = sourceInstr.substring(4).trim();							// Elimino SQL
    	sourceInstr = deleteTrailingCharIfAny(sourceInstr, ".").trim();			// Elimino eventuale punto
    	sourceInstr = sourceInstr.substring(0, sourceInstr.length() - 8);		// Elimino END-EXEC
    	instruction.setSourceInstr(sourceInstr);
    	instruction.setTypePrecompiler(EnumInstrDataCategory.SQL_PRECOMPILER);
    	if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
        	instruction.setNumInstr(this.curNumDefProcDiv);
		} else {
			instruction.setNumInstr(this.curNumDefDataDiv);
		}
     	this.analyzerSql.analyzeSqlInstruction(instruction);					// Attivazione analizzatore Sql
    	
    	instruction.setSourceInstr(sourceInstrOrigin);							// Restore

      	return;
	}

	/*
	 * ------------------------------
	 * Analisi PROGRAM-ID. statement.
	 * ------------------------------
	 * 
	 */
	private void analyzeProgramIdStmt(InnerContextAnalysis ictx, InstructionCobol instruction) throws ExceptionAmrita {
		
 		String sourceInstr = null;				// Source completo istruzione senza punto
		String programName = "";				// Nome programma
	
		sourceInstr = instruction.getSourceInstr();
		programName = sourceInstr.substring(11).trim(); 					// Eliminazione PROGRAM-ID.
		this.programCobol.setProgramId(programName);
	}
		 
	
	/*
	 * ---------------------------------------
	 * Analisi copy statement (di PROC/DATA)
	 * ---------------------------------------
	 * 
	 * Viene fornito un oggetto istruzione generico, in quanto l'istruzione
	 * copy può trovarsi in qualsiasi divisione di programma.
	 * 
	 */
	private void analyzeCopyStmt(InnerContextAnalysis ictx, InstructionCobol instruction, EnumObject typeCopyObject) throws ExceptionAmrita, SQLException {
		
    	EntityObject eo = null;
        ExceptionAmrita excp = null;
		InstructionCobol.InnerReplacingByEntry copyReplacingByEntry = null;  					// Singolo replacing By definito in statement copy
		ArrayList<InstructionCobol.InnerReplacingByEntry> al_CopyReplacingByEntry = null;	    // Insieme di Replacing x BY y   
		Scanner scn = null;						// Scanner gestione tokens
		String sourceInstr = null;				// Source completo istruzione senza punto
		String str = "";						// Work
		String token = "";						// Singolo token istruzione
		String copyName = "";					// Nome copy
		String copyLibraryName = "";			// Libreria in cui ceracre il copy
	    String copyValueToFind = null;			// Estratto da Replacing  
		String copyValueToReplace = null;		// Estratto da Replacing  
		char doubleApice = 34;                  // ""
		int numInstrOrDef = 0;                  // Numero istruzione di procedure division o numero definizione di data division
		boolean isSuppress = false;				// Presenza clausola suppress nell'istruzione
        
		// Utile per sapere da quale sys/subsys il copy proviene già dall'istruzione copy
		instruction.setSysOwner(this.di.systemInput);
		instruction.setSubSysOwner(this.di.subSystemInput);
		
		al_CopyReplacingByEntry = new ArrayList<InstructionCobol.InnerReplacingByEntry> ();
		
		sourceInstr = instruction.getSourceInstr();
		str = sourceInstr.substring(4).trim(); 								// Eliminazione Copy iniziale
		str = normalizeInstructioCopy(instruction, str);                    // Replace space in literal e delimiter con _ (undersore)
		
		// Errore in apertura/chiusura sringhe e delimiter
		if (instruction.isParsingError()) {
			return;
		}
		
		scn = new Scanner(str);
		copyName = scn.next();
		
		// Copy espresso da literal: elimino apici
		if (copyName.startsWith("'") || copyName.startsWith(Character.toString(doubleApice))) {
			copyName = copyName.substring(1, copyName.length() - 1);
		}

		
		token = nextToken(scn);						// Token ahead

		// Scan tokens
		while (!token.equals("")) {
			
			// Clausola OF/IN Library 
			if (token.equals("OF") || token.equals("IN")) {
				token = nextToken(scn);                      // Bypass OF/IN
				if (token.equals("")) {
					instruction.setParsingError(true);
					break;
				}
				copyLibraryName = token;
				// Library espressa da literal: elimino apici
				if (copyLibraryName.startsWith("'") || copyLibraryName.startsWith(Character.toString(doubleApice))) {
					copyLibraryName = copyLibraryName.substring(1, token.length() - 1);
				}
				token = nextToken(scn);	
				continue;
			}
			
			// Clausola SUPPRESS
			if (token.equals("SUPPRESS")) {
				isSuppress = true;
				token = nextToken(scn);
				continue;
			}

			// Clausola REPLACING
			if (token.equals("REPLACING")) {
				token = nextToken(scn);
				if (token.equals("")) {
					instruction.setParsingError(true);
					break;
				}

				copyReplacingByEntry = instruction.new InnerReplacingByEntry();
				
				// Scan Data Item Tokens
				while (!token.equals("")) {
					
					copyValueToFind = token;
					
					token = nextToken(scn);        // BY
					if (!token.equals("BY")) {
		   				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_COPY);
	    				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0042", token, excp, this.programName);
						instruction.setParsingError(true);
						break;
					}

					token = nextToken(scn);
					if (token.equals("")) {
		   				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_COPY);
	    				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0042", token, excp, this.programName);
						instruction.setParsingError(true);
						break;
					}
					
					copyValueToReplace = token;
					
					// Store in entry eliminando eventuali _ immessi in normalizzazione, apici di literal e delimiter
					copyReplacingByEntry.valueToFind = copyValueToFind.replace('_', ' ').replace("=", " ").trim();
					copyReplacingByEntry.valueToReplace = copyValueToReplace.replace('_', ' ').replace("'", " ").replace(Character.toString(doubleApice), " ").replace("=", " ").trim();
					
					// Append entry & prepare for any next
					al_CopyReplacingByEntry.add(copyReplacingByEntry);
					copyReplacingByEntry = instruction.new InnerReplacingByEntry();
					
					// In loop getting token
					token = nextToken(scn);
		 		}
				
			} // end-if
			
			// Clausola non prevista
			token = nextToken(scn);
		}	
		
		

		  
		////////////////////////////////////////////////////////////////////
		// Caricamento Descriptor istruzione con opzioni e strutture dati
		////////////////////////////////////////////////////////////////////
		
		// Suppress
	   	if (isSuppress) {
			instruction.addOption("SUPPRESS");
		}
	   	// Library
	   	if (!copyLibraryName.equals("")) {
			instruction.copySetLibrary(copyLibraryName);
		}
    	// Copy name
       	instruction.copySetName(copyName);
       	 
    	// Replacing
       	if (al_CopyReplacingByEntry.size() > 0) {
       		al_CopyReplacingByEntry.trimToSize();
          	instruction.copySetReplacingBy(al_CopyReplacingByEntry);
		}
 
		
       	////////////////////////////////////////////////////////////////////
		// Caricamento per inserimento finale su db 
		////////////////////////////////////////////////////////////////////
       	
       	// Numero istruzione COPY
		if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
			 numInstrOrDef = this.curNumDefProcDiv;
	    } else if (this.activeDivisionArea == EnumCobolReservedWords.DATA_DIVISION)  {
			 numInstrOrDef = this.curNumDefDataDiv;
		} else {
			 numInstrOrDef = this.curNumDefEnvDiv;
		}
      
        // L'nserimento della relazione e dell'oggetto relazionato viene effettuato dal chiamante
		
		// Non è un copy NESTED: return
		if (ictx.copyNestinglevel == 0) {
			return;
		}
		
		// Copy NESTED: si inserisce relazione COPY-COPY ed eventualmente l'oggetto relazionato 
		copyIncludeAddObjectAndRelation(ictx.copyNameCaller, EnumRelation.COPY_COPY, typeCopyObject, copyName, "", numInstrOrDef, instruction.getTypeInstrCategory(), instruction);
		return;


	}
    
	/*
	 * Completamento operazioni per copy, inserimento relazioni, oggetto copy relazionato
	 * Metodo richiamato anche a fronte di SQL INCLUDE in procedure division
	 */
    private EntityObject copyIncludeAddObjectAndRelation(String idObjectA, EnumRelation relation, EnumObject typeCopyObject, String copyNameCalled, String copyNameCaller,
			int numInstrOrDef, EnumInstrDataCategory typeInstrCategory, Instruction instruction) throws ExceptionAmrita, SQLException {
    	
    	EntityObject eo = null;
 
		// PROC_DIVISION
		if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
			// Oggetto copy da db sys/subSys corrente/subSysOwner/struttura db/new object
			// se inesistente viene gi+ inserito in struttura db
			eo=this.analyzerDbInfo.getAddObjectEntitled(copyNameCalled, EnumObject.OBJECT_COPY_COBOL_PROC);
		// DATA_DIVISION
		} else if (this.activeDivisionArea == EnumCobolReservedWords.DATA_DIVISION)  {
			// Oggetto copy da db sys/subSys corrente/subSysOwner/struttura db/new object
			// se inesistente viene gi+ inserito in struttura db
			eo=this.analyzerDbInfo.getAddObjectEntitled(copyNameCalled, EnumObject.OBJECT_COPY_COBOL_DATA);
		}
		
		// Relazione PGM_COPY  
		// Se programma presente si popola la struttura db con oggetti, relazioni, etc relativi al pgm in analisi
		// Se programma assente  si stanno analizzando i copy da soli (analisi NON a fronte di programma): no operation
		if (!this.programName.isEmpty()) {
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
	     			EnumObject.OBJECT_PGM_COBOL
				  , this.programName
				  , typeCopyObject 
			  	  , copyNameCalled
				  , EnumObjectStatus.OBJECT_TO_BE_ANALYZED
				  , relation              // EnumRelation.PGM_COPY, EnumRelation.PGM_COPY_INCLUDE
				  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
				  , this.programName
				  , numInstrOrDef
				  , instruction.getRowStartSource()
				  , instruction.getRowEndSource()
				  , ""
				  , 0
				  , 0
				  , typeInstrCategory
				  , this.activeDivisionArea
				  , false
				  , false
				  , false
				  , this.di.userExitInfoPgm
				   );			
		}
		
		return eo;
    }


	/*
     * -----------------------------------------------------
     * Validazione livello 88 e memorizzazione informazioni
     * -----------------------------------------------------
     * 
     * Viene attivata la gestione unificata di controllo stringhe
     * numeriche e alfanumeriche.
     * 
     * Memorizza le informazioni sul condition name del livello 88
     * nell'opportuno campo di InnerConditionValueEntry
     * 
     */
	private void storeEntryCondition(InstructionCobolDataItem instruction
								   , int fromTo
								   , String token
								   , InnerConditionValueEntry conditionValueEntry
								    ) throws ExceptionAmrita {
        
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;
		EnumCobolReservedWords en_ReservedWordExtracted = null;    
		ExceptionAmrita excp = null; 
		LiteralCobol literalCobol = null;
		String conditionValue = "";
        
        literalCobol = new LiteralCobol();
        
        literalCobol.parseLiteral(token+" ", 0);
        
		// Literal alfanumerica o esadecimale errata
		if (literalCobol.isLiteralString() 
		&& !literalCobol.isLiteralGood()){
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Liv. 88 Condition name"});
			return;
		}
        
        // Literal alfanumerica o esadecimale corretta
		if (literalCobol.isLiteralString() 
		&& 	literalCobol.isLiteralGood()){
			conditionValue = token.substring(0,token.length()).replace('_', ' ');
			conditionValueEntry.literalFromType = literalCobol.getLiteralType();
			if (fromTo == COBOL_CONDITION_NAME_FROM) {
				conditionValueEntry.literalFromString = conditionValue;
			} else {
				conditionValueEntry.literalThruString = conditionValue;
			}
			instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
			instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA);
            return;
		}
		
		// Literal numerica corretta
		if (literalCobol.isLiteralNum() 
        && 	literalCobol.isLiteralGood()){
			conditionValueEntry.literalFromType = literalCobol.getLiteralType();
			// From literal numeric
			if (fromTo == COBOL_CONDITION_NAME_FROM) {
				if (literalCobol.isLiteralNumInt()) {
					conditionValueEntry.literalFromNumericInt = literalCobol.getValueInt();
				} else if (literalCobol.isLiteralNumLong()) {
					conditionValueEntry.literalFromNumericLong = literalCobol.getValueLong();
				} else if (literalCobol.isLiteralNumDouble()) {
					conditionValueEntry.literalFromNumericDouble = literalCobol.getValueDouble();
				} else if (literalCobol.isLiteralNumFloat()) {
					conditionValueEntry.literalFromNumericFloat = literalCobol.getValueFloat();
				}
			}
			// Thru literal numeric
			if (fromTo == COBOL_CONDITION_NAME_TO) {
				if (literalCobol.isLiteralNumInt()) {
					conditionValueEntry.literalThruNumericInt = literalCobol.getValueInt();
				} else if (literalCobol.isLiteralNumLong()) {
					conditionValueEntry.literalThruNumericLong = literalCobol.getValueLong();
				} else if (literalCobol.isLiteralNumDouble()) {
					conditionValueEntry.literalThruNumericDouble = literalCobol.getValueDouble();
				} else if (literalCobol.isLiteralNumFloat()) {
					conditionValueEntry.literalThruNumericFloat = literalCobol.getValueFloat();
				}
			}
			
			instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
			instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM);
			return;
		}
		
		// Può essere solo una costante figurativa
        al_reservedWordEntry = this.map_ReservedWords.get(token);
        en_ReservedWordExtracted = null;
        if (al_reservedWordEntry != null) {
        	en_ReservedWordExtracted = al_reservedWordEntry.get(0).en_WordReservedOwner;
		}
		
		// Token non trovato: sorgente corrotto
		if (en_ReservedWordExtracted == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Liv. 88 Condition name"});
			return;
		}
		
		// Token non costante figurativa: sorgente corrotto
		if (en_ReservedWordExtracted.getCobolFigurative() == null) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Costante Figurativa"});
			return;
		}
		
		// Costante figurativa corretta
		conditionValueEntry.literalFromType = EnumCobolValueType.VALUE_FIGURATIVE;
		if (fromTo == COBOL_CONDITION_NAME_FROM) {
			conditionValueEntry.en_literalFromFigurative = en_ReservedWordExtracted.getCobolFigurative();
		} else {
			conditionValueEntry.en_literalThruFigurative = en_ReservedWordExtracted.getCobolFigurative();
		}
		
		instruction.addSymbolDefinedInside(token, EnumSymbolType.COBOL_SYMBOL_FIGURATIVE);
		instruction.addSymbolInput(token, EnumSymbolType.COBOL_SYMBOL_FIGURATIVE);
		return;
		
	}

	
	 
	/**
	 * 
	 *  Restituisce il successivo oggetto Instruction a partire dalle righe sorgente, in modo trasparente. 
	 *  <p>
	 *  Se non ci sono più istruzioni da restituire, restituisce null.
	 *  
	 *  
	 * @param InnerContextAnalysis 
	 * @return Object con oggetto Instruction specifico
	 * 
	 */
	private Object getNextObjectInstruction(InnerContextAnalysis ictx) {
		
		// Oggetto Instruction estratto. 
		//		InstructionCobolDataItem
		// 		InstructionCobolDataStruct
		// 		InstructionCobolProcedure
		// 		InstructioPrecompiler
		Object objectInstr = null;		// Oggetto istruzione di output
		Instruction instruction = null;
		String sourceInstr = "";  		// Stringa istruzuine completa istruzione, senza eventuale punto finale
		                                // eventualmente derivata da source splittato su + righe
		
		// Estrazione istruzione successiva (memorizzata anche in this.sourceInstr)
		sourceInstr = getNextSourceInstruction(ictx);  // -> this.sourceInstr this.activeTypeInstr
		
 		// Fine istruzioni o errore sorgente in input: restituisco oggetto istruzione null
		if (sourceInstr.equals("")) {
			ictx.objectInstr = null;
			return null;
		}

		// Istruzione non riconosciuta: restituisco oggetto istruzione null
		if (ictx.activeTypeInstr == EnumCobolReservedWords.NOT_ASSIGNED) {
			return null;
		}
		
		// Composizione oggetto istruzione da restituire al chiamante
		ictx.nameInstr = ictx.activeTypeInstr.toString();
		objectInstr = buildObjectInstruction(ictx);
		ictx.objectInstr = objectInstr;
		
		// Info per debug/errori/exception disponibili a fronte di exception
		this.di.excpInfo = ictx;
		if (objectInstr != null) {
			this.di.lastInstrGood = this.di.curInstr;
			this.di.curInstr = (Instruction) objectInstr;
		} 
		if (ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.CICS_PRECOMPILER
		||  ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.SQL_PRECOMPILER		
		||  ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.DL1_PRECOMPILER) {
			this.di.curTypeInstr = ictx.activeTypeInstr.getCobolInstrCategory();
		} else {
			this.di.curTypeInstr = EnumInstrDataCategory.COBOL_INSTRUCTION;
		}

		// Store categoria istruzione direttamente nell'istruzione
		// Informazione utilizzata in caso di errore di parsing e memorizzata su OBJE/OBJI
		instruction = (Instruction) objectInstr;
		instruction.setTypeInstrCategory(this.di.curTypeInstr);
		
// 		instruction.getSourceInstr().strip();
		if (instruction.getSourceInstr().substring(instruction.getSourceInstr().length()-1).equals(",")) {
			instruction.setSourceInstr(instruction.getSourceInstr().substring(0, instruction.getSourceInstr().length()-1));
		}
		return objectInstr;
	}

  
	
	/**
	 * 
	 *  Restituisce e riconosce una stringa con la successiva istruzione Cobol recuperando e 
	 *  concatenando le righe successive dalla posizione 8 alla 72.<br>
	 *  <p>
	 *  Vengono contestualmente aggiornati gli array dei commenti prima, a sinistra e a destra
	 *  di ogni riga. Se la definizione è spalmata su più righe con righe di commento fra una riga
	 *  e l'altra, questi commenti vengono accodati e messsi fra quelli prima della definizione.<br>
	 *  Una riga può contenere anche più di una istruzione e quindi viene anche gestita la posizione di
	 *  inizio e di fine di ogni definizione.<br>
	 *  L'istruzione può essere la definizione di un data item completo o meno di Picture, uno statemente Copy oppure
	 *  istruzioni per i precompilatori Cics, Sql o altro.<br>
	 *  Nel caso di istruzioni per i precompilatori viene valorizzata la variabile di enumerazione
	 *  EnumInstrDataCategory<br>
	 *  <p>
	 *  Viene eliminato il punto finale.
	 *  <p>
	 *  Vengono valorizzati i campi {@link EnumCobolReservedWords} activeTypeInstr con il codice dell'istruzione
	 *  intercettata e viene restituita la stringa copmpleta dell'istruzione, anche se era spalmata
	 *  su più righe, oppure iniziava alla fine di altre istruzioni, in mezzo alla riga sorgente.
	 *  
	 * @param InnerContextAnalysis ictx 
	 * @return String stringa con l'istruzione completa
	 * 
	 */
	private String getNextSourceInstruction(InnerContextAnalysis ictx) {
		
		EnumCobolReservedWords nextInstrType = null;
		EnumCobolReservedWords svActiveDivisionArea = null;
		InnerTokenInstr tokenSpreaded = null;
		ArrayList<InnerTokenInstr> al_tokenSpreaded = null;
		String sourceInstrPackaged = "";        	// Stringa con istruzione completa packagizzata
		String rowWrk = "";
		int iStartComm = 0;
		int iStartSource = 0;
		int i = 0;
		
		// Fine sorgente
		if (ictx.rowStartSource >= ictx.ar_RowsSource.length) {
			return "";
		}			
 
		// Inizializzazione campi e array list
		initializeForNewInstruction(ictx); 
		iStartComm = ictx.rowStartSource;
		this.di.curNumRowSource = iStartComm;					// Disponibile in caso di exception
		iStartSource = ictx.rowStartSource;
		
		// (1) Ricerca prima riga dell'istruzione da trattare
		//     Recupero prima riga utile da cui estrarre i token dell'istruzione       
        for (; ictx.rowStartSource < ictx.ar_RowsSource.length; ictx.rowStartSource++) {
        	
          	ictx.rowAll = ictx.ar_RowsSource[ictx.rowStartSource];
 
          	// Non è un commento Cobol o riga vuota: break e trattamento come istruzione
			if (ictx.rowAll.length() >= 7 && !ictx.rowAll.substring(6,7).equals("*")) {
				extractRowFields(ictx, ictx.rowAll);      // Estrazione col 1-7 8-72 73-80 in variabilidi istanza separate   
				addCommentsLeftRight(ictx);               // Left/Right inseriti per mantenere la sequenza originale
				break;
			}
		}
		
		// Fine sorgente
		if (ictx.rowStartSource >= ictx.ar_RowsSource.length) {
			return "";
		}
		
		
		// Istruzione corrente su stessa riga, come label. Exit. ?????????????????????????????????? RIVEDERE COMPLETAMENTE 
		rowWrk = ictx.ar_RowsSource[iStartComm];
		if (rowWrk.length() > 6 && !rowWrk.substring(7, ictx.posStartInstr).trim().equals("")) {
			iStartComm = 0;
		
		// Istruzione corrente su nuova riga
		} else {
			// Cerco ultima riga istruzione precedente
			for (iStartComm = ictx.rowStartSource - 1; iStartComm > 0; iStartComm--) {
				
				rowWrk = ictx.ar_RowsSource[iStartComm];
				
		       	// Commento: continue
				if (rowWrk.length() >= 7 && rowWrk.substring(6,7).equals("*")) {
					continue;
				}
		       	// Riga vuota: continue
				if (rowWrk.trim().equals("")) {
					continue;
				}
		       	// Riga incompleta: continue
				if (rowWrk.length() < 7) {
					continue;
				}

				// Istruzione: break
				iStartComm++;
				break;
			}
		}
		
		// Inserisco commenti presenti prima dell'istruzione 
		if (iStartComm > 0 || (iStartComm == 0 && iStartSource == 0 && ictx.rowStartSource > 0)) {
			for (i = iStartComm; i < ictx.rowStartSource; i++) {
				rowWrk = ictx.ar_RowsSource[i];
				ictx.al_CommentsBeforeInstr.add(rowWrk);
			}
		}

 		// (2) Individuazione ed estrazione completa istruzione
		
		// Estrazione token accodando 2 righe successive, per gestire parole chiave istruzioni splittate
		// rowAll è una nuova istruzione o l'ultima riga dell'istruzione precedente
		al_tokenSpreaded = new ArrayList<InnerTokenInstr> ();
		getTokensSpreaded(ictx, al_tokenSpreaded, ictx.rowStartSource, ictx.posStartInstr, COBOL_PREFETCH_PARSING_ROWS);
		
        // Individua il tipo di istruzione o NOT_ASSIGNED se non riconosciuta.
		// Viene identificata qualsiasi tipo di istruzione, dichiarativa, procedurale o altro
		ictx.activeTypeInstr = getInstructionType(ictx, al_tokenSpreaded, 0);     
 
		// Tipo istruzione non individuata: errore interno o source errato
		if (ictx.activeTypeInstr == EnumCobolReservedWords.NOT_ASSIGNED) {
	       	if (!this.pgmNameUnderParsing.trim().equals("")) {
				logMessage(EnumMessageType.ERROR_INTERNAL, "EI0028", this.pgmNameUnderParsing, ictx.rowStartSource + "", ictx.posStartInstr + "", al_tokenSpreaded.get(0).token);
				logMessage(EnumMessageType.INFORMATION, "MI0035", this.pgmNameUnderParsing, ictx.ar_RowsSource[ictx.rowStartSource]);
			} else {
				logMessage(EnumMessageType.ERROR_INTERNAL, "EI0039", this.copyNameUnderParsing, ictx.rowStartSource + "", ictx.posStartInstr + "", al_tokenSpreaded.get(0).token);
				logMessage(EnumMessageType.INFORMATION, "MI0046", this.copyNameUnderParsing, ictx.ar_RowsSource[ictx.rowStartSource]);			
			}
			ictx.isAnyInstructionErrorDetected = true;
	       	ictx.sourceInstr = "";
			return "";
		}
		
		// Informazioni identificative inizio istruzione
		ictx.rowStartSource = al_tokenSpreaded.get(0).numRowSource;
		ictx.posStartInstr = al_tokenSpreaded.get(0).posInRow;
		ictx.curInstrInfo.setRowStartSource(ictx.rowStartSource);
		ictx.curInstrInfo.setPosStartInstr(ictx.posStartInstr);
        
		// La divisione attiva deve essere valida per valutare già l'istruzione dopo procedure division (come label)
		if (ictx.activeTypeInstr == EnumCobolReservedWords.PROC_DIVISION) {
			this.activeDivisionArea = EnumCobolReservedWords.PROC_DIVISION;
		}
		
		// Lo statement procedure division può essere dentro un modulo copy
		// In questo caso per valutare correttamente l'istruzione successiva si deve simular
		// la procedure division già attiva. L'analisi del copy la imposterà poi naturalmente.
		svActiveDivisionArea = this.activeDivisionArea;
		if (this.activeDivisionArea != EnumCobolReservedWords.PROC_DIVISION) {
			if (ictx.isProcDivisionInsideCopy && ictx.rowStartSource == ictx.numRowCopyNameWithProcedureDivStmt) {
				this.activeDivisionArea = EnumCobolReservedWords.PROC_DIVISION;
			}
		}
		
 		// (3) Individuazione istruzione successiva e ripristino divisione attiva
		nextInstrType = getInstructionTypeNext(ictx, ictx.activeTypeInstr, al_tokenSpreaded, ictx.activeInstrKeyWordsSize);	
		this.activeDivisionArea = svActiveDivisionArea;
		
		// Individuo il token di fine dell'istruzione, anche in righe successive, a partire dal token valido 
        // successivo a quello chiave di inizio istruzione.
		if (nextInstrType != EnumCobolReservedWords.NOT_ASSIGNED) {
			// Caso ordinario di istruzione successiva individuata
			tokenSpreaded = al_tokenSpreaded.get(ictx.numLastTokenCurInstr);			// Ultimo token istruzione			
		} else {
			// Caso di fine istruzioni in sorgente
			tokenSpreaded = al_tokenSpreaded.get(al_tokenSpreaded.size() - 1);			// Ultimo token ultima istruzione
		}
			
		
		// Completamento informazioni istruzione corrente
		ictx.rowEndSource = tokenSpreaded.numRowSource;
		ictx.posEndInstr = tokenSpreaded.posInRow + tokenSpreaded.token.length() - 1;
		ictx.curInstrInfo.setRowEndSource(ictx.rowEndSource);
		ictx.curInstrInfo.setPosEndInstr(ictx.posEndInstr);
		
		// (4) Packaging istruzione e Adjust pointers per successiva istruzione 

		// Package istruzione eventualmente spalmata su più righe in unica stringa
        // La stringa con l'istruzione viene restituita trimmata.
        sourceInstrPackaged = packageInstr(ictx).toUpperCase();
        
        // Verifica esistenza ed eliminazione punto di chiusura nell'istruzione estratta
        ictx.instrTerminatedWithPoint = false;
        while (sourceInstrPackaged.endsWith(".")) {
           	sourceInstrPackaged = deleteTrailingCharIfAny(sourceInstrPackaged, ".").trim();
        	ictx.instrTerminatedWithPoint = true;
		}
            
        // Commenti e altre informazioni su istruzione
        ictx.sourceInstr = sourceInstrPackaged;
        ictx.curInstrInfo.setSourceInstr(sourceInstrPackaged);
        saveSourceInstructionInfo(ictx, ictx.curInstrInfo);
             
        // Imposto per reperimento successiva istruzione (sulla stessa riga o successive)
        
        // Istruzione estratta ultima del sorgente
        if (nextInstrType == EnumCobolReservedWords.NOT_ASSIGNED) {
        	ictx.rowStartSource = ictx.ar_RowsSource.length + 1;
        	ictx.posStartInstr = 0;
            return sourceInstrPackaged;
		}
         
        // Ulteriori istruzioni presenti
        tokenSpreaded = al_tokenSpreaded.get(ictx.numFirstTokenNextInstr);
        ictx.rowStartSource = tokenSpreaded.numRowSource;
        ictx.posStartInstr = tokenSpreaded.posInRow;
		
		return sourceInstrPackaged;
	}
    
	
	/**
	 * 
	 *  Restituisce un oggetto Instruction, di tipo generale, che conterrà il tipo di istruzione presente 
	 *  nelle righe sorgente circoscritte e individuate da getNextSourceInstruction() <br>
	 *  <p>
	 *  L'oggetto {@link Object} restituito può contenere una istruzione Cobol di Data Division<br>
	 *  come {@link InstructionCobolDataItem} o di statement copy {@link InstructionCobolCopy} o di precompilazione<br>
	 *  come {@link InstructionCics} o un'struzione di procedure division {@link InstructionCobol}.<br>
	 *  Tutte le classi sopra menzionate sono figlie della classe Instruction, che contiene tutte le informazioni<br>
	 *  relative alle righe sorgente dalla quale l'istruzione è stata estratta. {@link Instruction}, oltre
	 *  alle informazioni sulle righe sorgente, memorizza delle {@link Map} con gli utilizzi dei simboli
	 *  qualificati, in input e in output, oltre a tutte le informazioni sull'istruzione: statica, dinamica,
	 *  risolta, etc.<br>
	 *  Se il tipo di istruzione non viene individuato, viene restituito null ed è a cura del chiamante<br>
	 *  il tipo di intervento.  
	 *  
	 * @param InnerContextAnalysis 
	 * @return Object with Instruction coded
	 */
	private Object buildObjectInstruction(InnerContextAnalysis ictx) {
	
		InstructionCobolIdentification instructionIdentification;// Istruzione di identification division
		InstructionCobolEnvironment instructionEnvironment;		 // Istruzione di identification division
		InstructionCobolDataStruct instructionDataStruct;		 // Istruzione di Data Division come FD etc
	    InstructionCobolDataItem instructionDataItem = null;	 // Istruzione di Data Division definizione Data item  
	 	InstructionCobol instructionCopy = null;  	 		     // Istruzione Copy
		InstructionCobolProcedure instructionProcedure;			 // Istruzione di procedure division
		InstructionCobol instructionGeneric;		    		 // Istruzione generica non catalogata nelle precedenti
		InstructionCics instructionPrecompilerCics;			 	 // Istruzione per precompilatore Cics
		InstructionSql instructionPrecompilerSql;			 	 // Istruzione per precompilatore Sql
		InstructionDL1 instructionPrecompilerDl1;			 	 // Istruzione per precompilatore DL1


		// Istanziazione corretto oggetto istruzione figlio di Instruction
        switch (ictx.activeTypeInstr.getCobolInstrCategory()) {
   
	        // Identification division
			case COBOL_SOURCE_IDENTIFICATION:
				instructionIdentification = new InstructionCobolIdentification();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionIdentification);
				instructionIdentification.setTypeInstr(ictx.activeTypeInstr);
				instructionIdentification.setName(ictx.activeTypeInstr.toString());
				return instructionIdentification;

			// Environment division
			case COBOL_ENVIRONMENT_DEFINITION:
				instructionEnvironment = new InstructionCobolEnvironment();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionEnvironment);
				instructionEnvironment.setTypeInstr(ictx.activeTypeInstr);
				instructionEnvironment.setName(ictx.activeTypeInstr.toString());
				return instructionEnvironment;

			// Data division
			case COBOL_DATA_ITEM:
				instructionDataItem = new InstructionCobolDataItem();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionDataItem);
				instructionDataItem.setTypeInstr(ictx.activeTypeInstr);
				instructionDataItem.setName(ictx.activeTypeInstr.toString());
				return instructionDataItem;
			case COBOL_STRUCTURE_DEFINITION:
				instructionDataStruct = new InstructionCobolDataStruct();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionDataStruct);
				instructionDataStruct.setTypeInstr(ictx.activeTypeInstr);
				instructionDataStruct.setName(ictx.activeTypeInstr.toString());
				return instructionDataStruct;
			case COBOL_COMPILER_DIRECTIVE:
				instructionGeneric = new InstructionCobol();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionGeneric);
				instructionGeneric.setTypeInstr(ictx.activeTypeInstr);
				instructionGeneric.setName(ictx.activeTypeInstr.toString());
				return instructionGeneric;

			// Procedure Division
			case COBOL_PROC_INSTRUCTION:
				instructionProcedure = new InstructionCobolProcedure();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionProcedure);
				instructionProcedure.setTypeInstr(ictx.activeTypeInstr);
				instructionProcedure.setName(ictx.activeTypeInstr.toString());
				return instructionProcedure;
			case COBOL_PROC_INSTRUCTION_EXCEPTION:
				instructionProcedure = new InstructionCobolProcedure();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionProcedure);
				instructionProcedure.setTypeInstr(ictx.activeTypeInstr);
				instructionProcedure.setName(ictx.activeTypeInstr.toString());
				return instructionProcedure;
			case COBOL_SECTION_PROGRAM_DELIMITER:
				instructionGeneric = new InstructionCobol();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionGeneric);
				instructionGeneric.setTypeInstr(ictx.activeTypeInstr);
				instructionGeneric.setName(ictx.activeTypeInstr.toString());
				return instructionGeneric;
				
			// Comune a tutte le divisioni
			case COBOL_COPY_INSTRUCTION:
				instructionCopy = new InstructionCobol();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionCopy);
				instructionCopy.setTypeInstr(ictx.activeTypeInstr);
				instructionCopy.setName(ictx.activeTypeInstr.toString());
				return instructionCopy;
     
             // Precompilatori
			case CICS_PRECOMPILER:
				instructionPrecompilerCics = new InstructionCics();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionPrecompilerCics);
				instructionPrecompilerCics.setTypeInstr(ictx.activeTypeInstr);
				instructionPrecompilerCics.setName(ictx.activeTypeInstr.toString());
				return instructionPrecompilerCics;
			case SQL_PRECOMPILER:
				instructionPrecompilerSql = new InstructionSql();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionPrecompilerSql);
				instructionPrecompilerSql.setTypeInstr(ictx.activeTypeInstr);
				instructionPrecompilerSql.setName(ictx.activeTypeInstr.toString());
				return instructionPrecompilerSql;

			case DL1_PRECOMPILER:
				instructionPrecompilerDl1 = new InstructionDL1();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionPrecompilerDl1);
				instructionPrecompilerDl1.setTypeInstr(ictx.activeTypeInstr);
				instructionPrecompilerDl1.setName(ictx.activeTypeInstr.toString());
				return instructionPrecompilerDl1;

			default:
				instructionGeneric = new InstructionCobol();
				storeSourceInstructionInfo(ictx.curInstrInfo, instructionGeneric);
				instructionGeneric.setTypeInstr(ictx.activeTypeInstr);
				instructionGeneric.setName(ictx.activeTypeInstr.toString());
				return instructionGeneric;
			}
	}



	/* -------------------------------------------------
	 * Operazioni iniziali sul programma da analizzare
	 * -------------------------------------------------
	 * 
	 */
	private void initialPgm(SourceInput si, String programName) throws Exception {
		
		EntityObject entityObject = null;
        boolean isProgramAlreadyAnalyzed = false;
        
        // Il tempo di parsing include anche i tempi di attrezzaggio
		// Il tempo di fine è aggiornato a fine parsing
		this.timeMSStart = System.currentTimeMillis();
		
		
		// Identificazione sistema e sottosistema del programma sotto analisi
		// Tutti gli oggetti/relazioni/etc saranno generati sotto questo sistema/sottosistema
	    this.di.userExitInfoPgm = userExitGetSystemSubsystem(this.di, programName, "", "");
        this.di.userExitInfoPgm = this.di.userExitInfoPgm;						// Disponibile a fronte di exception
        this.di.userExitInfoPgm.setSystem(this.di.systemInput); 			// Sistema corrente del programma in analisi
        this.di.userExitInfoPgm.setSubSystem(this.di.subSystemInput); 		// sottosistema corrente del programma in analisi
        
		// Initial ora di inizio e reset errori
		this.di.curTimeMsStart = System.currentTimeMillis();
		this.di.curObjectWithErrors = false;
		
		// Descrittore sorgente e nome sorgente
		this.si = si;				
		this.programName = programName;
		this.pgmNameUnderParsing = programName;
		this.di.curObjectId = programName;
		this.di.curObjectType = EnumObject.OBJECT_PGM_COBOL;
		this.programCobol = new ProgramCobol(ucfg, programName);
		this.di.curProgramCobol = this.programCobol;			// Disponibile a fronte di exception
		this.di.curProgramCobol.setSysOwner(this.di.systemInput);
		this.di.curProgramCobol.setSubSysOwner(this.di.subSystemInput);
		this.di.curProgramCobol.setPath(si.getPathComplete());
		this.di.curProgramCobol.setDir(si.getDirInput());
		
		allocateForMetrics();;
		
		// Logiche & altro
	    this.logicInfoDynamic = new LogicInfoDynamic(); 
	    this.programCobol.setLogicInfoDynamic(this.logicInfoDynamic);
		this.logicSamePgm = new LogicSamePgm(ucfg, di, this.programCobol);
		this.logicSamePgm.setLogicInfoDynamic(this.logicInfoDynamic);
		this.logicInfoDynamic = this.logicSamePgm.getLogicInfoDynamic();
		this.logicInfoDynamic.setProgram(this.programCobol);
	    this.logicSamePgm.getLogicTools().setLogicInfoDynamic(this.logicInfoDynamic);		
		this.logicSpreadedPgm = new LogicSpreadedPgm(ucfg, di, this.programCobol);		
		this.analyzerCics = new AnalyzerCicsInstr(ucfg, di, this);
		this.analyzerSql = new AnalyzerSql(ucfg, di, this);
		this.analyzerCics.setUserExitInfoPgm(this.di.userExitInfoPgm);
		this.analyzerSql.setUserExitInfoPgm(this.di.userExitInfoPgm);
		
		// Impostazione informazioni di contesto iniziali
		this.setInitialContextAnalysis();                     			// metodo pubblico di inizializzazione this.ictx	
		
        // Impostazioni per oggetto programma da inserire/aggiornare a fine elaborazione
		entityObject = new EntityObject();
		entityObject.setSystem(this.di.systemInput);   						 
		entityObject.setSubSystem(this.di.subSystemInput);    
		entityObject.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
		entityObject.setTypeSource(this.getSourceType(entityObject.getTypeObject()));
		entityObject.setIdObject(this.pgmNameUnderParsing);
		isProgramAlreadyAnalyzed = analyzerDbInfo.getObject(entityObject);

		
        // Impostazioni come se il programma fosse alla sua prima analisi
		entityObject.setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS);  // Status di default
  		entityObject.setDtLastAnalysis(DateTimeService.getDateFormatted(new Date(), "yyyyMMdd"));
		entityObject.setTmLastAnalysis(DateTimeService.getTimeFormatted(new Date(), "hhmmss") + "00");
  		if (!isProgramAlreadyAnalyzed) {
			entityObject.setDtFirstAnalysis(DateTimeService.getDateFormatted(new Date(), "yyyyMMdd"));
			entityObject.setTmFirstAnalysis(DateTimeService.getTimeFormatted(new Date(), "hhmmss") + "00");
		}
		// Inserito/aggiornato a fine elaborazione
		this.idxPgmCopyInDbObject = this.analyzerDbInfo.addObjEntity(entityObject);
 		
		// Primary key oggetto db info di analisi e dimensionali
		this.analyzerDbInfo.getObjAnalysisInfo().setSystem(this.di.systemInput);
		this.analyzerDbInfo.getObjAnalysisInfo().setSubSystem(this.di.subSystemInput);
		this.analyzerDbInfo.getObjAnalysisInfo().setTypeObject(EnumObject.OBJECT_PGM_COBOL);
		this.analyzerDbInfo.getObjAnalysisInfo().setIdObject(this.pgmNameUnderParsing);

		// Info disponibili a fronte di eventuale exception
		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.NORMALYZING_SOURCE;
		this.di.curAnalyzerDbInfo = this.analyzerDbInfo;
        
		// Valori dimensionali, commenti etc.
		sourceDimenensionalMetrics(this.ictx);
		
		// Eliminazione anomalie sorgente come istruzione prima di colonna 
		if (this.di.optNormalizeSourceCode) {
			normalizeSourceCodeAndCounting(this.ictx, true);
		}
				
		// Info disponibili a fronte di eventuale exception
		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.PARSING_SOURCE;
		this.di.curAnalyzerDbInfo = this.analyzerDbInfo;

		// Flag dynamic code
        this.ictx.isWithDynamicCode = false;                  // True indica programma con codice dinamico
        this.ictx.isWithDynamicCodeSolved = false;            // True indica programma con codice dinamico con TUTTE le istruzioni risolte
        this.ictx.isWithDynamicCodeSpreadedToSolve = false;   // True indica programma con codice dinamico con istruzioni da risolvere in programmai chiamanti
        this.ictx.isWithDynamicCodeWaitingForData = false;    // True indica programma con codice dinamico con istruzioni in attesa di dati esterni

		// Si suppone non ci siano data item da inserire implicitamente
		hashSet_ImplicitData.clear();
		
 	}

	
	/* -------------------------------------------------
	 * Operazioni iniziali sul copy da analizzare
	 * -------------------------------------------------
	 *  
	 */
	private void initialOperationsCopy(SourceInput si, String copyName, EnumObject objectType) throws Exception {
		
		EntityObject entityObject = null;
        
        // Il tempo di parsing include anche i tempi di attrezzaggio
		// Il tempo di fine è aggiornato a fine parsing
		this.timeMSStart = System.currentTimeMillis();
		
		
		// Identificazione sistema e sottosistema del copy sotto analisi da descrittore sorgemte
		// Tutti gli oggetti/relazioni/etc saranno generati sotto questo sistema/sottosistema
	    this.di.userExitInfoPgm = userExitGetSystemSubsystem(this.di, copyName, "", "");
        this.di.userExitInfoPgm = this.di.userExitInfoPgm;						// Disponibile a fronte di exception
        this.di.userExitInfoPgm.setSystem(si.getSystemOwner()); 			    // Sistema corrente del programma in analisi
        this.di.userExitInfoPgm.setSubSystem(si.getSubSystemOwner()); 		    // sottosistema corrente del programma in analisi
        
		// Initial ora di inizio e reset errori
		this.di.curTimeMsStart = System.currentTimeMillis();
		this.di.curObjectWithErrors = false;
		
		// Descrittore sorgente e nome sorgente
		this.si = si;								
		this.programName = "";					// Non sto analizzando un copy dentro un programma	
		this.pgmNameUnderParsing = "";          // Non sto analizzando un copy dentro un programma
		this.copyNameUnderParsing = copyName;  
		this.di.curObjectId = copyName;
		this.di.curCopyUnderAnalysis = copyName;
		this.di.curObjectType = si.getSourceType().getObjectType();
 		this.copyCobol = new CopyCobol(ucfg, copyName, si.getSourceType().getObjectType());
 		this.di.curCopyCobol = this.copyCobol;
		
		// Le metriche sono solo a livello di programma
		
		// Logiche & altro
		this.analyzerCics = new AnalyzerCicsInstr(ucfg, di, this);
		this.analyzerSql = new AnalyzerSql(ucfg, di, this);
		this.analyzerCics.setUserExitInfoPgm(this.di.userExitInfoPgm);
		this.analyzerSql.setUserExitInfoPgm(this.di.userExitInfoPgm);
		
		// Impostazione informazioni di contesto iniziali
		this.setInitialContextAnalysis();                     			// metodo pubblico di inizializzazione this.ictx	
	
        // Impostazioni per oggetto programma da inserire/aggiornare a fine elaborazione
//		entityObject = new EntityObject();
//		entityObject.setSystem(this.di.systemInput);   						 
//		entityObject.setSubSystem(this.di.subSystemInput);    
//		entityObject.setSystemOwner(this.di.systemInput);   						 
//		entityObject.setSubSystemOwner(this.di.subSystemInput);    
//		entityObject.setTypeObject(objectType);
//		entityObject.setIdObject(copyName);
		entityObject = this.analyzerDbInfo.getAddObjectEntitled(copyName, objectType);
				
        // Impostazioni come se il copy fosse alla sua prima analisi
		entityObject.setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS);  // Status di default
//		entityObject.setFileSource(copyName);   	   			                  // Nome file
//		entityObject.setLibrarySourceObject(di.libraryCodeCurObj);   	   		  // Nome oggetto LIBRARY libreria sorgente di analisi
//		entityObject.setLibrarySource(di.libraryPathCurObj);         			  // Libreria sorgente di analisi (Per oggetti direttamente dedotti da un file sorgente)
//		entityObject.setTypeSource(getSourceType(entityObject.getTypeObject())); 
		this.analyzerDbInfo.completeInfoObject(entityObject);
		
		// Inserito/aggiornato a fine elaborazione
		this.idxPgmCopyInDbObject = this.analyzerDbInfo.addObjEntity(entityObject);
 		
		// Primary key oggetto db info di analisi e dimensionali
		this.analyzerDbInfo.getObjAnalysisInfo().setSystem(this.di.systemInput);
		this.analyzerDbInfo.getObjAnalysisInfo().setSubSystem(this.di.subSystemInput);
		this.analyzerDbInfo.getObjAnalysisInfo().setTypeObject(si.getSourceType().getObjectType());
		this.analyzerDbInfo.getObjAnalysisInfo().setIdObject(copyName);
		this.di.curAnalyzerDbInfo = this.analyzerDbInfo;
		
		// Info disponibili a fronte di eventuale exception
		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.PARSING_SOURCE;
		this.di.curAnalyzerDbInfo = this.analyzerDbInfo;		
 	}	
	
    /* ---------------------------------------------------------
     * Allocazione oggetti Metrics per programma e mainline 
     * ---------------------------------------------------------
     * 
     */
    private void allocateForMetrics() {
    	
       	// Array per metriche section/paragrafi
	    this.al_metricsProgramSection = new ArrayList<Metrics> ();

 		// Metriche mainline di programma
		this.metricsProgramMainline = new Metrics(ucfg, di);
		this.metricsProgramMainline.setSystem(this.di.systemInput);
		this.metricsProgramMainline.setSubSystem(this.di.subSystemInput);
		this.metricsProgramMainline.setScope(EnumMetricsScope.SCOPE_LEVEL_SECTION);
		this.metricsProgramMainline.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
    	this.metricsProgramMainline.setIdObject(this.programName);
		this.metricsProgramMainline.setSection(ID_SUBGRAPH_MAINLINE);
		this.programCobol.setMetricsProgramMainline(this.metricsProgramMainline);
		
		// Metriche di programma
		this.metricsProgram = new Metrics(ucfg, di);
		this.metricsProgram.setSystem(this.di.systemInput);
		this.metricsProgram.setSubSystem(this.di.subSystemInput);
		this.metricsProgram.setScope(EnumMetricsScope.SCOPE_LEVEL_OBJECT);
		this.metricsProgram.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
    	this.metricsProgram.setIdObject(programName);
		this.metricsProgram.setSection("*");
		this.programCobol.setMetricsProgram(this.metricsProgram);
	}


	/* -------------------------------
     * Eliminazione anomalie sorgente
     * -------------------------------
     * 
     * Si bonifica dove possibile il sorgente e si usano le informazioni come metriche.
     * Si tratta principalmente di anomalie legate al cobol MF e ai sources su PC
     * 
     * Casi gestiti:
     * 
     * 1) Istruzioni prima di colonna 8
     *    Se iniziano prima di colonna 8 e prima non è codificato nulla
     *    si shifta la riga a destra per portarla a colonna 8.
     * 2) La riga contiene caratteri speciali, tipo tabulazione
     *    la riga viene cnormalizzata inserendo gli spazi di allineamneto a 8
     * 3) Label/paragrafi che iniziano dopo colonna 8.
     *    Si tratta di istruzioni tipo LAB01. oppure LAB01. MOVE ...
     *    LAB01 inizia prima di colonna 8 e finisce con .
     *    Si shifta la riga a sinistra per portarla a colonna 8.
     * 4) Definizioni dati non chiuse da un punto
     *    Si tratta di istruzioni tipo 05 SK-RECORD
     *    SK-RECORD non è terminato da un punto
     *    Si inserisce un punto dopo il nome del campo
     * 5) Label di chiusura paragrafi seguita da EXIT senza spazi
     *    Si tratta di istruzioni tipo A126-LAB.EXIT.
     * 6) Definizione dati terminata da un punto che termina fra col 73 e 79  
     *    Si tratta di istruzioni tipo:
     *    05 WS-REQ-TYPE                    PIC X(01) VALUE SPACE. 
     *    Si eliminano gli spazi superflui  e si recovera la situazione
     *    
     */
	private void normalizeSourceCodeAndCounting(InnerContextAnalysis ictx, boolean isDimensionalCountingToDo) {
        
		String row = "";
		String rowPrec = "";
		String rowNext = "";
        boolean isProcedureDivision = false;
        boolean isProcedureDivisionInsideSource = false;
        boolean isDataDivision = false;
        boolean isRowWithBadChar = false;
		boolean isRowWrongCommentAreaB = false;
        boolean isRowWrongLiteral = false;
        boolean isRowShiftedLeft = false;
        boolean isRowShiftedRight = false;
        boolean isRowDefOutsideAreaB = false;
        boolean isPointInserted = false;
        boolean isRowInstrSpaced = false;
 		boolean isContinuationApiceRemoved = false;
 	    int iNew = 0;
        
 	    
 	    // Scan preliminare per idividuazione statement procedure division
 	    // Potrebbe essere annegato in qualche copy e quindi non visibile
 	    // Tuttavia i controlli successivi necessitano dell'informazione
 	    for (int i = 0; i < ictx.ar_RowsSource.length; i++) {
			row = ictx.ar_RowsSource[i];
			if (isRowToSkip(row) || isDirCompiler(row)) {continue;}		// Riga vuota/commento/continuazione/salto pagina/...
			isProcedureDivisionInsideSource = normalizeSourceCodeSetProcedure(ictx, row, i, isProcedureDivision, true);
			if (isProcedureDivisionInsideSource) {break;}				// Procedure division statement
	    }
 	    
		// Scan righe sorgente
		for (int i = 0; i < ictx.ar_RowsSource.length; i++) {
			
			// Disponibile a fronte di exception
			this.di.curNumRowSource = i;
			
			row = ictx.ar_RowsSource[i];
			
			// (00) Eliminazione caratteri di tabulazione e speciali 
			isRowWithBadChar = normalizeSourceCodeTabset(ictx, row, i);
			if (isRowWithBadChar) {
				row = ictx.ar_RowsSource[i];
			}

			// Conteggio misure dimensionali, direttamente in oggetto database (OBJI)
			if (isDimensionalCountingToDo) {
				dimensionalInfoCounting(ictx, row, isDataDivision, isProcedureDivision);
			}
			
			// Riga vuota/commento/continuazione/salto pagina/Numerazione e successiva
			if (isRowToSkip(row)) {
				continue;
			}
			// Direttiva compilatore EJECT/SKIP1/2/3/..
			if (isDirCompiler(row)) {
				continue;
			}
			
			// Riga successiva necessaria nei controlli
			rowNext = normalizeSourceCodeGetRowNext(ictx, i);

			// (00) Impostazione a livello di programma se Cics (DFHCOMMAREA)
			normalizeSourceCodeSetCicsProgram(row, isDataDivision);

			// (01) Impostazione flag di data e procedure division
			isDataDivision = normalizeSourceCodeSetData(row, isProcedureDivision, isDataDivision);
			isProcedureDivision = normalizeSourceCodeSetProcedure(ictx, row, i, isProcedureDivision, isProcedureDivisionInsideSource);
			if (isProcedureDivision) {
				isDataDivision = false;
			}
			
			// (02) Gestione eliminazione apice di continuazione
			isContinuationApiceRemoved = normalizeSourceCodeContinuationApiceRemoved(ictx, row, i, rowPrec);
			if (isContinuationApiceRemoved) {
				rowPrec = row;
				continue;
			}

			// (03) Bypass istruzioni precompilatori
			iNew = normalizeSourceCodeBypassPreprocessor(ictx, row, i, isDataDivision, isProcedureDivision);
			if (iNew > i) {
				i = iNew;
				continue;
			}
			row = ictx.ar_RowsSource[i];

	        // (04) Riga con doppie literal dentro literal con stesso delimiter
			isRowWrongLiteral = normalizeSourceCodeLiteral(ictx, row, i);
			if (isRowWrongLiteral) {
				row = ictx.ar_RowsSource[i];
				rowPrec = row;
			}

			// (05) Riga terminata da commento improprio in area B
 			isRowWrongCommentAreaB = normalizeSourceCodeCommentAreaB(ictx, row, i, isDataDivision, isProcedureDivision);
 			if (isRowWrongCommentAreaB) {
 				row = ictx.ar_RowsSource[i];
				rowPrec = row;
 			}
 
			// (06) Riduzione in area B se sconfina e se possibile (se Data Division)
			isRowDefOutsideAreaB = normalizeSourceCodeInsertDefEndedOutsideAreaB(ictx, row, i, isDataDivision, rowNext);
			if (isRowDefOutsideAreaB) {
				row = ictx.ar_RowsSource[i];
				rowPrec = row;
				continue;
			} 

			// (07) Inserimento di un punto dopo il nome campo di una definizione dati (se Data Division)
			isPointInserted = normalizeSourceCodeInsertPointMissing(ictx, row, i, isDataDivision, rowNext, rowPrec);
			if (isPointInserted) {
				row = ictx.ar_RowsSource[i];
				rowPrec = row;
				continue;
			}

			// (08) Riga con codice istruzione seguito da apice o doppio apice o (
			if (isProcedureDivision) {
				isRowInstrSpaced = normalizeSourceCodeInstrSpaced(ictx, row, i);
				if (isRowInstrSpaced) {
					row = ictx.ar_RowsSource[i];
					rowPrec = row;
				}
			}
			
			// (09) Riga con label seguita da . e EXIT. senza spaziatura
			if (isProcedureDivision) {
				isRowInstrSpaced = normalizeSourceCodeLabelAndExit(ictx, row, i);
				if (isRowInstrSpaced) {
					row = ictx.ar_RowsSource[i];
					rowPrec = row;
				}
			}
			
			// (10) Riga da shiftare a destra, erroneamente codificata in area A o prima
			isRowShiftedRight = normalizeSourceCodeShiftRight(ictx, row, i);
			if (isRowShiftedRight) {
				row = ictx.ar_RowsSource[i];
				rowPrec = row;
			}

			// Riga già shiftata a destra
			if (isRowShiftedRight) {
				continue;
			}
			
 			// (11) Riga da shiftare a sinistra, a causa di label oltre col. 8
			isRowShiftedLeft = normalizeSourceCodeShiftLeft(ictx, row, i, isProcedureDivision, rowPrec);
			if (isRowShiftedLeft) {
				row = ictx.ar_RowsSource[i];
			}

			rowPrec = row;
	        
		} // end-for rows
		
	}
 
	/* ---------------------------------------
     * Calcolo metriche dimensionali sorgente
     * ---------------------------------------
     * 
     * I valori vengono impostati direttamente in objectAnalysisInfo
     * 
     */
	private void sourceDimenensionalMetrics(InnerContextAnalysis ictx) {       
		String row = "";
		int i2 = 0;
		int i3 = 0;

        boolean isProcedureDivision = false;
        boolean isDataDivision = true;
        
 	    		// Scan righe sorgente
		for (int i = 0; i < ictx.ar_RowsSource.length; i++) {
			
			// Disponibile a fronte di exception
			this.di.curNumRowSource = i;
			
			row = ictx.ar_RowsSource[i];
			i2 = row.indexOf(" PROCEDURE ");
			if (i2 > 0) {
				i3 =  row.indexOf(" DIVISION", i2 + 10);
				if (i3 > 0) {
					isDataDivision = false;
					isProcedureDivision = true;
				}
			}
			
			// Conteggio misure dimensionali, direttamente in oggetto database objectAnalysisInfo
			dimensionalInfoCounting(ictx, row, isDataDivision, isProcedureDivision);
	        
		} // end-for rows
		
	}
	/* ------------------------------------
	 * Impostazione flag di programma Cics
	 * ------------------------------------
	 * 
	 * Si verificano le seguenti condizioni:
	 * 
	 * 1) Attiva data division
	 * 2) Definizione campo
	 * 3) nome campo DFHCOMMAREA
	 * 
	 * Il flag viene anche impostato in un'altra sezione
	 * se si incontrano statement EXEC CICS ... END-EXEC
	 * 
	 */
    private void normalizeSourceCodeSetCicsProgram(String rowInput, boolean isDataDivision) {
		Scanner scn = null;
    	String row = "";
    	String token = "";
    	
    	// Non si è in data division
    	if (!isDataDivision) {
			return;
		}
		
    	row = rowBlankOnLeadingTrailing(rowInput);
       	scn = new Scanner(row);
        
       	// Non inizia con un numero di livell
       	if (!scn.hasNextInt()) {
			return;
		}
       	token = nextToken(scn);					// Lvl number
       	token = nextToken(scn).toUpperCase();					// Field name
    	if (token.equals("DFHCOMMAREA")) {
			this.programCobol.setCicsProgram(true);
		}
	}


	/* ------------------------------------------------------------------
     * Restituisce true se la riga contiene una direttiva di compilazione
     * ------------------------------------------------------------------
     * 
     */
	private boolean isDirCompiler(String row) {
		Scanner scn = null;
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
		InnerInstructionWordsEntry typeInstr = null;
		String str = "";
		String token = "";
		
		str = row.substring(7).trim();
		scn = new Scanner(str);
        token = nextToken(scn);
        token = deleteTrailingCharIfAny(token, ".");
        
        al_innerReservedWord = this.map_ReservedWords.get(token);

        // Non è una parola chiave Cobol
        if (al_innerReservedWord == null) {
			return false;
		}
        
        // E' una direttiva del compilatore
        typeInstr = al_innerReservedWord.get(0);
        if (typeInstr.en_InstrCategory == EnumInstrDataCategory.COBOL_COMPILER_DIRECTIVE) {
			return true;
		}
        
		return false;
	}


	/* ---------------------------------------------------------------------------
	 * Elimina l'apice iniziale nelle righe di continuazione
	 * ---------------------------------------------------------------------------
	 * 
	 * Solo se la riga precedente non termina con una literal completa.
	 * Predispone il sorgente per l'analisi e il packaging di istruzioni con continuazione.
	 * Fa in modo che il parsing si trovi sempre istruzioni con literal aperte e chiuse
	 * 
	 */
	private boolean normalizeSourceCodeContinuationApiceRemoved(InnerContextAnalysis ictx, String row, int i, String rowPrec) {
	
		String rowLtrim = "";
		String strDoubleApice = "";                             //
		String strApice = "";                                   //
		char doubleApice = 34;									// Doppio apice ""
		int iApice = 0;
        boolean isApiceReplaced = false;
        boolean isRowPrecEndedByLiteral = false;
        boolean isRowPrecEndedByItem = false;
        @SuppressWarnings("unused")
		boolean isRowPrecEndedByCrtOfLiteral = false;
		StringBuffer sb = null;

		// Non è una continuazione
		if (row.charAt(6) != '-') {
			return false;
		}
		
		// Riga precedente termina con VALUE: nessuna operazione
		if (rowBlankOnLeadingTrailing(rowPrec).endsWith("VALUE") 
		||  rowBlankOnLeadingTrailing(rowPrec).endsWith("VALUES")) {
			return false;
		}
		
		strDoubleApice = Character.toString(doubleApice);
		
		// Estrazione stringa significativa e impostazione flag di controllo
		rowLtrim = StringService._ltrim(row.substring(7)); 
		isApiceReplaced = false;
		
		// Rimozione apice per cobol standard
		
		// Apice semplice iniziale
		if (rowLtrim.startsWith("'")) {
			strApice = rowLtrim.substring(0, 1);
			isApiceReplaced = true;
			iApice = row.indexOf("'");
			sb = new StringBuffer(row);
			row = sb.replace(iApice, iApice + 1, " ").toString();
			ictx.ar_RowsSource[i] = row;
		} else if (rowLtrim.startsWith(strDoubleApice)) {
			strApice = rowLtrim.substring(0, 1);
			isApiceReplaced = true;
			iApice = row.indexOf(strDoubleApice);
			sb = new StringBuffer(row);
			row = sb.replace(iApice, iApice + 1, " ").toString();
			ictx.ar_RowsSource[i] = row;
		}
		
		// Gestione particolare per MF: ripristino l'apice che era stato rimpiazzato
	    isRowPrecEndedByLiteral = isRowEndedeByLiteral(rowPrec, strApice);
	    isRowPrecEndedByItem = isRowEndedeByItem(rowPrec);
		isRowPrecEndedByCrtOfLiteral = isRowEndedByCrtOfLiteral(rowPrec);
		if ((isRowPrecEndedByItem || isRowPrecEndedByLiteral) && isApiceReplaced) {
			isApiceReplaced = false;
			row = sb.replace(iApice, iApice + 1, strApice).toString();
			ictx.ar_RowsSource[i] = row;
		}
		return isApiceReplaced;
	}


	/* -------------------------------------------
	 * Mette uno spazio dopo il codice istruzione
	 * -------------------------------------------
	 *  
	 * se seguito da apice, doppio apice, (
	 */
	private boolean normalizeSourceCodeInstrSpaced(InnerContextAnalysis ictx, String row, int i) {
		
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
		String token = "";
		String keyWord = "";
		String rowReplaced = "";
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
        int iApice = 0;
        int iDelimiter = 0;
        int iParOpen = 0;
 
        rowReplaced = rowBlankOnLeadingTrailing(row);
        
		Scanner scn;
		scn = new Scanner(rowReplaced);
		token = nextToken(scn);
		
		iApice = token.indexOf(singleApice);
		iParOpen = token.indexOf("(");
		if (iApice < 0) {
			iApice = token.indexOf(doubleApice);
		}
		if (iParOpen > 0) {
			iDelimiter = iParOpen;
		}
		if (iApice > 0) {
			iDelimiter = iApice;
		}
		if (iApice < 0 && iParOpen < 0) {
			return false;
		}
		
		keyWord = token.substring(0, iDelimiter);
		al_innerReservedWord = this.map_ReservedWords.get(keyWord);
		
		// Parola chiave non censita: non è una istruzione
		if (al_innerReservedWord == null) {
			return false;
		}
		
		// Verifica se istruzione di procedure division
		if (!al_innerReservedWord.get(0).en_InstrCategory.equals(EnumInstrDataCategory.COBOL_PROC_INSTRUCTION)) {
			return false;
		}
		
		// Istruzione di procedure division: elimino spazio
		this.programCobol.getNumRowsWithBadCoding().add(i);
		rowReplaced = rowReplaced.substring(0, scn.match().start()) 
		            + token.substring(0, iDelimiter)
		            + " "
		            + token.substring(iDelimiter)
		            + rowReplaced.substring(scn.match().start() + token.length());
		ictx.ar_RowsSource[i] = rowReplaced;
		return true;
	}

	/* ----------------------------------------------------------------------------
	 * Restituisce true se la riga inizia con un'istruzione di procedure division
	 * ----------------------------------------------------------------------------
	 *  
	 */
	private boolean normalizeSourceCodeIsProcInstr(String row) {
		
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
		String token = "";
		String rowReplaced = "";
 
        rowReplaced = rowBlankOnLeadingTrailing(row);
        
		Scanner scn;
		scn = new Scanner(rowReplaced);
		token = nextToken(scn);
		
		al_innerReservedWord = this.map_ReservedWords.get(token);
		
		// Parola chiave non censita: non è una istruzione
		if (al_innerReservedWord == null) {
			return false;
		}
		
		// Verifica se istruzione di procedure division
		if (!al_innerReservedWord.get(0).en_InstrCategory.equals(EnumInstrDataCategory.COBOL_PROC_INSTRUCTION)) {
			return false;
		}
		
		// Istruzione di procedure division
		return true;
	}

	/* -----------------------------------------------------------------
	 * Mette uno spazio dopo una label se seguita EXIT senza spaziatura.
	 * -----------------------------------------------------------------
	 * 
	 * Il recovery avviene solo se la label è 
	 * 
	 * Es. A125-ROUTINE.EX-A125.
	 * 
	 */
	private boolean normalizeSourceCodeLabelAndExit(InnerContextAnalysis ictx, String row, int i) {
		
		String rowReplaced = "";
        int iPointExit = 0;
        
        // Non è una label
        if (row.charAt(7) == ' ') {
			return false;
		}
        
        rowReplaced = rowBlankOnLeadingTrailing(row);
        
        iPointExit = rowReplaced.indexOf(".EXIT.");
        
        // Solo label: niente da recoverare
        if (iPointExit < 0) {
		   return false;
		}
        
        // Spazio precedente: niente da recoverare
        if (rowReplaced.charAt(iPointExit - 1) == ' ') {
        	return false;
		}
        
        // Inserimento space
        rowReplaced = rowReplaced.substring(0, iPointExit + 1) + " " + rowReplaced.substring(iPointExit + 1);
        this.programCobol.getNumRowsWithBadCoding().add(i);
		ictx.ar_RowsSource[i] = rowReplaced;

		return true;
	}


	/* ---------------------------------------------------
	 * Retituisce la prima riga non blank, non comment ..
	 * ---------------------------------------------------
	 * 
	 */
	private String normalizeSourceCodeGetRowNext(InnerContextAnalysis ictx, int i) {
		String row = "";
		for (int j = i + 1; j < ictx.ar_RowsSource.length; j++) {
			row = ictx.ar_RowsSource[j];
			if (!isRowToSkip(row)) {
				return row;
			}
		}
		return "";
	}


	/* ----------------------------------
	 * Se data divisione restituisce true
	 * ----------------------------------
	 */
	private boolean normalizeSourceCodeSetData(String row, boolean isProcedureDivision,  boolean isDataDivision) {
		
		int idx1 = 0;
		int idx2 = 0;
		
		// Non può essere data division, già attiva procedure division
		if (isProcedureDivision) {
			return false;
		}
		
		// E' gia data division 
		if (isDataDivision) {
			return true;
		}
		
		idx1 = row.indexOf(" DATA ");
		if (idx1 > 0) {
			idx2 =  row.indexOf(" DIVISION", idx1 + 5);
			if (idx2 > 0) {
				return true;
			}
		}
		
		idx1 = row.indexOf(" FILE ");
		if (idx1 > 0) {
			idx2 =  row.indexOf(" SECTION", idx1 + 5);
			if (idx2 > 0) {
				return true;
			}
		}
		
		idx1 = row.indexOf(" WORKING-STORAGE");
		if (idx1 > 0) {
			idx2 =  row.indexOf(" SECTION", idx1 + 5);
			if (idx2 > 0) {
				return true;
			}
		}
		
		idx1 = row.indexOf(" LINKAGE");
		if (idx1 > 0) {
			idx2 =  row.indexOf(" SECTION", idx1 + 5);
			if (idx2 > 0) {
				return true;
			}
		}
		
			
		return false;
	}

	/* ----------------------------------------
	 * Se procedure divisione restituisce true
	 * ----------------------------------------
	 * 
	 * Lo statement di procedure dicision potrebbe esseere codificato dentro un copy.
	 * In fase preliminare si è già individuato se lo statemet Procedure division è presente
	 * Se Procedure Division NON è presente fisicamente si verifica che:
	 * - Se è uno statement section
	 * - Se la prima parola da area A è una parola riservata di procedure division
	 * Se una delle condizioni precedenti è vera, allora si restituisce true
	 * 
	 */
	private boolean normalizeSourceCodeSetProcedure(InnerContextAnalysis ictx, String row, int iRow, boolean isProcedureDivision, boolean isProcedureDivisionToSearch) {
		
		Scanner scn = null;
		String rowPrec = "";
		String copyName = "";
		String token = "";
		boolean newFlag = false;
		int idx1 = 0;
		int idx2 = 0;
		
		// Si è già in procedure division
		if (isProcedureDivision) {
			return isProcedureDivision;
		}
		
		// Procedure division nel source
		if (isProcedureDivisionToSearch) {
			newFlag = isProcedureDivision;
			idx1 = row.indexOf(" PROCEDURE ");
			if (idx1 > 0) {
				idx2 =  row.indexOf(" DIVISION", idx1 + 10);
				if (idx2 > 0) {
					newFlag = true;
				}
			}
			return newFlag;
		}
		
		// Procedure division deve essre in un copy precedente
		
		// Non è una istruzione di procedure division
		if (!normalizeSourceCodeIsProcInstr(row)) {
			return false;
		}
		
		// Istruzione di procedure division.
		// Ricerca primo copy precedente che deve contenere lo statement procedure Division
		// Tale copy sarà usato come riferimento nell'analisi del programma come
		// inizio della procedure division
		
		// Scan reverse righe sorgente alla 
		for (int i = iRow - 1; i > 0; i--) {
			rowPrec = ictx.ar_RowsSource[i];
			rowPrec = rowBlankOnLeadingTrailing(rowPrec);
			scn = new Scanner(rowPrec);
			token = nextToken(scn);
			if (token.equals("")) {continue;}
			if (!token.equals("COPY")) {continue;}
			token = nextToken(scn);
			copyName = deleteTrailingCharIfAny(token, ".");
			ictx.copyNameWithProcedureDivStmt = copyName;
			ictx.isProcDivisionInsideCopy = true;
			ictx.numRowCopyNameWithProcedureDivStmt = i;
			break;
		}
		
		return true;
	}


	/* --------------------------------------------------
	 * Eliminazione caratteri di tabulazione e speciali 
	 * --------------------------------------------------
	 * 
	 */
	private boolean normalizeSourceCodeTabset(InnerContextAnalysis ictx, String row, int i) {
		
		String rowReplaced = "";
		rowReplaced = replaceTabsWithSpace(row);
		
		// C'erano tab
		if (!rowReplaced.equals(row)) {
	    	ictx.ar_RowsSource[i] = rowReplaced;
	    	// Analisi copy non embedded in un programma
	    	if (di.curTypeCopyUnderAnalysis == EnumObject.OBJECT_COPY_COBOL_PROC
	    	&& this.programCobol != null) {
		    	this.programCobol.getNumRowsWithBadChar().add(i);
		    	return true;				
			}
		}

		return false;
	}


	/* ----------------------------------------------------------
	 * Bypass istruzioni precompilatori con recovery violazioni
	 * ----------------------------------------------------------
	 * 
	 * 1) Inserimento di spazio prima di END-EXEC per prevention casi come )END-EXEC
	 * 2) Inserimento di spazio dopo INTO  se seguito da variabile host (:var)
	 * 3) Inserimento di spazio dopo WHERE se seguito da variabile host (:var)
	 */
	private int normalizeSourceCodeBypassPreprocessor(InnerContextAnalysis ictx, String row, int iStart, boolean isDataDivision, boolean isProcedureDivision) {
		
		String rowReplaced = "";
   		boolean isBadChar = false;
  		boolean isShiftedRight = false;
  		@SuppressWarnings("unused")
		boolean isRowWrongCommentAreaB = false;
 		boolean isExecSql = false;
 		boolean isBadCodeSql = false;
   		int iToken1 = 0;
        int iNew = 0;
        
        
        isBadChar = normalizeSourceCodeTabset(ictx, row, iStart);
        isShiftedRight = normalizeSourceCodeShiftRight(ictx, row, iStart);
        
        iToken1 = row.indexOf(" EXEC ");
    	
    	// Non è Exec ...
    	if (iToken1 < 0) {
    		return iStart;
    	}
    	
    	// Non è Exec Sql/Cics/..
    	if (row.indexOf("SQL", iToken1) < 0 
    	&&  row.indexOf("CICS", iToken1) < 0) {
    	    return  iStart;
    	    		
    	}
    	
    	// Update flag in descrittore programma
       	if (row.indexOf("SQL", iToken1) > 0 ) {
     	   if (this.programCobol != null) {
			this.programCobol.setSqlProgram(true);
		   }
      	}
       	if (row.indexOf("CICS", iToken1) > 0 ) {
       		if (this.programCobol != null) {
       			this.programCobol.setCicsProgram(true);
       		}
       	}
       	if (row.indexOf("DLI", iToken1) > 0 ) {
      	   this.programCobol.setDl1Program(true);
       	}
    	
    	// Sql
    	if (row.indexOf("SQL", iToken1) > 0) {
    		isExecSql = true;
    	}
    	
    	iNew = iStart;
    	
    	// Scan e normalizzazione fino a End-Exec 
		for (; iNew < ictx.ar_RowsSource.length; iNew++) {
			
			row = ictx.ar_RowsSource[iNew];
			
			// La riga con Exec... è già stata conteggiata prima del richiamo
			if (iNew > iStart) {
				dimensionalInfoCounting(ictx, row, isDataDivision, isProcedureDivision);
			}
			
			// Commento Sql: space in riga
			if (isExecSql && row.trim().startsWith("--")) {
				ictx.ar_RowsSource[iNew] = "";
				continue;
			}
			
			isBadChar = normalizeSourceCodeTabset(ictx, row, iNew);
			if (isBadChar) {
				row = ictx.ar_RowsSource[iNew];
			}

			if (isCobolRowComm(row) || isRowCobolEmpty(row) ) {
				continue;
			}
			
			isShiftedRight = normalizeSourceCodeShiftRight(ictx, row, iNew);
			if (isShiftedRight) {
				row = ictx.ar_RowsSource[iNew];
			}

			// Normalizzazione bad coding sql 
			if (isExecSql) {
				isBadCodeSql = normalizeSourceCodeSql(ictx, row, iNew);
				if (isBadCodeSql) {
					row = ictx.ar_RowsSource[iNew];
				}
			}
			
			iToken1 = row.indexOf("END-EXEC");
			if (iToken1 >= 0) {
				rowReplaced = row.replace("END-EXEC", " END-EXEC");
				ictx.ar_RowsSource[iNew] = rowReplaced;
				break;
			}
		}
		return iNew;
	}

    /* ----------------------------------
     * Normalizzazione istruzione sql
     * ----------------------------------
     * 
     *  1) Riga con INTO seguito senza spazi da variabile host (inizia con :)
     *  2) Riga con WHERE seguito senza spazi da variabile host (inizia con :)
     *  3) Riga con Variabile host scritta come : space var invece che :var
     * 
     */
	private boolean normalizeSourceCodeSql(InnerContextAnalysis ictx, String row, int iRow) {
		
		String rowReplaced = "";
		int iInto = 0;
		int iWhere = 0;
		int iTwoPoint = 0;
		
		iInto = row.indexOf(" INTO:");
		iWhere = row.indexOf(" WHERE:");
		iTwoPoint = row.indexOf(": ");
		
		// Nessuna violazione
		if (iInto < 0 && iWhere < 0 && iTwoPoint < 0) {
			return false;
		}
		
		rowReplaced = row;
		
		if (iInto >= 0) {
			rowReplaced = rowReplaced.replace(" INTO:", " INTO :");
		}
		if (iInto >= 0) {
			rowReplaced = rowReplaced.replace(" WHERE:", " WHERE :");
		}
		if (iTwoPoint >= 0) {
			rowReplaced = rowReplaced.replace(": ", ":");
			rowReplaced = rowReplaced.replace(": ", ":");
			rowReplaced = rowReplaced.replace(": ", ":");
		}
		ictx.ar_RowsSource[iRow] = rowReplaced;
		this.programCobol.getNumRowsWithBadCodingSql().add(iRow);
		
		return true;
	}


	/* ----------------------------- 
	 * 	Riga da shiftare a sinistra 
	 * ------------------------------ 
	 * 
	 * A causa di label oltre col. 8
	 * 
 	 */
	private boolean normalizeSourceCodeShiftLeft(InnerContextAnalysis ictx, String row, int i, boolean isProcedureDivision, String rowPrec) {

		Scanner scn = null;
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
        String rowReplaced = "";
  		String token = "";
 		int iFirstCrtLabel= 0;

        // Solo se procedure division
        if (!isProcedureDivision) {
        	return false;
        }
        	
        // Solo se riga precedente chiusa da un punto
        if (isRowEndedByPoint(rowPrec)) {
        	scn = new Scanner(row);
        	token = firstGoodTokenOnRow(scn, row);		// Label ?
			al_innerReservedWord = this.map_ReservedWords.get(deleteTrailingCharIfAny(token, "."));
			// E' una parola riservata cobol, quindi NON è label
			if (al_innerReservedWord != null) {
				return false;
			}
			// E un numero intero di un data item, quindi NON è label
			if (StringService._isNumericInt(token)) {
				return false;
			}
			// Inizia con un apice, quindi NON è label
			if (token.charAt(0) == '"' || token.startsWith("'")) {
				return false;
			}
			
			// Label da shiftare a sinistra
			iFirstCrtLabel = scn.match().start();
        	if (iFirstCrtLabel > 7) {
				if (row.length() < 72) {
					rowReplaced = "       " + row.substring(iFirstCrtLabel).trim();
				} else {
					rowReplaced = "       " + row.substring(iFirstCrtLabel, 72).trim();
				}
				ictx.ar_RowsSource[i] = rowReplaced;
				this.programCobol.getNumRowsShiftedLeft().add(i);
				return true;
			}	        	
		}
		return false;
	}

	/* -------------------------------------------------------------------------------
	 *  Eliminazione spazi superflui in definizione dati fino a riduzione entro 72 crt
	 * -------------------------------------------------------------------------------
	 * 
	 *  Casi tipo:
	 *  
	 *  5 WS-REQ-TYPE                    PIC X(01) VALUE SPACE.  
	 *           
	 */
	private boolean normalizeSourceCodeInsertDefEndedOutsideAreaB(InnerContextAnalysis ictx, String row, int i, boolean isDataDivision, String rowNext) {

	    String rowBlanked = "";
	    String rowReplaced = "";
	    String rowFromCol8 = "";
 
        // Solo se Data Division
        if (!isDataDivision) {
        	return false;
        }

        // Solo se inizia una definizione dati
        rowBlanked = rowBlankOnLeadingTrailing(row);
        if (!isRowDataDefinitionStarting(rowBlanked)) {
        	return false;
        }
        
        // Solo se supera 72 crt
        if (row.trim().length() <= 72) {
         	return false;
		}
        
        // Solo se caratteri prima e dopo col 72
        if (row.charAt(71) == ' '
		||  row.charAt(72) == ' ') {
        	return false;
		}
        
        // Area da trattare
        rowFromCol8 = row.substring(7);
        
        rowFromCol8 = rowFromCol8.replace("   ", " ");
        rowFromCol8 = rowFromCol8.replace("  ", " ");
        rowFromCol8 = rowFromCol8.replace("  ", " ");
	
        // Ricompongo riga normalizzata
        rowReplaced = row.substring(0, 8) + rowFromCol8;
		
		// Update source e inserimento in struttura programma
		ictx.ar_RowsSource[i] = rowReplaced;
		this.programCobol.getNumRowsWithBadCoding().add(i);
		
        return true;
	}


	
	/* ------------------------------------------------------------
	 *  Inserimento di un punto a chiusura di una definizione dati
	 * ------------------------------------------------------------
	 * 
	 */
	private boolean normalizeSourceCodeInsertPointMissing(InnerContextAnalysis ictx, String row, int i, boolean isDataDivision, String rowNext, String rowPrec) {

		Scanner scn = null;
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
        String rowReplaced = "";
        @SuppressWarnings("unused")
		String levelNumber = "";
        String fieldName = "";
        String nextToken = "";

        // Solo se Data Division
        if (!isDataDivision) {
        	return false;
        }

        row = rowBlankOnLeadingTrailing(row);

        // Definizione dati di continuazione. 
        // Precedurta e seguita da una definizione dati non chiusa da un punto.
         if (!isRowDataDefinitionStarting(row) 
         &&  !row.trim().endsWith(".")		 
         &&   isRowDataDefinitionStarting(rowBlankOnLeadingTrailing(rowPrec)) 
         &&   isRowDataDefinitionStarting(rowBlankOnLeadingTrailing(rowNext))) {
        	// Definizione terminata da un .
        	if (row.trim().endsWith(".")) {
				return false;
			}
        	// Inserisco il punto
        	rowReplaced = row + ".";
			ictx.ar_RowsSource[i] = rowReplaced;
			this.programCobol.getNumRowsWithDataUnclosed().add(i);
        	return true;
        }

        // Continuo solo se la riga inizia una definizione dati 
        if (!isRowDataDefinitionStarting(row)) {
        	return false;
        }

        scn = new Scanner(row);
		levelNumber = nextToken(scn);											// nn 
		fieldName = nextToken(scn);                 							// field-name
		
		// Campo già terminato da punto: continue
		if (fieldName.endsWith(".")) {
			return false;
		}
		
		// Parola chiave dopo numero livello: continue
		al_innerReservedWord = this.map_ReservedWords.get(fieldName);
		if (al_innerReservedWord != null) {
			return false;
		}
		
		// Ultima riga sorgente: deve terminare con .
		if (rowNext.equals("")) {
			if (row.endsWith(".")) {
				return false;
			}
			// inserisco il punto 
			rowReplaced = row + ".";
			ictx.ar_RowsSource[i] = rowReplaced;
			this.programCobol.getNumRowsWithDataUnclosed().add(i);
			return true;
		}
		
		
		rowNext = rowBlankOnLeadingTrailing(rowNext);
		
		// Su stessa riga continua la definizione dati
		nextToken = nextToken(scn);												// PIC|USAGE|COMP|.... ?
		al_innerReservedWord = this.map_ReservedWords.get(nextToken);
		if (al_innerReservedWord != null) {
			// Riga terminata da un punto: nessuna operazione
			if (isRowEndedByPoint(row)) {
				return false;
			} 
			// Riga successiva NON inizia definizione dati: continue
			if (!isRowDataDefinitionStarting(rowNext)) {
				return false;
			}
		}
		
		// Riga successiva INIZIA una definizione dati: inserisco il punto
		if (isRowDataDefinitionStarting(rowNext)) {
			rowReplaced = StringService._rtrim(row) + ".";
			ictx.ar_RowsSource[i] = rowReplaced;
			this.programCobol.getNumRowsWithDataUnclosed().add(i);
			return true;
		}
		
        return false;
	}


	/* ----------------------------------------------------
	 *  Riga da shiftare a destra, erroneamente codificata
	 *  ---------------------------------------------------
	 *  
	 */
	private boolean normalizeSourceCodeShiftRight(InnerContextAnalysis ictx, String row, int i) {

		Scanner scn = null;
   		String token = "";
   		String rowNomalized = "";
     	int iFirstCrtNoSpace = 0;
   		
		// Commento da colonna 1
//		if (row.startsWith("*")) {
//			row = "      " + row.substring(0);
//			ictx.ar_RowsSource[i] = row;
//			this.programCobol.getNumRowsShiftedRight().add(i);
//			return true;
//		}
		
		iFirstCrtNoSpace = StringService._firstNoSpace(row, 0);
        if (iFirstCrtNoSpace <= 6 
		&&  iFirstCrtNoSpace > 0) {
        	scn = new Scanner(row);
        	token = nextToken(scn);								// token col1-7
            // Unico token non numerico tutto a colonna 1-7: se non è un numero o istruzione nessuna operazione
         	if ((iFirstCrtNoSpace + token.length()) <= 7  
         	&& !StringService._isNumericInt(token)
         	&& !token.equals("IF")
         	&& !token.equals("GO")
         	&& !token.equals("TO")
        	&& !token.equals("MOVE")
        	&& !token.equals("ADD")) {
				return false;
			}
         	
         	// Numero in colonne 1-6 
         	if (StringService._isNumericInt(token)) {
         		// NON è un numero di livello (1 - 99): nessuna operazione
         		if (token.length() > 2) {
         			return false;
				}
         		// Può essere un numero di livello: NON deve essere seguito da un numero
         		token = nextToken(scn);	
         		if (StringService._isNumericInt(token)) {
         			return false;
         		}
			}
         	
         	// Faccio iniziare la stringa da colonna 12
         	// Tokenizzo ed elimino spazi per gestione casi particolari
         	rowNomalized = "";
         	scn = new Scanner(row.substring(iFirstCrtNoSpace));
         	token = nextToken(scn);
         	while (!token.equals("")) {
         		rowNomalized = rowNomalized + " " + token;
				token = nextToken(scn);
			}
         	
   			row = "            " + rowNomalized;
			ictx.ar_RowsSource[i] = row;
			this.programCobol.getNumRowsShiftedRight().add(i);
			return true;
   		}
        
		return false;
	}


	/* -----------------------------------------------
	 * Riga terminata da commento improprio in area B
	 * -----------------------------------------------
	 * 
	 * Normalizzazione attiva solo se in data division.
	 * In procedure division si potrebbe eliminare un * di computazione
	 */
	@SuppressWarnings("unused")
	private boolean normalizeSourceCodeCommentAreaB(InnerContextAnalysis ictx
												  , String row
												  , int i
										          , boolean isDataDivision
										          , boolean isProcedureDivision
											       ) {

		String rowReplaced = "";
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
		boolean isStarFound = false;
	    int idx1 = 0;
	    int j = 0;
	    
	    // Non è data division: nessuna operazione
	    if (!isDataDivision) {
			return false;
		}
	    
		// Cerco primo * partendo dal fondo della riga
		for (idx1 = row.length() - 1; idx1 > 7; idx1--) {
			// Apici di chiusura: non è il caso 
			if (row.charAt(idx1) ==  singleApice
			||  row.charAt(idx1) ==  doubleApice) {
				idx1 = 0;
				break;
			}
			// *: Se in area B può essere una violazione
			if (row.charAt(idx1) ==  '*') {
				isStarFound = true;
				break;
			}
		}
		
		// Nessun * trovato partendo da fondo
		if (!isStarFound) {
			return false;
		}
				
		// Da non considerare
		if (idx1 < 7 
		||  idx1 > 71){
		    return false;
		}
		if (row.charAt(6) ==  '*' 
		||  row.charAt(6) ==  '-') {
			return false;
		}
		
		// Elimino da * incluso
		rowReplaced = row.substring(0, idx1);
	    ictx.ar_RowsSource[i] = rowReplaced;
	    this.programCobol.getNumRowsWithBadCoding().add(i);
		return true;
	}


	/* ------------------------------------------------------------
	 * Riga con doppie literal dentro literal con stesso delimiter
	 * ------------------------------------------------------------
	 * 
	 */
	private boolean normalizeSourceCodeLiteral(InnerContextAnalysis ictx, String row, int i) {

        String rowReplaced = "";
        String doubleDoubleApice = "";
        String doubleSingleApice = "";
        boolean isWrongLiteral = false;
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
        int idx1 = 0;
        int idx2 = 0;
        
        doubleSingleApice = "''";
        doubleDoubleApice = Character.toString(doubleApice) +  Character.toString(doubleApice);

        
		idx1 = row.indexOf(doubleDoubleApice);
		idx2 = row.indexOf(doubleSingleApice);
		if (idx1 > 0) {
			if (isDoubleApiceInsideSameDelimiter(row, idx1, Character.toString(doubleApice))) {
				rowReplaced = row.replace(doubleDoubleApice, Character.toString(singleApice) + " ");
			    ictx.ar_RowsSource[i] = rowReplaced;
			    this.programCobol.getNumRowsWithBadCoding().add(i);
			    row = rowReplaced;
			    isWrongLiteral = true;
			}
		}
		if (idx2 > 0) {
			if (isDoubleApiceInsideSameDelimiter(row, idx1, Character.toString(singleApice))) {
				rowReplaced = row.replace(doubleSingleApice, Character.toString(doubleApice) + " ");
			    ictx.ar_RowsSource[i] = rowReplaced;
			    this.programCobol.getNumRowsWithBadCoding().add(i);
			    isWrongLiteral = true;
			}
		}
		return isWrongLiteral;
	}

	/* -----------------------------------------------------------------------------
	 * Conteggia le misure dimensionali direttamente nell'oggetto database di info
	 * -----------------------------------------------------------------------------
	 * 
	 */
	private void dimensionalInfoCounting(InnerContextAnalysis ictx, String row,	boolean isDataDivision, boolean isProcedureDivision) {
		
		int oldValue = 0;
		long oldSizeBytes = 0;
		
		// Size in bytes
		oldSizeBytes = this.analyzerDbInfo.getObjAnalysisInfo().getSizeBytes();
		this.analyzerDbInfo.getObjAnalysisInfo().setSizeBytes( oldSizeBytes + row.length());
		
		// Numero righe totali e per divisione (includono commenti e righe empty/blank)
		oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsTot();	
		this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsTot(++oldValue);	
		if (isDataDivision) {
			oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsData();
			this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsData(++oldValue);	
		}
		if (isProcedureDivision) {
			oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsProc();	
			this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsProc(++oldValue);	
		}
		
		// Riga commento
		if (isCobolRowComm(row)) {
			oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsCommTot();	
			this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsCommTot(++oldValue);
			if (isDataDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsCommData();
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsCommData(++oldValue);	
			}
			if (isProcedureDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsCommProc();	
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsCommProc(++oldValue);	
			}
			return;
		}

		// Riga empty (carriage return o spaces)
		if (isRowEmpty(row)) {
			oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsEmptyTot();	
			this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsEmptyTot(++oldValue);
			if (isDataDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsEmptyData();	
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsEmptyData(++oldValue);	
			}
			if (isProcedureDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsEmptyProc();	
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsEmptyProc(++oldValue);	
			}
			return;
		}
		
		// Riga blank (spaces da col 7 o commento vuoto)
		if (isRowCobolEmpty(row)) {
			oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsBlankTot();	
			this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsBlankTot(++oldValue);
			if (isDataDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsBlankData();	
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsBlankData(++oldValue);	
			}
			if (isProcedureDivision) {
				oldValue = this.analyzerDbInfo.getObjAnalysisInfo().getNumRowsBlankProc();	
				this.analyzerDbInfo.getObjAnalysisInfo().setNumRowsBlankProc(++oldValue);	
			}
			return;
		}
		
	}


	/* --------------------------------------------------------------------
	 * Restituisce true se doppio apice in literal con stesso delimiter
	 * --------------------------------------------------------------------
	 * 
	 * Situazioni gestite:
	 * 
	 * ".."".."
	 * '..''..'
	 * 
	 */
	private boolean isDoubleApiceInsideSameDelimiter(String row, int idx, 	String delimiterApice) {
		
		int cntApice = 0;
		
		for (int i = idx - 1; i >= 0; i--) {
			if (row.substring(i, i + 1).equals(delimiterApice)) {
				cntApice++;
			}
		}
		
		// Se l'apice è stato aperto e chiuso il resto deve essere 0
		if (cntApice % 2 == 0) {
			return false;
		}
		
		return true;
	}


	/* --------------------------------------------------------
	 * Restituisce true se la riga inizia una definizione dati
	 * --------------------------------------------------------
	 * 
	 *         05 campo PIC X
	 *  AA   01 campo VALUE ZERO
	 */
    private boolean isRowDataDefinitionStarting(String rowInput) {
    	
    	Scanner scn = null;
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;
       	String nextToken = "";
		String fieldName = "";
    	
		// Riga vuota: false
       	if (rowInput.trim().equals("")) {
			return false;
		}
        	
        scn = new Scanner(rowInput);

        // Non inizia con un numero: non è una definizione dati
        if (!scn.hasNextInt()) {
        	return false;
        }
        
        // Inizia con un numero: potrebbe essere una definizione dati 
		nextToken(scn);															// nn 
		fieldName = nextToken(scn);                 							// field-name
		nextToken = nextToken(scn); 											// PIC|VALUE|
		
		// C'era un numero seguito da un punto: si tratta del value numerico di una definizione 
		// come 88 campo value is
		//               1 .
		if (fieldName.equals(".")) {
			return false;
		}
		
		// E' una definizione dati
		al_innerReservedWord = this.map_ReservedWords.get(nextToken);
		if (al_innerReservedWord != null && al_innerReservedWord.get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_DATA_ITEM) {
			return true;
		}
		
		// Sicuramente non è una definizione dati
		if (!nextToken.equals("")) {
			return false;
		}
		
		// nn campo: inizia una definizione dati
		if (!fieldName.equals("")) {
			return true;
		}
    	
    	return false;
	}


    /* ----------------------------------------
     * Pulizia area in colonna 1-7 e col 72-80
     * ----------------------------------------
     * 
     * La riga istruzione si suppone codificata correttamente
     * nelle aree A e B
     * 
     */
	private String rowBlankOnLeadingTrailing(String rowInput) {
		Scanner scn =  null;
		StringBuffer sbRow = null;
		String token = "";
		int iStart = 0;
		int iEnd = 0;
		
		// Riga vuota: no operation
		if (rowInput.trim().equals("")) {
			return rowInput;
		}
		
		sbRow = new StringBuffer(rowInput);
		scn = new Scanner(rowInput);
		
		// Leading
		token = nextToken(scn);
		if (scn.match().start() < 7) {
			iStart = scn.match().start();
			iEnd = iStart + token.length();
			for (int i = iStart; i < iEnd; i++) {
				sbRow.replace(i, i + 1, " ");
			}
		}
		
		// Trailing
		if (rowInput.length() >= 72) {
			for (int i = 72; i < rowInput.length(); i++) {
				sbRow.replace(i, i + 1, " ");
			}

		}
		return sbRow.toString();
	}


	/* -----------------------------------------------------
     * Restituisce true se la riga è terminata da un punto 
     * -----------------------------------------------------
     * 
     */
	private boolean isRowEndedByPoint(String row) {
		String rowWork = "";
		
		if (row.length() > 72) {
			rowWork = row.substring(0, 72).trim();
		} else {
			rowWork = row.trim();
		}
		
		if (rowWork.endsWith(".")) {
			return true;
		}
		
		return false;
	}


	/* ---------------------------------------
	 * Estrazione primo token valido da riga
	 * ---------------------------------------
	 * 
	 * La riga è già valida, non commento, non vuota etc.
	 * Se la riga è valorizzata da colonna 1 è il secondo token
	 * Altrimenti è il primo
	 * Le colonne da 1 a 7 possono non essere valorizzate da colonna 1
	 * 
	 */
	private String firstGoodTokenOnRow(Scanner scn, String row) {
		String token = "";
		
		token = nextToken(scn);	
		
		// Primo token da col >= 8
		if (scn.match().start() >= 7) {
			return token;
		}

		// Col 1-7 valorizzate da col 1
		if (scn.match().start() == 0) {
			token = nextToken(scn);				
			return token;
		}
		
		// col 1-7 non completamente piene
		if ((scn.match().start() + token.length()) > 7 ) {
			token = nextToken(scn);				
			return token;
		}
		
		// Inizio codifica errata in area A

		return token;
	}


	/* ------------------------------------------
	 * Restituisce true se la riga è da skippare
	 * ------------------------------------------
	 * 
	 */
    private boolean isRowToSkip(String row) {
    	
        Scanner scn = null;
        @SuppressWarnings("unused")
		String token = "";
        
        // Riga vuota/commento/continuazione/salto pagina/Numerazione 
		if (row.trim().equals("")) 					  										 {return true;}
		if (row.length() <=7)                         										 {return true;}
		if (row.length() >=7  && row.charAt(6) == '*') 										 {return true;}
		if (row.length() >= 7 && row.charAt(6) == '/')										 {return true;}
		if (row.length() > 7  && row.length() > 72 && row.substring(7, 73).trim().equals("")){return true;}
		if (row.length() > 7  && row.length() <= 72 && row.substring(7).trim().equals(""))   {return true;}
		if (row.length() > 72 && row.substring(0, 72).trim().equals(""))					 {return true;}

      	scn = new Scanner(row);
    	if (scn.hasNext()) {
        	token = nextToken(scn);							// col1-7
        	if (scn.match().start() == 0 && !scn.hasNext()) {
				return true;									// Riga vuota con numerazione/testo iniziale 
			}
		}
		return false;
	}



	/* ------------------------------------------
     * Sostituzione tabulazioni con space
     * ------------------------------------------
     * 
     * Ogni tabset allinea al primo multiplo di 8 il carattere successivo
     * 
     */
	private String replaceTabsWithSpace(String row) {
		String rowReplaced = "";
		String spaces = "          ";
        int rest = 0;
           
		// Scan row
		for (int i = 0; i < row.length(); i++) {
			
			if (!row.substring(i, i + 1).equals("\t")) {
				rowReplaced = rowReplaced + row.substring(i, i + 1);
				continue;
			}
			
            // Tab
			rest = rowReplaced.length() % 8;
					
			// Inserisco spazi per completamento allineamento
			rowReplaced = rowReplaced + spaces.substring(0, 8 - rest);
			
		}
		
		return rowReplaced;
	}



	
	/*---------------------------------------------
	 * Operazioni finali di analisi del programma.
	 * --------------------------------------------
	 * 
	 * Operazioni finali su data e procedure division.
	 * Operazioni finali sulla Data Division Analizzata e memorizzata.
	 * Vengono marcate le definizioni e i copy non utilizzati dal programma.
	 * Viene calcolata la lunghezza di tutti i gruppi presenti nel programma.
	 * Le strutture dei copy analizzati on-fly con i relativi oggetti copy sono già
	 * state caricate durante l'analisi ricorsiva dei copy dei quali si è gestito il
	 * copy stmt.
	 */
	private void finalPgm() throws Exception {
        
		
		computeElapsedTime();																	// Computo e memorizzazione tempo di parsing
		this.analyzerDbInfo.getObjAnalysisInfo().setMsParsing((int)this.timeMSElapsed);
		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.POST_PARSING_OPERATION;		// Info disponibile a fronte di eventuale exception

		/////////////////////////////////////////////////////////////////////////
		// (0) Il programma sotto analisi potrebbe essere stato precedentemente 
		// considerato in differenti sottosistemi.
		// Devo aggiornare il subSystemOwner al subSystem corrente, di tutti gli oggetti programma
		// presenti in ALTRI sottosistemi con lo stesso nome
		/////////////////////////////////////////////////////////////////////////
		
		sqlInsUpdateObjectSubSysOwner(this.pgmNameUnderParsing, EnumObject.OBJECT_PGM_COBOL, this.di.systemInput, this.di.subSystemInput); 
		
		/////////////////////////////////////////////////////////////////////////
        // (1) Completamento analisi di Data e Procedure division
		//     Controllo esistenza label/section in perform/goTo
		//     Individuazione e marcatura dead code
        /////////////////////////////////////////////////////////////////////////

		
		finalPgmCtrlExistsLabelParagraphSection();                  // Verifica se ogni label/section incontrata a fronte di goTo/perform sia definita
		if (!this.ictx.isAnyInstructionErrorDetected) {
	        finalPgmSetDivisionsRowsStartEnd();        				// Per ogni divisione numero riga sorgente di inizio/fine
	        finalPgmDataComputeGroupsLengthAndPos(); 			    // Calcola e aggiorna la lunghezza totale dei gruppi e la posizione dei campi 
	        finalPgmDataDeadCodeCopy();		  						// Individuazione copy non utilizzati e caricamento PGM_WITH_COPY_UNUSED 
			finalPgmDataDeadCodeDataItems();	  					// Scan definizioni data division e gestione marcatura campi non referenziati come dead code 
	        finalPgmProcSetInstructionInfo();        				// Completamento informazioni su istruzioni analizzate, chiusure etc
	        finalPgmProcDeadCodeInstructions();						// Scan istruzioni procedure division e marcatura codice morto  
			finalPgmProcDeadCodeCopy();								// Scan istruzioni procedure division e marcatura copy con istruzioni tutte dead code  			
			finalPgmIdDivSetCopy();						    		// Scan istruzioni identification division e inserimento nome copy in struttura programma
			finalPgmEnvDivSetCopy();						    	// Scan istruzioni environment division e inserimento nomi copy in struttura programma
			finalPgmDimensionalMeasures();							// Misure istruzioni, righe vuote etc.
			finalPgmOptionDimension();				    			// Inserimento opzione programma Small/Medium/Large/Huge
			finalPgmWhereUsedCopyItems();                      		// Inserimento where used campi copy Data e rel ENTITY_COPY
			finalPgmWhereUsedSqlColumns();                          // Inserimento where used colonne tabelle SQL 			
			finalPgmOptimize();                                     // Caricamento map goTo/Label/Section e ottimizazione
   			computeElapsedTime();									// Computo e memorizzazione tempo di operazioni post parsing
 			this.analyzerDbInfo.getObjAnalysisInfo().setMsPostParsingOperations((int)this.timeMSElapsed);
		}
		
        /////////////////////////////////////////////////////////////////////////////
        // (2) Soluzione istruzioni potenzialmente dinamiche localmente al programma
		//     Marcatura istruzioni dinamiche light come risolte su db
        /////////////////////////////////////////////////////////////////////////////
		
 		// Solo se NON ci sono stati errori che potrebbero pregiudicare la consistenza  
		if (!this.ictx.isAnyInstructionErrorDetected) {
			// La soluzione dinamica light risolve le istruzioni dinamiche con campi non movimentati con value
			if (di.optSolveDynamicLocal || di.optSolveDynamicLocalLight) {
				this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.DYNAMIC_CODE_SOLVING;		// Info disponibile a fronte di eventuale exception
			    solveInstructionsDynamicLocally();					// Tutte le istruzioni dinamiche sono da risolvere  TODO
				computeElapsedTime();								// Computo e memorizzazione tempo di soluzione istruzioni dinamiche light			 
	    		this.analyzerDbInfo.getObjAnalysisInfo().setMsDynamicCodeSolving((int)this.timeMSElapsed);
			}
			finalInsertOptionsDynamicCode();      					// Inserimento opzioni codice dinamico                
		}
		

		/////////////////////////////////////////////////////////////////////////////
        // (3) Calcolo metriche e individuazione violazioni
		//     Solo se opzioni abilitate in direttive di esecuzione
        /////////////////////////////////////////////////////////////////////////////

		if (!this.ictx.isAnyInstructionErrorDetected) {
			// METRICHE generali di programma di data/proc division sempre prodotte
			this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.METRIC_COMPUTING;		// Info disponibile a fronte di eventuale exception
	        metricsMeasurePgmDimensionalDataBasic(); 			// Misure dimensionali definizioni dati		
	        metricsMeasurePgmDimensionalProcBasic(this.metricsProgram, 0, this.programCobol.entriesProcedure().length - 1); 
	        metricsMeasurePgmProcDetail();    					// Calcolo metriche di dettaglio per mainline e ogni section/paragrafo richiamato
	        // Salvataggio metriche di programma e di dettaglio per ogni section/paragrafo in strutture per update db
			storeMetricsOnDbStructure(this.di.optMetricsBasic, this.di.optMetricsDetail && this.di.optMetricsPgmDetailOnDb); 
			computeElapsedTime();								// Computo e memorizzazione tempo di calcolo metriche			 
			this.analyzerDbInfo.getObjAnalysisInfo().setMsMetricComputing((int)this.timeMSElapsed);
			// VIOLAZIONI alle metriche
			this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.METRIC_VIOLATION_DETECTING;		// Info disponibile a fronte di eventuale exception
			metricsDetectViolation();                           // Individuazione violazioni (metodo pubblico)
			computeElapsedTime();								// Computo e memorizzazione tempo di individuazione violazioni 			 
    		this.analyzerDbInfo.getObjAnalysisInfo().setMsViolationDetecting((int)this.timeMSElapsed);
		}   

		///////////////////////////////////////////////////////////////////////////////////
        // (4) Logging Errori/warning di parsing o nelle elaborazioni post parsing
		//     Inserimento errori/warning nelle strutture db
		//     Si trattano le istruzioni di tutte le divisioni Cobol
        ///////////////////////////////////////////////////////////////////////////////////

		if (this.ictx.isAnyInstructionErrorDetected
		||  this.ictx.isAnyInstructionWarningDetected) {
			loggingParsingErrorsWarning();				
			if (this.ictx.isAnyInstructionErrorDetected) {
				this.di.isExecutionWithErrors = true;
				this.di.curObjectWithErrors = true;
			}
			// Solo se abilitato
			if (this.di.optTraceAnyAnalysisErrorOnDb ) {
				storeOnDbParsingErrorsWarningDivision(this.programCobol, this.analyzerDbInfo, this.analyzerDbInfo.getObjAnalysisInfo());  
			}
		}
		

		//////////////////////////////////////////////////////////////////////////////////////
        // (5) Persistenza su file system: programma, info dinamiche, metriche
        //////////////////////////////////////////////////////////////////////////////////////
  
		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.PROGRAM_SERIALIZATION;		// Info disponibile a fronte di eventuale exception
		String retCreateIdxSource = "";
		retCreateIdxSource=createIdxSource();   							// Creazione in una stringa (rowStart rowEnd numInstr|rowStart rowEnd numInstr|.....)
 		putSerialized(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjPgm(), SUFFIX_SERIALIZED_PGM, this.programName, this.programCobol);
 		computeElapsedTime();					 				// Computo e memorizzazione tempo di scrittura su disco pgm serializzato
 		this.analyzerDbInfo.getObjAnalysisInfo().setMsSerializationPgm((int)this.timeMSElapsed);
    
    
        /////////////////////////////////////////////////////////////////////////
        // (6) Persistenza su db
        /////////////////////////////////////////////////////////////////////////

		// Aggiornamento stato analisi programma 
 		logMessage(EnumMessageType.INFORMATION, "MI0309", this.pgmNameUnderParsing);
        if (this.ictx.isAnyInstructionErrorDetected) {
        	analyzerDbInfo.al_DbObject.get(idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_ERRORS);      
		} else {
			analyzerDbInfo.al_DbObject.get(idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS); 
			if (this.ictx.isWithDynamicCode) {
				if (this.ictx.isWithDynamicCodeSolved 
				&& !this.ictx.isWithDynamicCodeSpreadedToSolve 
				&& !(this.ictx.isWithDynamicCodeWaitingForData)) {
					analyzerDbInfo.al_DbObject.get(idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_SOLVED); 
				} else if (this.ictx.isWithDynamicCodeWaitingForData) {				
					analyzerDbInfo.al_DbObject.get(idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_WAITING_FOR_DATA);  
				} else if (this.ictx.isWithDynamicCodeSpreadedToSolve) {
					analyzerDbInfo.al_DbObject.get(idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_DYNAMIC_SPREAD_TO_SOLVE);  
				}
			}
		}
         
        // Aggiornamenti complessivi effettivi base dati
        if (this.di.optUpdateDb) {
        	// Delete preventivo db
    		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.DB_DELETE;		      // Info disponibile a fronte di eventuale exception
    		this.analyzerDbInfo.sqlDeleteProgramLevel(this.programName);	  			  // Delete a livello programma
        	this.analyzerDbInfo.sqlDeleteGenericLevel();					  			  // Delete generici
     		computeElapsedTime();													      // Computo e memorizzazione tempo di delete db			 
    		this.analyzerDbInfo.getObjAnalysisInfo().setMsDbDelete((int)this.timeMSElapsed);
        	// Update db
    		this.di.curTypeProcessAnalysis = EnumTypeProcessAnalysis.DB_UPDATE;		      // Info disponibile a fronte di eventuale exception
    		this.analyzerDbInfo.update(true, false, this.programName, ictx); 			  // Updates db generali
    		this.analyzerDbInfo.sqlUpdateGenericLevel();                      			  // Updates db specifici
    		computeElapsedTime();													      // Computo e memorizzazione tempo di update db			 
     		this.analyzerDbInfo.getObjAnalysisInfo().setMsDbUpdate((int)this.timeMSElapsed);
            // Update data analisi, ora inizio/fine ed elapsed totale in ms
     		this.di.curTimeMsEnd = System.currentTimeMillis();
     		this.di.curTimeMsElapsed = this.di.curTimeMsEnd - this.di.curTimeMsStart;
     		this.updateOnDbPendingErrorsWarningDateTimeElapsed(this.analyzerDbInfo.getObjAnalysisInfo());
     		this.analyzerDbInfo.updateInfo(false);							 			 // Update info db analisi con ultimi valori aggiornati
		}
 
		
		/////////////////////////////////////////////////////////////////////////
        // (7) Statistiche finali di elaborazione
        /////////////////////////////////////////////////////////////////////////

		Long timeElapsed = Long.valueOf(this.di.curTimeMsElapsed);
		
		// Messaggio di fine elaborazione
        if (this.ictx.isAnyInstructionErrorDetected) {
        	logMessage(EnumMessageType.INFORMATION, "MI0113", this.pgmNameUnderParsing, timeElapsed.toString(), this.si.getArrayRowSource().length+"", programCobol.entriesData().length+"", programCobol.entriesProcedure().length+"");    
		} else {
			logMessage(EnumMessageType.INFORMATION, "MI0114", this.pgmNameUnderParsing, timeElapsed.toString(), this.si.getArrayRowSource().length+"", programCobol.entriesData().length+"", programCobol.entriesProcedure().length+""); 
		}
 	}
    
	/*
	 * Creazione stringa con rowStart1 rowEnd1 numInstr1 +|rowStart2 rowEnd2 numInstr2 +|.....
	 * NON vengono inseriti i riferimenti ad items DENTRO copy (individuati con "+" in expand)
	 */
	private String createIdxSource() {
		ProgramCobolEntry<? extends Instruction>[] ar_entryDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDivision = null;
		Instruction instr = null;
		InstructionCobol instrCobol = null;
		InstructionSql instrSql = null;
		String idxFile = "";
		String sep = "";
		String division = "";   // Identification, Data, Environment, Procedure
		String expand = "";     // + se copy entry, - altrimenti
		String retPut = "";
		String idCopy = "";
		int i;
	
		// Ciclo generale di analisi identification division  
		ar_entryDivision = this.programCobol.entriesIdentification();
		for (i = 0; i < ar_entryDivision.length; i++) {			
			entryDivision = ar_entryDivision[i];
			instr = entryDivision.getInstruction();
			expand = "-";
			if (entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
				expand = "+";
				idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " I " + expand;
				sep = "|";
				idCopy = entryDivision.getUnderCopyName();
				continue;
			}
			
			// Statement dentro copy
			if (!entryDivision.getUnderCopyName().equals("")) {
				continue;
			}
			
			// Entry normale non sotto copy
			idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " I " + expand;
			sep = "|";

		} // end-for 		 

		// Ciclo generale di analisi environment division  
		ar_entryDivision = this.programCobol.entriesEnvironment();
		for (i = 0; i < ar_entryDivision.length; i++) {			
			entryDivision = ar_entryDivision[i];
			instr = entryDivision.getInstruction();
			expand = "-";
			if (entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
				expand = "+";
				idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " E " + expand;
				sep = "|";
				idCopy = entryDivision.getUnderCopyName();
				continue;
			}
			
			// Statement dentro copy
			if (!entryDivision.getUnderCopyName().equals("")) {
				continue;
			}
						
			// Entry normale non sotto copy
			idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " E " + expand;
			sep = "|";

		} // end-for 		 

		// Ciclo generale di analisi data division  
		ar_entryDivision = this.programCobol.entriesData();
		for (i = 0; i < ar_entryDivision.length; i++) {			
			entryDivision = ar_entryDivision[i];
			instr = entryDivision.getInstruction();
			if (entryDivision.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) {
				instrSql = (InstructionSql) instr;
			}
			expand = "-";
			
			// COPY stmt o INCLUDE Sql
			if ((entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY)
            || (entryDivision.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) && instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE)
			{
				expand = "+";
				idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " D " + expand;
				sep = "|";
				if (entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
					idCopy = entryDivision.getUnderCopyName();					
				} else {
					idCopy = instrSql.sqlIncludeGetName();
				}
				continue;
			}
			
			// Statement dentro copy
			if (!entryDivision.getUnderCopyName().equals("")) {
				continue;
			}

			// Entry normale non sotto copy
			idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " D " + expand;
			sep = "|";

		} // end-for 		 

		// Ciclo generale di analisi procedure division  
		ar_entryDivision = this.programCobol.entriesProcedure();
		for (i = 0; i < ar_entryDivision.length; i++) {			
			entryDivision = ar_entryDivision[i];
			instr = entryDivision.getInstruction();
			expand = "-";
			
			// COPY stmt o INCLUDE Sql
			if ((entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY)
		    || (entryDivision.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) && instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE)	{
				expand = "+";
				idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " P " + expand;
				sep = "|";
				if (entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
					idCopy = entryDivision.getUnderCopyName();					
				} else {
					idCopy = instrSql.sqlIncludeGetName();
				}
				continue;
			}
			
			// INCLUDE Sql
			if (entryDivision.getInstruction().getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
					
				}
				expand = "+";
				idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " P " + expand;
				sep = "|";
				instrSql = (InstructionSql) entryDivision.getInstruction();
				idCopy = instrSql.sqlIncludeGetName();
				continue;
			}
			
			// Statement dentro copy/include
			if (!entryDivision.getUnderCopyName().equals("")) {
				continue;
			}
					
			// Entry normale non sotto copy
			idxFile = idxFile + sep + instr.getRowStartSource() + " " + instr.getRowEndSource() + " "  + instr.getNumInstr() + " P " + expand;
			sep = "|";

		} // end-for 		 
		
		idxFile+=System.lineSeparator();     // LineFeed CarriageReturn
				
 		retPut = AmritaStartup.sm.putFile(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjPgm(), this.programName, SUFFIX_SERIALIZED_PGM_IDX, idxFile);

		return retPut;
	}


	/*---------------------------------------------
	 * Operazioni finali di analisi del copy cobol.
	 * --------------------------------------------
	 * 
	 * Updates stato analisi
	 * Delete  preliminare dati
	 * Updates standard entity
	 * Updates eventuali generici presenti
	 */
	private void finalCopyOperations(String copyName) throws Exception {
		
		// Aggiornamento stato analisi modulo copy 
        if (this.ictx.isAnyInstructionErrorDetected) {
        	this.analyzerDbInfo.al_DbObject.get(this.idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_ERRORS);      
		} else {
			this.analyzerDbInfo.al_DbObject.get(this.idxPgmCopyInDbObject).setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS);   
		}
         
        // Aggiornamenti complessivi effettivi base dati  
        if (this.di.optUpdateDb) {
        	this.analyzerDbInfo.sqlDeleteCopyLevel(copyName);             				// Delete preliminare da tabelle
        	this.analyzerDbInfo.update(true, false, copyName, this.ictx); 				// Update specifici
    		this.analyzerDbInfo.sqlUpdateGenericLevel();                    			// Updates db generici

		}
		
		
	}
 

	
	/*
	 * -----------------------------------------------------
	 * Caricamento map GoTo/Label/Section e ottimizzazione
	 * -----------------------------------------------------
	 * 
	 */
	private void finalPgmOptimize() {
		this.programCobol.setAnalysisMapGoTo(this.map_GoTo);
		this.programCobol.setAnalysisMapLabelSection(this.map_LabelSection);
		this.programCobol.optimize();                   		// Ottimizzazione oggetto programCobol
	}


	/*
     * ------------------------------------------------------------------
     * Controllo esistenza label/paragrafi/section richiamati 
     * ------------------------------------------------------------------
     * 
     * Si utilizza la map aggiornata a fronte di goTo/Perform/Label/Section
     * Si verifica che la label/section sia definita
     * Se non lo è si marca errore semantico nelle istruzioni che referenziano
     * Si marcano i flag generali di errore
     * 
    */
	@SuppressWarnings("unchecked")
	private void finalPgmCtrlExistsLabelParagraphSection() throws  ExceptionAmrita {

		ProgramCobolEntry<? extends Instruction> entryProc = null;
		Instruction instrGeneric = null;
		ArrayList<Integer> al_numInstrDef = null;
		ArrayList<Integer> al_numInstrGoTo = null;
		ArrayList<Integer> al_numInstrPerform = null;
		Object ar_object[] = null;
		String labelSection = "";
		 
		// Scan map_labelSection individuate da section/label/goTo/perform
		for (Entry<String, Object[]> entry_map_LabelSection : this.map_LabelSection.entrySet()) {
			
			labelSection = entry_map_LabelSection.getKey();					//
			ar_object = entry_map_LabelSection.getValue();
			al_numInstrDef = (ArrayList<Integer>) ar_object[4];				// Numeri istruzione di definizione (potrebbero essere in + section)
			al_numInstrGoTo = (ArrayList<Integer>) ar_object[1];			// Numeri istruzione con goTo    a label/section
			al_numInstrPerform = (ArrayList<Integer>) ar_object[2];			// Numeri istruzione con perform a label/section
			
			// Label/section definita nel programma
			if (al_numInstrDef.size() > 0) {
				continue;
			}
			
			// Perform/GoTo e section/label NON definite nel programma 
			
			// Scan istruzioni perform con xref a undefined
			for (Integer numInstr : al_numInstrPerform) {
				entryProc = this.programCobol.entryProcedure(numInstr);
				instrGeneric = entryProc.getInstruction();
				instrGeneric.setSemanticError(true);
				instrGeneric.setTokenInError(labelSection);
				instrGeneric.setMsgType(EnumMessageType.ERROR_INPUT);
				instrGeneric.setMsgParm(this.pgmNameUnderParsing, labelSection);
				instrGeneric.setMsgCode("EI0037");
				this.ictx.isAnyInstructionErrorDetected = true;

			}
			// Scan istruzioni goTo con xref a undefined
			for (Integer numInstr : al_numInstrGoTo) {
				entryProc = this.programCobol.entryProcedure(numInstr);
				instrGeneric = entryProc.getInstruction();
				instrGeneric.setSemanticError(true);
				instrGeneric.setTokenInError(labelSection);
				instrGeneric.setMsgType(EnumMessageType.ERROR_INPUT);
				instrGeneric.setMsgParm(this.pgmNameUnderParsing, labelSection);
				instrGeneric.setMsgCode("EI0038");
				this.ictx.isAnyInstructionErrorDetected = true;
			}
			
		} // end-for label/section
		
	}



	/*
	 * Calcolo elapsed time e impostazione per successivo
	 */
    private void computeElapsedTime() {
    	
    	// Calcolo elapsed time
		this.timeMSEnd = System.currentTimeMillis();
		this.timeMSElapsed = this.timeMSEnd - this.timeMSStart;

		// Per successivo conteggio
		this.timeMSStart = this.timeMSEnd;
		this.timeMSEnd = 0;
	}


	/* ------------------------------------------------------
     * Update flag istruzioni dinamiche light come solved
     * ------------------------------------------------------
     * 
     * Le istruzioni dinamiche light sono state caricate nella
     * struttura di aggiornamento db DynamicField di AnalyzerDbInfo ed è
     * necessario aggiornare i flag di soluzione.
     * Le istruzioni possono avere piu campi dinamici, come Cancel A, B, C
     * 
     */
	private void finalPgmMarkDynamicLightSolved() {
	
		EntityDynamicField edf = null;	
		EntityDynamicFieldSubValue edfsv = null;
        Instruction instructionGeneric = null;
		ProgramCobolEntry<? extends Instruction>[] ar_entryProcDivision = null;
	    ar_entryProcDivision = this.programCobol.entriesProcedure();
		int i = 0;             // Indice su struttura db con campi dinamici istruzioni
		int iStartField = 0;                    // First entry in al_DbDynamicField X istruzione
		int iEndField = 0;                      // Last  entry in al_DbDynamicFieldSubValue X istruzione
		int iStartFieldValue = 0;               // First entry in al_DbDynamicFieldSubValue X istruzione
		int iEndFieldValue = 0;
	    
		// Scan istruzioni di procedure
		for (ProgramCobolEntry<? extends Instruction> procEntry : ar_entryProcDivision) {
			instructionGeneric = procEntry.getInstruction();
			
			// Interessano solo le istruzioni dinamiche light, risolvibili nello stesso programma
			if (!instructionGeneric.isDynamic()) {continue;}
			if (!instructionGeneric.isDynamicLight()) {continue;}

		    instructionGeneric.setDynamicSolved(false);
		    instructionGeneric.setDynamicSolvedFull(true);

			// Scan campi di istruzioni dinamiche inserite per il programma
			// Se almeno un campo è stato  risolto è DynamicSolved
			// Se tutti i campi sono stati risolti è DynamicSolvedFull
			
			// Primo/Ultimo campo istruzione dinamica in struttura db
			for (iStartField = 0; iStartField < this.analyzerDbInfo.al_DbDynamicField.size(); iStartField++) {
				edf=this.analyzerDbInfo.al_DbDynamicField.get(iStartField);
				if (edf.getNumInstr() == instructionGeneric.getNumInstr()) {break;}
			}			
			// Nessun campo istruzione trovato in struttura db: Next istruzione
			if (iStartField > this.analyzerDbInfo.al_DbDynamicField.size()) {
				continue;   // Next istruzione
			} 
			for (iEndField = iStartField; iStartField < this.analyzerDbInfo.al_DbDynamicField.size(); iEndField++) {
				edf=this.analyzerDbInfo.al_DbDynamicField.get(iStartField);
				if (edf.getNumInstr() == instructionGeneric.getNumInstr()) {break;}
			}			
			// Primo/ultimo valore campi in istruzione dinamica in struttura db
			for (iStartFieldValue = 0; iStartFieldValue < this.analyzerDbInfo.al_DbDynamicFieldSubValue.size(); iStartFieldValue++) {
				edfsv=this.analyzerDbInfo.al_DbDynamicFieldSubValue.get(iStartFieldValue);
				if (edfsv.getNumInstr() == instructionGeneric.getNumInstr()) {break;}
			}			
			if (iStartFieldValue < this.analyzerDbInfo.al_DbDynamicFieldSubValue.size()) {
				for (iEndFieldValue = iStartFieldValue; iEndFieldValue < this.analyzerDbInfo.al_DbDynamicFieldSubValue.size(); iEndFieldValue++) {
					edfsv=this.analyzerDbInfo.al_DbDynamicFieldSubValue.get(iEndFieldValue);
					if (edfsv.getNumInstr() == instructionGeneric.getNumInstr()) {break;}
				}			
			} 
			
			
			// Verifico valori campi dinamici dell'istruzione
			for (i = iStartField; i <= iEndField; i++){
			    edf=this.analyzerDbInfo.al_DbDynamicField.get(i);
			    if (edf.getNumInstr() > instructionGeneric.getNumInstr()) {break;}	
			    
			    // Cerca valori campo dinamico in struttura db e update flags
			    if (isDynamicValueFound(edf, iStartFieldValue, iEndFieldValue)) {
			    	instructionGeneric.setDynamicSolved(true);
			    	edf.setSolved(true);
				} else {
			    	instructionGeneric.setDynamicSolvedFull(false);
			    	edf.setSolvedFull(false);
				}				
			}			
		} // Next instruction
	}

    /*
     *  Restituisce true se presenti valori dinamici per il campo in edf
     *  per l'istruzione sotto esame
     */
	private boolean isDynamicValueFound(EntityDynamicField edf, int iStartFieldValue, int iEndFieldValue) {
		EntityDynamicFieldSubValue edfsv = null;
		int i=0;
		
		for (i=iStartFieldValue; i <= iEndFieldValue; i++) {
			edfsv = this.analyzerDbInfo.al_DbDynamicFieldSubValue.get(i);
			if (edfsv.getIdField().equals(edf.getIdField())) {return true;}  // Valore trovato per il campo
		}
		return false;
	}


	/**  
     * Calcolo metriche di dettaglio per tutte le section, paragrafi richiamati e la mainline del programma.<br>
     * <p>
     * Questo metodo viene attivato a fine analisi programma o dalle elaborazioni post analisi<br>
     * a livello di programma, come indicato nelle direttive di esecuzione.<br>
     * <p>
     * Si calcolano le metriche a livello di mainline di programma  <br>
     * Si calcolano le metriche per ogni paragrafo/section richiamato <br>
     * Si calcolano i valori minimi/massimi/medi degli indici previsti <br>
     * <p>
     * 
     */
	public void metricsMeasurePgmProcDetail() throws ExceptionAmrita, SQLException {

		Metrics metricsProcedure = null;
		InnerInternalProcedure innerInternalProcedure = null;

		// Indici di complessita/manutenibilità minimi
		double idxMILow = 999999999;                        // IMII MI       Indice di manutenibilità introdotta nel 1991 da Oman e Hagemeister
		double idxFPLow = 999999999;                        // IFPP FP       IndiceNumero punti funzione
		double idxMcCabeLow = 999999999;                    // IMCB MCBEI    Indice di complessità ciclomatica di McCabe con il seguente significato
		double idxReHostingLow = 999999999;                 // IREH RHI      Indice della complessità e sforzo di rehosting di una applicazione.

		// Indici di complessita/manutenibilità massimi
		double idxMIHigh = 0;                            	// IMII MI       Indice di manutenibilità introdotta nel 1991 da Oman e Hagemeister
		double idxFPHigh = 0;                              	// IFPP FP       IndiceNumero punti funzione
		double idxMcCabeHigh = 0;                           // IMCB MCBEI    Indice di complessità ciclomatica di McCabe con il seguente significato
		double idxReHostingHigh = 0;                        // IREH RHI      Indice della complessità e sforzo di rehosting di una applicazione.

		// Indici di complessita/manutenibilità cumulativi per le medie
		double idxMITot = 0;                            	// IMII MI       Indice di manutenibilità introdotta nel 1991 da Oman e Hagemeister
		double idxFPTot = 0;                              	// IFPP FP       IndiceNumero punti funzione
		double idxMcCabeTot = 0;                           	// IMCB MCBEI    Indice di complessità ciclomatica di McCabe con il seguente significato
		double idxReHostingTot = 0;                        	// IREH RHI      Indice della complessità e sforzo di rehosting di una applicazione.

		// Misure stimate con sizeLinesCodeLogical Totali
		double  backFiredFunctionPointTot = 0;   		    // BFFP BFFP     Function point stimati in base al numero logico di loc (sizeLinesCodeLogical)
		double timeDevelopmentTot = 0;     			        // TMDV TMDV     Tempo di sviluppo in giorni stimato in base alla produttività media giornaliera

		// Misure di complessità di Halstead (o Software Science) totali
		long  halsteadOperatorsOccTot = 0;                  // HPTO HLSTN1   Numero occorrenze di operatori (#IF)
		long  halsteadOperandsOccTot = 0;                   // HPNO HLSTN2   Numero occorrenze di operandi (#utilizzi campo)
		long  halsteadLengthPgmTot = 0;                     // HLNP HLSTL    Lunghezza programma
		long  halsteadVocabularyPgmTot = 0;                 // HVBP HLSTn    Vocabolario programma
		double halsteadVolumePgmTot = 0;                    // HVLP HLSTV    Volume programma
		double halsteadDifficultPgmTot = 0;                 // HDFP HLSTD    Difficoltà programma
		double halsteadEffortPgmTot = 0;                    // HEFP HLSTS    Sforzo programma
		long halsteadTimeWritingTot = 0;                    // HTMW HLSTT    Tempo stimato di scrittura programma in secondi
		
		// Misure di McCabe basate sui grafi di mainline/section/paragrafi
		long  mcCabeArcsTot = 0;                            // MARC MCBEE    Numero archi di programma
		long  mcCabeNodesTot = 0;                           // MNOD MCBEN    Numero nodi di programma
		long  mcCabeOperatorsOrAndTot = 0;                  // MOPC MCBEX    Numero operatori condizionali OR AND
		long  mcCabeGraphConnTot = 0;                       // MGNC MCBEP    Numero di sottografi connessi, in cobol sono section non referenziate

		
		// Istruzion i dinamiche totali
		long dynamicInstrTot = 0;              	    		// DYN02 DINT    Numero istruzioni dinamiche totali
		long dynamicInstrLightTot = 0;              	   	// DYN03 DINL    Numero istruzioni dinamiche light, con soli campi con value
		
		// Varie
		String idProcedurePerformed = "";						// Coincide con nome section o paragrafoo performato
		int cntProcedurePerformed = 0;
		int cntSections = 0;
		int cntParagraphs = 0;
 		
        
	    // Metriche disabilitate
	    if (!this.di.optMetricsAll && !this.di.optMetricsDetail) {
			return;
		}
		
		
		///////////////////////////////////////////////////////////////////
		// Metriche della mainline del programma
		///////////////////////////////////////////////////////////////////
		
		// Metriche di base 
        metricsMeasurePgmDimensionalProcBasic(this.metricsProgramMainline, 0, this.programCobol.getNumLastInstrMainline()); 
		
        // Metriche stimate
        this.metricsProgramMainline.evaluateTimeDevelopment();
        this.metricsProgramMainline.evaluateBackFiredFunctionPoint();
        
        // Metriche di McCabe, si contano nodi e archi nel grafo e si calcola l'indice con la formula semplificata
        if (di.optMetricsAll || di.optMetricsMcCabe) {
        	evaluatePgmMetricsMcCabeSemplified(0, this.programCobol.getNumLastInstrMainline(), this.metricsProgramMainline);
        }
        	
        // Metriche di Halstead
        if (di.optMetricsAll || di.optMetricsHalstead) {
          	evaluatePgmMetricsHalstead(0, this.programCobol.getNumLastInstrMainline(), this.metricsProgramMainline);// Metodo pubblico di valutazione metriche di programma
        }
        
        // A livello di mainline i valori High/Low/Tot coincidono con quelli medi
        this.metricsProgramMainline.setIdxMILow(this.metricsProgramMainline.getIdxMIAvg());
        this.metricsProgramMainline.setIdxMIHigh(this.metricsProgramMainline.getIdxMIAvg());
        this.metricsProgramMainline.setIdxMITot(this.metricsProgramMainline.getIdxMIAvg());
        this.metricsProgramMainline.setIdxMcCabeLow(this.metricsProgramMainline.getIdxMcCabeAvg());
        this.metricsProgramMainline.setIdxMcCabeHigh(this.metricsProgramMainline.getIdxMcCabeAvg());
        this.metricsProgramMainline.setIdxMcCabeTot(this.metricsProgramMainline.getIdxMcCabeAvg());
        this.metricsProgramMainline.setIdxFPLow(this.metricsProgramMainline.getIdxFPAvg());
        this.metricsProgramMainline.setIdxFPHigh(this.metricsProgramMainline.getIdxFPAvg());
        this.metricsProgramMainline.setIdxFPTot(this.metricsProgramMainline.getIdxFPAvg());
        this.metricsProgramMainline.setIdxReHostingLow(this.metricsProgramMainline.getIdxReHostingAvg());
        this.metricsProgramMainline.setIdxReHostingHigh(this.metricsProgramMainline.getIdxReHostingAvg());
        this.metricsProgramMainline.setIdxReHostingTot(this.metricsProgramMainline.getIdxReHostingAvg());
        this.metricsProgramMainline.setIdxReHostingTot(this.metricsProgramMainline.getIdxReHostingAvg());

        // Indice di manutenibilita mainline programma necessita di McCabe e Halstead
        if (di.optMetricsAll 
        || (di.optMetricsMcCabe && di.optMetricsHalstead)) {
	    	this.metricsProgramMainline.computeIdxMI();       		// Calcolo indice di manutenibilità, integra McCabe e Halstead
        }
 
        // Valori stimati
        this.metricsProgramMainline.evaluateTimeDevelopment();
        this.metricsProgramMainline.evaluateBackFiredFunctionPoint();

        // Valori cumulativi: si inizia dalla mainline
		idxMITot =  this.metricsProgramMainline.getIdxMIAvg();                           
		idxFPTot = this.metricsProgramMainline.getIdxFPAvg();                         
		idxMcCabeTot = this.metricsProgramMainline.getIdxMcCabeAvg();                           
		idxReHostingTot = this.metricsProgramMainline.getIdxReHostingAvg();                               
		backFiredFunctionPointTot = this.metricsProgramMainline.getBackFiredFunctionPoint(); 
		timeDevelopmentTot = this.metricsProgramMainline.getTimeDevelopment();   			 
		halsteadOperatorsOccTot = this.metricsProgramMainline.getHalsteadOperatorsOcc();              
		halsteadOperandsOccTot = this.metricsProgramMainline.getHalsteadOperandsOcc();              
		halsteadLengthPgmTot = this.metricsProgramMainline.getHalsteadLengthPgm();                 
		halsteadVocabularyPgmTot = this.metricsProgramMainline.getHalsteadVocabularyPgm();                  
		halsteadVolumePgmTot = this.metricsProgramMainline.getHalsteadVolumePgm();                 
		halsteadDifficultPgmTot = this.metricsProgramMainline.getHalsteadDifficultPgm();            
		halsteadEffortPgmTot = this.metricsProgramMainline.getHalsteadEffortPgm();                    
		halsteadTimeWritingTot = this.metricsProgramMainline.getHalsteadTimeWriting(); 
		mcCabeArcsTot = this.metricsProgramMainline.getMcCabeArcs();        
		mcCabeNodesTot = this.metricsProgramMainline.getMcCabeNodes();                         
		mcCabeOperatorsOrAndTot = this.metricsProgramMainline.getMcCabeOperatorsOrAnd();                 
		mcCabeGraphConnTot = this.metricsProgramMainline.getMcCabeGraphConn();                        
		dynamicInstrTot = this.metricsProgramMainline.getDynamicInstr();              	    		 
		dynamicInstrLightTot = this.metricsProgramMainline.getDynamicInstrLight();                	   		 
        
        
		///////////////////////////////////////////////////////////////////
		// Metriche per ogni procedura interna definita e/o richiamata
		///////////////////////////////////////////////////////////////////

		// Scan procedure interne richiamate con Perform 
		for (Entry<String, InnerInternalProcedure> procedureEntry : map_InternalProcedure.entrySet()) {
			
			innerInternalProcedure = procedureEntry.getValue();
			idProcedurePerformed = innerInternalProcedure.idProcedurePerformed;
			cntProcedurePerformed++;
			if (this.programCobol.isSection(idProcedurePerformed)) {
				cntSections++;
			} else {
				cntParagraphs++;
			}

			metricsProcedure = new Metrics(ucfg, di);
			metricsProcedure.setSystem(this.di.systemInput);
			metricsProcedure.setSubSystem(this.di.subSystemInput);
			metricsProcedure.setScope(EnumMetricsScope.SCOPE_LEVEL_SECTION);
			metricsProcedure.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			metricsProcedure.setIdObject(this.pgmNameUnderParsing);
			metricsProcedure.setSection(innerInternalProcedure.idProcedurePerformed);                           // TODO ?????????????????????????
			this.programCobol.getMetricsProgramSections().add(metricsProcedure); 										 
			
			// Metriche di base
	        metricsMeasurePgmDimensionalProcBasic(metricsProcedure, innerInternalProcedure.instrFrom, innerInternalProcedure.instrTo); 

	        // Metriche stimate
	        metricsProcedure.evaluateTimeDevelopment();
	        metricsProcedure.evaluateBackFiredFunctionPoint();
			 
	        // Metriche di McCabe, si contano nodi e archi nel grafo e si calcola l'indice con la formula semplificata
	        if (di.optMetricsAll || di.optMetricsMcCabe) {
	          	evaluatePgmMetricsMcCabeSemplified(innerInternalProcedure.instrFrom, innerInternalProcedure.instrTo, metricsProcedure);
	        }
	        	
	        // Metriche di Halstead
	        if (di.optMetricsAll || di.optMetricsHalstead) {
	          	evaluatePgmMetricsHalstead(innerInternalProcedure.instrFrom, innerInternalProcedure.instrTo, metricsProcedure);					 
	        }
	        
	        // Indice di manutenibilita procedura necessita di McCabe e Halstead già disponibili
	        if (di.optMetricsAll 
	        || (di.optMetricsMcCabe && di.optMetricsHalstead)) {
	        	metricsProcedure.computeIdxMI();       		 
	        }
			
	        // Accodamento metriche procedura in struttura complessiva
	        this.al_metricsProgramSection.add(metricsProcedure);
			
	        // A livello di section/paragrafo i valori High/Low/Tot coincidono con quelli medi
	        metricsProcedure.setIdxMcCabeLow(metricsProcedure.getIdxMcCabeAvg());
	        metricsProcedure.setIdxMcCabeHigh(metricsProcedure.getIdxMcCabeAvg());
	        metricsProcedure.setIdxMcCabeTot(metricsProcedure.getIdxMcCabeAvg());
	        metricsProcedure.setIdxFPLow(metricsProcedure.getIdxFPAvg());
	        metricsProcedure.setIdxFPHigh(metricsProcedure.getIdxFPAvg());
	        metricsProcedure.setIdxFPTot(metricsProcedure.getIdxFPAvg());
	        metricsProcedure.setIdxReHostingLow(metricsProcedure.getIdxReHostingAvg());
	        metricsProcedure.setIdxReHostingHigh(metricsProcedure.getIdxReHostingAvg());
	        metricsProcedure.setIdxReHostingTot(metricsProcedure.getIdxReHostingAvg());

	        // Indice di manutenibilita necessita di McCabe e Halstead
	        if (di.optMetricsAll 
	        || (di.optMetricsMcCabe && di.optMetricsHalstead)) {
		    	metricsProcedure.computeIdxMI();       					// Calcolo indice di manutenibilità, integra McCabe e Halstead
		        metricsProcedure.setIdxMITot(metricsProcedure.getIdxMIAvg());
		        metricsProcedure.setIdxMILow(metricsProcedure.getIdxMIAvg());
		        metricsProcedure.setIdxMIHigh(metricsProcedure.getIdxMIAvg());
	        }
	        
  	        // Valori cumulativi
			idxMITot = idxMITot +  metricsProcedure.getIdxMIAvg();                         
			idxFPTot = idxFPTot +  metricsProcedure.getIdxFPAvg();                         
			idxMcCabeTot = idxMcCabeTot +  metricsProcedure.getIdxMcCabeAvg();                           
			idxReHostingTot = idxReHostingTot +  metricsProcedure.getIdxReHostingAvg();                               
			backFiredFunctionPointTot += metricsProcedure.getBackFiredFunctionPoint(); 
			timeDevelopmentTot += metricsProcedure.getTimeDevelopment();   			 
			halsteadOperatorsOccTot += metricsProcedure.getHalsteadOperatorsOcc();              
			halsteadOperandsOccTot += metricsProcedure.getHalsteadOperandsOcc();              
			halsteadLengthPgmTot += metricsProcedure.getHalsteadLengthPgm();                 
			halsteadVocabularyPgmTot += metricsProcedure.getHalsteadVocabularyPgm();                  
			halsteadVolumePgmTot += metricsProcedure.getHalsteadVolumePgm();                 
			halsteadDifficultPgmTot += metricsProcedure.getHalsteadDifficultPgm();            
			halsteadEffortPgmTot += metricsProcedure.getHalsteadEffortPgm();                    
			halsteadTimeWritingTot += metricsProcedure.getHalsteadTimeWriting();                   
			mcCabeArcsTot += metricsProcedure.getMcCabeArcs();        
			mcCabeNodesTot += metricsProcedure.getMcCabeNodes();                         
			mcCabeOperatorsOrAndTot += metricsProcedure.getMcCabeOperatorsOrAnd();                 
			mcCabeGraphConnTot += metricsProcedure.getMcCabeGraphConn();                        
			dynamicInstrTot += metricsProcedure.getDynamicInstr();              	    		 
			dynamicInstrLightTot += metricsProcedure.getDynamicInstrLight();                	   		 
		
	        // Valori Minimi
			if (metricsProcedure.getIdxMILow() <= idxMILow) {
				idxMILow = metricsProcedure.getIdxMIAvg();
			}
			if (metricsProcedure.getIdxFPLow() <= idxFPLow) {
				idxFPLow = metricsProcedure.getIdxFPAvg();
			}
			if (metricsProcedure.getIdxMcCabeLow() <= idxMcCabeLow) {
				idxMcCabeLow = metricsProcedure.getIdxMcCabeLow();
			}
			if (metricsProcedure.getIdxReHostingLow() <= idxReHostingLow) {
				idxReHostingLow = metricsProcedure.getIdxReHostingLow();
			}
			
	        // Valori Massimi
			if (metricsProcedure.getIdxMIHigh() >= idxMIHigh) {
				idxMIHigh = metricsProcedure.getIdxMIAvg();
			}
			if (metricsProcedure.getIdxFPHigh() >= idxFPHigh) {
				idxFPHigh = metricsProcedure.getIdxFPHigh();
			}
			if (metricsProcedure.getIdxMcCabeHigh() >= idxMcCabeHigh) {
				idxMcCabeHigh = metricsProcedure.getIdxMcCabeHigh();
			}
			if (metricsProcedure.getIdxReHostingHigh() >= idxReHostingHigh) {
				idxReHostingHigh = metricsProcedure.getIdxReHostingHigh();
			}
			
		} // end-for
		
        
		///////////////////////////////////////////////////////////////////
		// Metriche a livello di programma
		///////////////////////////////////////////////////////////////////

		// Numero section e paragrafi
		this.metricsProgram.setStructSections(cntSections);
		this.metricsProgram.setStructParagraphs(cntParagraphs);
		
		// Update valori massimi, minimi e totali per le metriche di programma McCabe
		this.metricsProgram.setIdxMcCabeLow(idxMcCabeLow);
		this.metricsProgram.setIdxMcCabeHigh(idxMcCabeHigh);
		this.metricsProgram.setIdxMcCabeTot(idxMcCabeTot + this.metricsProgramMainline.getIdxMcCabeTot()); // Adjusted dopo 
		// Update valori massimi, minimi e totali per le metriche di programma FP
		this.metricsProgram.setIdxFPLow(idxFPLow);
		this.metricsProgram.setIdxFPHigh(idxFPHigh);
		this.metricsProgram.setIdxFPTot(idxFPTot + this.metricsProgramMainline.getIdxFPTot());
		// Update valori massimi, minimi e totali per le metriche di programma ReHosting
		this.metricsProgram.setIdxReHostingLow(idxReHostingLow);
		this.metricsProgram.setIdxReHostingHigh(idxReHostingHigh);
		this.metricsProgram.setIdxReHostingTot(idxReHostingTot + this.metricsProgramMainline.getIdxReHostingAvg());
		// Update valori massimi, minimi e totali per le metriche di programma MI
		this.metricsProgram.setIdxMILow(idxMILow);
		this.metricsProgram.setIdxMIHigh(idxMIHigh);
		this.metricsProgram.setIdxMITot(idxMITot);
		
	    // Calcolo valori medi a livello di programma (includono quelli della mainline)
		// Il totale di Halstead è la somma dei valori di mainline/section/paragrafo
		if (cntProcedurePerformed > 0) {
			// Adjust McCabe totale
			this.metricsProgram.setIdxMcCabeTot(this.metricsProgram.getIdxMcCabeTot() - cntProcedurePerformed);
			this.metricsProgram.setIdxMcCabeAvg((this.metricsProgram.getIdxMcCabeTot()) / (cntProcedurePerformed + 1));
			this.metricsProgram.setIdxFPAvg((this.metricsProgramMainline.getIdxFPAvg() + idxFPTot) / cntProcedurePerformed);
			this.metricsProgram.setIdxReHostingAvg((this.metricsProgramMainline.getIdxReHostingAvg() + idxReHostingTot) / (cntProcedurePerformed + 1));
			this.metricsProgram.setIdxMIAvg(idxMITot / (cntProcedurePerformed + 1));
		} else {
			this.metricsProgram.setIdxMcCabeHigh(this.metricsProgramMainline.getIdxMcCabeTot());
			this.metricsProgram.setIdxMcCabeLow(this.metricsProgramMainline.getIdxMcCabeTot());
			this.metricsProgram.setIdxMcCabeAvg(this.metricsProgramMainline.getIdxMcCabeTot());
			this.metricsProgram.setIdxFPAvg(this.metricsProgramMainline.getIdxFPAvg());
			this.metricsProgram.setIdxReHostingAvg(this.metricsProgramMainline.getIdxReHostingAvg());
			this.metricsProgram.setIdxMIAvg(this.metricsProgramMainline.getIdxMIAvg());
		}

        // Metriche stimate, si ricalcola per evitare arrotondamenti
		this.metricsProgram.evaluateTimeDevelopment();
		this.metricsProgram.evaluateBackFiredFunctionPoint();

		// Valori totalizzati da mainline/section/paragrafi
		this.metricsProgram.setBackFiredFunctionPoint(backFiredFunctionPointTot);
		this.metricsProgram.setTimeDevelopment(timeDevelopmentTot); 			 
		this.metricsProgram.setHalsteadOperatorsOcc(halsteadOperatorsOccTot);              
		this.metricsProgram.setHalsteadOperandsOcc(halsteadOperandsOccTot);          
		this.metricsProgram.setHalsteadLengthPgm(halsteadLengthPgmTot);          
		this.metricsProgram.setHalsteadVocabularyPgm(halsteadVocabularyPgmTot);                
		this.metricsProgram.setHalsteadVolumePgm(halsteadVolumePgmTot);                 
		this.metricsProgram.setHalsteadDifficultPgm(halsteadDifficultPgmTot);           
		this.metricsProgram.setHalsteadEffortPgm(halsteadEffortPgmTot);                 
		this.metricsProgram.setHalsteadTimeWriting(halsteadTimeWritingTot); 
		this.metricsProgram.setMcCabeArcs(mcCabeArcsTot);
		this.metricsProgram.setMcCabeNodes(mcCabeNodesTot);
		this.metricsProgram.setMcCabeOperatorsOrAnd(mcCabeOperatorsOrAndTot);
		this.metricsProgram.setMcCabeGraphConn(mcCabeGraphConnTot);
		this.metricsProgram.setDynamicInstr(dynamicInstrTot);             	    		 
		this.metricsProgram.setDynamicInstrLight(dynamicInstrLightTot);            	   		 
		this.metricsProgram.evaluateDynamicCodePercent();    
		if (dynamicInstrTot > 0 || dynamicInstrLightTot > 0) {
			this.metricsProgram.setDynamicPgm(1);
		}

	}

	
	/**  
	 * Individuazione violazioni.<br>
     * <p>
     *  
     * Si individuano le violazioni previste e si memorizzano gli estremi su db.
     * L'elaborazione si effettua solo se l'opzione nel pilot di esecuzione è presente.
     * 
     * 
     */
	public void metricsDetectViolation() throws ExceptionAmrita, SQLException {
		
		EntityMetricViolation emv = null;
		EntityMetricValue emva = null;
		ProgramCobolEntry<? extends Instruction> entryProc = null;
		InstructionCobolProcedure instrProc = null;
		InstructionSql instrSql = null;
    	Instruction instrGeneric = null;
		InnerViolationDetecting ivd = null;
        EnumMetricsViolation typeViolation = null;
        Map<String, EnumMetricsViolation> hs_violations = null;			// Key=nome violazione Data=violazione personalizzata (flag attivo etc)
        Map<String, Integer> hs_violationsCount = null;					// Key=nome violazione Data=count violazioni individuate
        Map<String, Integer> hs_remediationCostSum = null;				// Key=nome violazione Data=sum costi remediation in minuti
        Map<String, EnumMetricsSqualeRating> hs_squaleRating = null;
        ArrayList<Integer> al_openFileNumInstr = null;
        ArrayList<String> al_openFile = null;
        ArrayList<String> al_closeFile = null;
        ArrayList<String> al_usedFile = null;
        ArrayList<String> al_fileWork = null;
        ArrayList<Integer> al_sqlNumInstrProc = null;
        ArrayList<Integer> al_sqlNumInstrData = null;
        Set<String> hs_sqlCursorOpen = null;
        Set<String> hs_sqlCursorClose = null;
        Set<String> hs_sqlCursorFetch = null;
        Set<String> hs_copyWithUninitializedCallParm = null;
        String sqlCursor = "";
      	String metricViolationId = "";
        String typeViolationText = null;
        String metricSection = "";
        String mapKey = "";
        String mapOriginViolationInstr = "";
        String mapOriginViolationRow = "";
        String mapOriginViolationRowCopy = "";
        String mapViolationValue = "";
		Integer cnt = null;
		Integer sum = null;
        int cntViolations = 0;
        int totViolations = 0;
 		int i = 0;
        
		
		// Opzione disabilitata
		if (!this.di.optMetricsAll && !this.di.optMetricsSqualeDetectViolation) {
			return;
		}

        // Per cumulare gli aggiornamenti per violazione da aggiornare a fine elaborazione (stessa key)
	    this.map_metricViolation = new HashMap<String, String> ();
	    this.map_metricViolationRow = new HashMap<String, String> ();
	    this.map_metricViolationRowCopy = new HashMap<String, String> ();
	    this.map_metricViolationValue = new HashMap<String, String> ();
		
	    // Per sistema Squale, conteggio violazioni per gravità e somma remediation cost per caratteristica di qualità
	    hs_violations = new HashMap<String, EnumMetricsViolation> ();
	    hs_violationsCount = new HashMap<String, Integer> ();
        hs_remediationCostSum = new  HashMap<String, Integer> ();
        hs_squaleRating = new HashMap<String, EnumMetricsSqualeRating> ();
        metricsDetectViolationsInitialize(hs_violations);
        metricsDetectViolationsSqualeInitialize(hs_violationsCount, hs_remediationCostSum, hs_squaleRating);
        
		ivd = new InnerViolationDetecting();
		al_openFileNumInstr = new ArrayList<Integer> ();
		al_openFile = new ArrayList<String> ();
		al_closeFile = new ArrayList<String> ();
		al_usedFile = new ArrayList<String> ();
		hs_copyWithUninitializedCallParm = new  HashSet<String> ();
		hs_sqlCursorOpen = new  HashSet<String> ();
		hs_sqlCursorClose = new  HashSet<String> ();
		hs_sqlCursorFetch = new  HashSet<String> ();
        al_sqlNumInstrProc = new ArrayList<Integer> ();
        al_sqlNumInstrData = new ArrayList<Integer> ();

		
		////////////////////////////////////////////////////////////
		// (1) Scan sequenziale istruzioni di programma
		////////////////////////////////////////////////////////////
		
		for (i = 0; i < this.programCobol.entriesProcedure().length; i++) {
			
			entryProc =  this.programCobol.entriesProcedure()[i];

			// Scan violazioni rilevate durante l'analisi dell'istruzione
			instrGeneric = entryProc.getInstruction();
    		for (EnumMetricsViolation metricViolation : instrGeneric.getMetricViolations()) {
    			metricViolationId = metricViolation.name() + ":";
          		insUpdateViolationOnMap(metricViolationId, ivd.procInternalName, entryProc);							// Inserimento/update violazione in map
			}
            
     		// Sql statement
     		if (entryProc.getInstruction() instanceof InstructionSql) {
				instrSql = (InstructionSql) entryProc.getInstruction();
				al_sqlNumInstrProc.add(instrSql.getNumInstr());
				// Open cursor
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_OPEN) {
					sqlCursor = instrSql.sqlOpenCursorGetCursorName();
					hs_sqlCursorOpen.add(sqlCursor);
				}
				// Close cursor
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_CLOSE) {
					sqlCursor = instrSql.sqlCloseCursorGetCursorName();
					hs_sqlCursorClose.add(sqlCursor);
				}
				// Fetch cursor
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_FETCH) {
					sqlCursor = instrSql.sqlFetchGetDescriptor().getCursorName();
					hs_sqlCursorFetch.add(sqlCursor);
				}
			}    		
    		
			// Open: intabello nomi files aperti
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_OPEN) {
				al_openFileNumInstr.add(i);
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_fileWork = instrProc.openGetInputFiles();
				al_openFile.addAll(al_fileWork);
				al_fileWork = instrProc.openGetOutputFiles();
				al_openFile.addAll(al_fileWork);
				al_fileWork = instrProc.openGetIOFiles();
				al_openFile.addAll(al_fileWork);
				al_fileWork = instrProc.openGetExtendFiles();
				al_openFile.addAll(al_fileWork);
			}
			
			// Close: intabello nomi files chiusi
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_CLOSE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_fileWork = instrProc.closeGetFiles();
				al_closeFile.addAll(al_fileWork);
			}
			
			// Read: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_READ) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.readGetFileNameInternal());
			}
			
			// Rewrite: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_REWRITE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.rewriteGetFileNameInternal());
			}
			
			// Write: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_WRITE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.writeGetFileNameInternal());
			}
			
			// Delete: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DELETE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.deleteGetFileNameInternal());
			}
			
			// Sort: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SORT) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.sortMergeGetFileNameInternal());
			}
			
			// Merge: intabello nome file 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MERGE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				al_usedFile.add(instrProc.sortMergeGetFileNameInternal());
			}
			
			// Istruzione non in section/paragrafo: reset eventuale procedura interna attiva
			if (!entryProc.isUnderProcInternal() 
			||   entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_END_DECLARATIVES) {
				ivd.procInternalName = "";
				if (entryProc.isMainline()) {
					ivd.procInternalName = this.programCobol.procInternalNameOwner(i);
				}
				ivd.numInstrStart = 0;
				ivd.numInstrEnd = 0;
				ivd.cntViolations = 0;
				ivd.isLoopPerformed = false;
				ivd.isInnerPerform = false;
			}
			
			// LABEL
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
				completeInfoOnProcInternal(ivd, entryProc);							// Se la label è un paragrafo completa informazioni
				detectViolationRelatedToLabel(ivd, entryProc, hs_violations);						  
				// Label di inizio paragrafo NON dentro section
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				if (!ivd.procInternalName.equals("") && ivd.procInternalName.equals(instrProc.labelGetName()) && !ivd.isSection) {
					detectViolationParagraph(ivd, entryProc, hs_violations);
				}
				continue;
			}

			// SECTION
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
				completeInfoOnProcInternal(ivd, entryProc);
				detectViolationSection(ivd, entryProc, hs_violations);   							 
				continue;
			}

			// Fine formale section/paragrafo
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EXIT) {
				ivd.procInternalName = "";
				ivd.numInstrStart = 0;
				ivd.numInstrEnd = 0;
				ivd.cntViolations = 0;
				ivd.isSection = false;
			}
			
			// PERFORM inner
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				// INNER Perform
                if (instrProc.performIsInnerPerform()) {
            		ivd.numInstrStartInnerPerform = instrProc.getNumInstr() + 1;
            		ivd.numInstrEndInnerPerform = entryProc.getNumInstrRelated() - 1;
            		ivd.isInnerPerform = true;
 				} 
  			}

			// END-PERFORM
			if (ivd.isInnerPerform && entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_END_PERFORM && i == ivd.numInstrEndInnerPerform + 1) {
        		ivd.numInstrStartInnerPerform = 0;
        		ivd.numInstrEndInnerPerform = 0;
				ivd.isInnerPerform = false;
			}

			// Violazioni specifiche istruzione dentro paragrafo
			if (!ivd.procInternalName.equals("") && !ivd.isSection) {
				detectViolationInsideParagraph(ivd, entryProc, hs_violations);										 
			}

			// Violazioni specifiche istruzione dentro section
			if (!ivd.procInternalName.equals("") && ivd.isSection) {
				detectViolationInsideSection(ivd, entryProc, hs_violations);   								 
			}

			// Violazioni specifiche istruzione dentro loop di paragrafo/section/inner perform
			if ((!ivd.procInternalName.equals("") && ivd.isLoopPerformed) || ivd.isInnerPerform) {
				detectViolationSpecificOnlyOnLoopProc(ivd, entryProc, hs_violations);												 
 			}
			
			// Violazioni da verificare solo se fuori da loop
			if ((!ivd.procInternalName.equals("") && !ivd.isLoopPerformed) && !ivd.isInnerPerform) {
				detectViolationSpecificOnlyNotOnLoopProc(ivd, entryProc, hs_violations);		
			}

			// Violazioni da verificare sempre (dentro section/paragrafi, in loop o non in loop)
			detectViolationNotSpecificOnLoopProc(ivd, entryProc, hs_copyWithUninitializedCallParm, hs_violations);											 
			 
		}

		// Violazioni relative alle divisioni cobol nel loro complesso
		// Vengono inoltre inserite le violazioni presenti nelle istruzioni e caricate in analisi
		detectViolationGlobalId(hs_violations);															// Identification division		
		detectViolationGlobalEnv(hs_violations);														// Environment division		
		detectViolationGlobalData(hs_copyWithUninitializedCallParm, al_sqlNumInstrData, hs_violations);	// Data division
		detectViolationGlobalProc(al_openFileNumInstr, al_openFile, al_closeFile, al_usedFile, hs_violations); 
		detectViolationGlobalSql(hs_sqlCursorOpen, hs_sqlCursorClose, hs_sqlCursorFetch, al_sqlNumInstrProc, al_sqlNumInstrData, hs_violations); 
	 
		// Violazioni generali, non specifiche di divisione cobol e rilevabili in fondo
		detectViolationGlobalProgram(hs_violations);												// Valide per tutto i programma
 		detectViolationsBadSource(hs_violations);				    								// Violazioni rilevate prima dell'analisi
		detectViolationByUserExit(hs_violations);  													// Violazioni legate a standard esterni validati via user exit
		
		
		
		////////////////////////////////////////////////////////////
		// (2) Inserimento violazioni per update finale su db
		////////////////////////////////////////////////////////////
		
        // Scan map con violazioni cumulate
		for (Entry<String, String> entrySetViolation : this.map_metricViolation.entrySet()) {
			
			mapKey = entrySetViolation.getKey();
			mapOriginViolationInstr = entrySetViolation.getValue();							// Numero istruzione
			mapOriginViolationRow = this.map_metricViolationRow.get(mapKey);				// Numero riga
			mapOriginViolationRowCopy = this.map_metricViolationRowCopy.get(mapKey);		// Numero riga dentro copy
			mapViolationValue = this.map_metricViolationValue.get(mapKey);					// Valore
			
			i = mapKey.indexOf(":");
			typeViolationText = mapKey.substring(0, i);
			typeViolation = EnumMetricsViolation.valueOf(typeViolationText);

			if (typeViolation.getQualityCharacteristic().getRelatedSqaleQualityFactor() == EnumMetricsQualityFactors.TESTABILITY) {
				metricSection = "";
			}
			if (typeViolation.getQualityCharacteristic().getRelatedSqaleQualityFactor() == EnumMetricsQualityFactors.CHANGEABILITY) {
				metricSection = "";
			}
			

			metricSection = "";
			if (mapKey.length() > (i + 1) ) {
				metricSection = mapKey.substring(i + 1);
			}
			
			// Violazione non legata a una section specifica ma a tutto il programma
			if (metricSection.equals("")) {
				metricSection = "*";
			}
			
			// Conteggio generale violazioni   
			cntViolations = 1;
			if (!mapOriginViolationRow.trim().equals("")) {
				String[] ar_violation = mapOriginViolationRow.split(" ");
				cntViolations = ar_violation.length - 1;
			}
			
			// Inserimento violazione in strutture db
			emv = new EntityMetricViolation ();
			emv.setSystem(this.di.systemInput);
			emv.setSubSystem(this.di.subSystemInput);
			emv.setTypeObject(this.programCobol.programType);
			emv.setIdObject(this.programCobol.programName);
			emv.setSection(metricSection);
			emv.setTypeViolation(typeViolation);
			emv.setSeverityViolation(typeViolation.getMetricViolationSeverity());
			emv.setQualityCharacteristic(typeViolation.getQualityCharacteristic());
			emv.setRemediationUnit(typeViolation.getFixUnit());
			emv.setRemediationCost(typeViolation.getRemediationCost());
			emv.setOriginViolation(mapOriginViolationInstr);
			emv.setOriginViolationRows(mapOriginViolationRow);
			emv.setOriginViolationRowsCopy(mapOriginViolationRowCopy);
			emv.setValue(mapViolationValue);
			emv.setCntViolations(cntViolations);
			totViolations += cntViolations;
			this.analyzerDbInfo.addObjMetricViolation(emv);
			
			// Somma violazioni per gravità
			cnt = hs_violationsCount.get(typeViolation.getMetricViolationSeverity().toString());
			cnt += cntViolations;
			hs_violationsCount.put(typeViolation.getMetricViolationSeverity().toString(), cnt);
			
			// Somma remediation cost caratteristica qualità violata in minuti
			sum = hs_remediationCostSum.get(typeViolation.getQualityCharacteristic().getRelatedSqaleQualityFactor().toString());
			sum += typeViolation.getRemediationCostMinutes();
			hs_remediationCostSum.put(typeViolation.getQualityCharacteristic().getRelatedSqaleQualityFactor().toString(), sum);
		}
		
		// Numero totale di violazioni a livello di metriche di programma e di entityMetric programma (già in strutture db)
		this.metricsProgram.setViolations(totViolations);
		this.metricsProgram.evaluateViolationsPercent();
		this.entityMetricProgram.setViolations(totViolations);
		this.entityMetricProgram.setPercViolationsByInstruction(this.metricsProgram.getPercViolationsByInstruction());
		this.entityMetricProgram.setPercViolationsByLogical(this.metricsProgram.getPercViolationsByLogical());
		this.entityMetricProgram.setPercViolationsByPhisical(this.metricsProgram.getPercViolationsByPhisical());
		
		// Sistema qualità Squale, update indici assoluti
		this.metricsProgram.setSqualeSQTI(hs_remediationCostSum.get("TESTABILITY")/480);
		this.metricsProgram.setSqualeSQRI(hs_remediationCostSum.get("RELIABILITY")/480);
		this.metricsProgram.setSqualeSQCI(hs_remediationCostSum.get("CHANGEABILITY")/480);
		this.metricsProgram.setSqualeSQEI(hs_remediationCostSum.get("EFFICIENCY")/480);
		this.metricsProgram.setSqualeSQSI(hs_remediationCostSum.get("SECURITY")/480);
		this.metricsProgram.setSqualeSQMI(hs_remediationCostSum.get("MAINTENABILITY")/480);
		this.metricsProgram.setSqualeSQPI(hs_remediationCostSum.get("PORTABILITY")/480);

		// Sistema qualità Squale, update numero violazioni per categoria gravità
		this.metricsProgram.setSqualeViolationsBlocker(hs_violationsCount.get("E_BLOCKING"));
		this.metricsProgram.setSqualeViolationsCritical(hs_violationsCount.get("D_CRITICAL"));
		this.metricsProgram.setSqualeViolationsMajor(hs_violationsCount.get("C_MAJOR"));
		this.metricsProgram.setSqualeViolationsMinor(hs_violationsCount.get("B_MINOR"));
		this.metricsProgram.setSqualeViolationsInfo(hs_violationsCount.get("A_INFO"));

		// Sistema qualità Squale, calcolo tutti gli indici
		this.metricsProgram.evaluateSqualeQualityAbsoluteIndex();
		this.metricsProgram.evaluateSqualeQualityConsolidateIndex();
		this.metricsProgram.evaluateSqualeRatingIndex(hs_squaleRating);
		this.metricsProgram.evaluateSqualeRuleComplianceIndex();
		this.metricsProgram.evaluateSqualeDensityQualityIndex();
		
		// Sistema qualità Squale, valorizzo l'entity metrics
		this.metricsProgram.dbPopulateMetricSquale(this.entityMetricProgram);
		
	}
    
	/* -----------------------------------------
	 * Inizializza le map per gestione Squale 
	 * -----------------------------------------
	 * 
	 * Per oggni entry di EnumEnumMetricsViolationSeverity
	 *   si inserisce un entry in hs_violationsCount, Key=Name Data=Integer(0)
	 * Per oggni entry di EnumMetricsQualityCharacteristics
	 *   si inserisce un entry in hs_remediationCostSum, Key=Name Data=Integer(0)
	 */
    private void metricsDetectViolationsSqualeInitialize(Map<String, Integer> hs_violationsCount, Map<String, Integer> hs_remediationCostSum, Map<String, EnumMetricsSqualeRating> hs_squaleRating) {

    	// Livelli di severità
    	for (EnumMetricsViolationSeverity enumViolationSeverity  : EnumMetricsViolationSeverity.values()) {
    		hs_violationsCount.put(enumViolationSeverity.toString(), new Integer(0));
    	}
		
    	// Caratteristiche di qualità
    	for (EnumMetricsQualityCharacteristics enumQualityCharacteristics  : EnumMetricsQualityCharacteristics.values()) {
    		if (!enumQualityCharacteristics.isSqaleQualityFactor()) {continue;}
    		hs_remediationCostSum.put(enumQualityCharacteristics.toString(), new Integer(0));
    	}
    	
    	// Squale rating
    	for (EnumMetricsSqualeRating enumSqualeRating  : EnumMetricsSqualeRating.values()) {
    		hs_squaleRating.put(enumSqualeRating.toString(), enumSqualeRating);
    	}
	}

    /* --------------------------------------------------
     * Inizializza la map con le violazioni personalizzte
     * --------------------------------------------------
     * 
     * Carica la map con gli elementi dell'enumerazione EnumMetricsViolation
     * Ogni elemento contiene i valori di default, come abilitazione, caratteristica, gravità etc.
     * Legge da tabella METx i valori personalizzati delle singole violazioni
     * Aggiorna i valori del corrispondente elemento nella map
     * 
     */
	@SuppressWarnings("unused")
	private void metricsDetectViolationsInitialize(Map<String, EnumMetricsViolation> hs_violations) throws ExceptionAmrita, SQLException {
		
		EnumMetricsViolation violationToUpdate = null;
		EntityMetricScenario entityMetricScenario = null;
		List<EntityMetricScenario> ar_objEntityMetricScenario = null;
		String idViolation = "";
		int numViolation = 0;
		
		// Violazioni di default in map
    	for (EnumMetricsViolation enumMetricsViolation  : EnumMetricsViolation.values()) {
    		hs_violations.put(enumMetricsViolation.toString(), enumMetricsViolation);
    	}
		
    	// Non è previsto nessun scenario di personalizzazione
        if (!this.di.optMetricsViolationsScenario) {
			return;
		}
        

		// Lettura scenario personalizzazioni violazioni
   	    entityMetricScenario = new EntityMetricScenario();	
      	String whereCondition = "";
      
     	// Composizione Where  
       	whereCondition =   " idScenario = '" + this.di.curMetricsViolationsScenario + "'";
       	
       	Connection conn = DataBaseConnections.getConnection();
       	IDAOMetricScenario eoDAO = (DAOImplMetricScenario) AmritaStartup.sqlFactory.getDAOMetricScenario(conn, false,false, ucfg);
       	ar_objEntityMetricScenario = eoDAO.findAllWhere(whereCondition, "");    	
      	 
     	// Scan violazioni personalizzate in scenario
     	for (int i = 0; i < ar_objEntityMetricScenario.size(); i++) {
     		
     		entityMetricScenario = (EntityMetricScenario) ar_objEntityMetricScenario.get(i);
     		
     		// Recupero enumerazione da personalizzare
     		idViolation = entityMetricScenario.getTypeViolation().toString();
     		numViolation = entityMetricScenario.getTypeViolation().ordinal();
     		violationToUpdate = hs_violations.get(idViolation);
     		
     		// Update valori enumerazione violazione
       		violationToUpdate.setRuleEnabled(entityMetricScenario.getViolationEnabled());
       		violationToUpdate.setQualityCharacteristic(entityMetricScenario.getQualityCharacteristic());
      		violationToUpdate.setMetricViolationSeverity(entityMetricScenario.getSeverityViolation());
    		violationToUpdate.setRemediationCost(entityMetricScenario.getRemediationCost());
    		violationToUpdate.setFixUnit(entityMetricScenario.getRemediationUnit());
    		// Update soglie solo se >= 0
    		if (entityMetricScenario.getThresholdLow() >= 0) {
    			violationToUpdate.getThreshold().setThresholdLow(entityMetricScenario.getThresholdLow());
			}
    		if (entityMetricScenario.getThresholdHigh() >= 0) {
          		violationToUpdate.getThreshold().setThresholdHigh(entityMetricScenario.getThresholdHigh());
    		}
       	 }

	}



	/* ----------------------------------------------------------
     * Recupero informazioni su procedura interna di appartenenza
     * ----------------------------------------------------------
     * 
     * Il metodo viene richiamato a fronte di section o label (paragrafo)
     * Si tratta numero di istruzione di fine section/paragrafo.
     * Si individua se la section o il paragrafo sono sotto loop
     *   verificando tutte le perform esplicite, se richiamate con Varying Until,
     *   e tutte le perform a section/paragrafi chiamanti, a qualsiasi livello
     */
	private void completeInfoOnProcInternal(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc) {
		
		InstructionCobolProcedure instrProc = null;
       	String labelName = "";
 		
		instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
		
		// Section
		if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
			ivd.procInternalName = instrProc.sectionGetName();
			ivd.isSection = true;
			ivd.isLoopPerformed = this.programCobol.isProcInternalLoopPerformed(instrProc.sectionGetName());
			ivd.numInstrStart = instrProc.getNumInstr() + 1;
			ivd.numInstrEnd = instrProc.sectionGetLastNumInstr();
			return;
		}
		
		// Non è una label
		if (instrProc.getTypeInstr() != EnumCobolReservedWords.PROC_LABEL) {
			return;
		}
		
		// Non è un paragrafo
		if (!instrProc.labelIsParagraph()) {
			return;
		}
		
		// E un paragrafo performato, dichiarato in DECLARATIVES o dead code
		
		labelName = instrProc.labelGetName();
		ivd.procInternalName = labelName;
		ivd.isSection = false;
		ivd.isLoopPerformed = this.programCobol.isProcInternalLoopPerformed(labelName);
		
		// Se paragrafo vuoto restituisce la label di inizio paragrafo e imposta quela di fine allo stesso numero di istruzione
		ivd.numInstrEnd = instrProc.labelGetLastNumInstrParagraph();
		if (ivd.numInstrEnd == instrProc.getNumInstr()) {
			ivd.numInstrStart = ivd.numInstrEnd;
			return;
		}
		ivd.numInstrStart = instrProc.getNumInstr() + 1;
    	return;
	}


	
	/*
	 * -------------------------------------------------------
	 * Violazioni associate a una section e al suo contenuto
	 * -------------------------------------------------------
	 * 
     * Individuazione violazione R0001_AVOID_GOTO_OUTSIDE_SECTION
     * Individuazione violazione R0002_AVOID_GOTO_BACK_SAME_SECTION
     * Individuazione violazione R0005_AVOID_GOTO_FWD_TO_END
     * Individuazione violazione R0006_AVOID_GOTO_FWD_NOT_TO_END
     * Individuazione violazione R0094_AVOID_GOBACK_NOT_IN_MAINLINE
     * Individuazione violazione R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE
     */
	private void detectViolationInsideSection(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Map<String, EnumMetricsViolation> hs_violations) {
		
		InstructionCobolProcedure instProc = null;
		String sectionName = "";
		String[] ar_labelGoTo = null;
		int numInstrLabel = 0;
		
		sectionName = ivd.procInternalName;
			
		// GoTO
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
			instProc = (InstructionCobolProcedure) entryProc.getInstruction();
			ar_labelGoTo = instProc.goToGetLabels();
			
			// Scan label
			for (String labelGoTo : ar_labelGoTo) {
				numInstrLabel = this.programCobol.labelPointer(labelGoTo);
				
				// Violazione goTo back
				if (hs_violations.get("R0002_AVOID_GOTO_BACK_SAME_SECTION").isRuleEnabled()) {
					if (numInstrLabel < instProc.getNumInstr()
					&&  numInstrLabel >= ivd.numInstrStart) {
						insUpdateViolationOnMap("R0002_AVOID_GOTO_BACK_SAME_SECTION:", sectionName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0002_AVOID_GOTO_BACK_SAME_SECTION);
					    continue;
					}
				}
				
				// Violazione goTo outside
				if (hs_violations.get("R0001_AVOID_GOTO_OUTSIDE_SECTION").isRuleEnabled()) {
					if (numInstrLabel < ivd.numInstrStart 
					||  numInstrLabel > ivd.numInstrEnd) {
						insUpdateViolationOnMap("R0001_AVOID_GOTO_OUTSIDE_SECTION:", sectionName, entryProc);			// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0001_AVOID_GOTO_OUTSIDE_SECTION);
					    continue;
					}
				}
				
				// Violazione goTo End
				if (hs_violations.get("R0005_AVOID_GOTO_FWD_TO_END").isRuleEnabled()) {
					if (numInstrLabel > instProc.getNumInstr() 
					&&  numInstrLabel == ivd.numInstrEnd) {
						insUpdateViolationOnMap("R0005_AVOID_GOTO_FWD_TO_END:", sectionName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0005_AVOID_GOTO_FWD_TO_END);
					    continue;
					}
				}
				
				// Violazione goTo Fwd (solo se NON depending ON)
				if (hs_violations.get("R0006_AVOID_GOTO_FWD_NOT_TO_END").isRuleEnabled()) {
					if (numInstrLabel > instProc.getNumInstr() && !instProc.goToIsDependingOn()) {
						insUpdateViolationOnMap("R0006_AVOID_GOTO_FWD_NOT_TO_END:", sectionName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0006_AVOID_GOTO_FWD_NOT_TO_END);
					    continue;
					}
				}
			}  
            return;
		} 
		
		
	    // STOP RUN  
		if (hs_violations.get("R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE").isRuleEnabled()) {
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_STOP) {
				instProc = (InstructionCobolProcedure) entryProc.getInstruction();
				insUpdateViolationOnMap("R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE:", sectionName, entryProc);				// Inserimento/update violazione in map
				instProc.getMetricViolations().add(EnumMetricsViolation.R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE);
				return;
			}
		}
			
	    // GOBACK
		if (hs_violations.get("R0094_AVOID_GOBACK_NOT_IN_MAINLINE").isRuleEnabled()) {
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_GOBACK) {
				instProc = (InstructionCobolProcedure) entryProc.getInstruction();
				insUpdateViolationOnMap("R0094_AVOID_GOBACK_NOT_IN_MAINLINE:", sectionName, entryProc);				// Inserimento/update violazione in map
				instProc.getMetricViolations().add(EnumMetricsViolation.R0094_AVOID_GOBACK_NOT_IN_MAINLINE);
				return;
			}
		}
	}

	
	/*
	 * -------------------------------------------------------
	 * Violazioni associate a una section nel suo insieme
	 * -------------------------------------------------------
	 * 
	 * Si utilizzano anche le misure di metriche già calcolate.
	 * 
 	 * Individuazione violazione R0007_AVOID_RECURSIVE_PERFORM
	 * Individuazione violazione R0015_AVOID_SECTION_UNREFERENCED
     * Individuazione violazione RC016_AVOID_EMPTY_SECTION
     * Individuazione violazione R0017_AVOID_SECTION_WITH_NO_PARAGRAPH
     * Individuazione violazione R0022_AVOID_HIGH_SECTION_INSTR_SIZE
     * Individuazione violazione R0018_AVOID_UNDOCUMENTED_SECTION
     * Individuazione violazione R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW
     * Individuazione violazione R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR
 	 * Individuazione violazione R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY
 	 * Individuazione violazione R0082_AVOID_DEAD_SECTION
 	 * Individuazione violazione R0097_AVOID_SECTION_NOT_ENDED_BY_EXIT
 	 * Individuazione violazione R0123_AVOID_SECTION_IN_PROCEDURE
    */
	private void detectViolationSection(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProcSection, Map<String, EnumMetricsViolation> hs_violations) {
		
		ProgramCobolEntry<? extends Instruction> ar_entryProc[] = null;
		InstructionCobolProcedure instProcSection = null;
		Metrics metricsSection = null;
		ArrayList<String> al_deadCodeSection = null;
		String sectionName = "";
		int numInstrSectionEnd = 0;
		int cntInstrNoLabel = 0;
		int cntInstrLabel = 0;
		@SuppressWarnings("unused")
		long sizeSourceSection = 0;
		@SuppressWarnings("unused")
		long sizeCommSection = 0;
		long sizeInstrSection = 0;
	   	double percCommByInstr = 0;
    	double percCommByRow = 0;
    	int sizeInstr = 0;
		boolean isSectionUnReferenced = false;
		
		instProcSection = (InstructionCobolProcedure) entryProcSection.getInstruction();
		sectionName = instProcSection.sectionGetName();
		ar_entryProc = this.programCobol.entriesProcedure();

		// Section presente in procedure division
		if (hs_violations.get("R0123_AVOID_SECTION_IN_PROCEDURE").isRuleEnabled()) {
			insUpdateViolationOnMap("R0123_AVOID_SECTION_IN_PROCEDURE:", sectionName, entryProcSection);   		// Inserimento/update violazione in map
			instProcSection.getMetricViolations().add(EnumMetricsViolation.R0123_AVOID_SECTION_IN_PROCEDURE);
		}
		
		// Section non terminata da EXIT
		if (hs_violations.get("R0097_AVOID_SECTION_NOT_ENDED_BY_EXIT").isRuleEnabled()) {
			numInstrSectionEnd = instProcSection.sectionGetLastNumInstr();
			if ((numInstrSectionEnd + 1 <= ar_entryProc.length - 1 
			&&  ar_entryProc[numInstrSectionEnd + 1].getTypeInstr() != EnumCobolReservedWords.PROC_EXIT)
			|| numInstrSectionEnd + 2 >= ar_entryProc.length) {
				insUpdateViolationOnMap("R0097_AVOID_SECTION_NOT_ENDED_BY_EXIT:", sectionName, entryProcSection);   										// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0097_AVOID_SECTION_NOT_ENDED_BY_EXIT);
			}				
		}

		// Section non referenziata 
		if (hs_violations.get("R0015_AVOID_SECTION_UNREFERENCED").isRuleEnabled()) {
			if (!this.programCobol.isSectionReferenced(instProcSection.sectionGetName())) {
				insUpdateViolationOnMap("R0015_AVOID_SECTION_UNREFERENCED:", sectionName, entryProcSection);   		// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0015_AVOID_SECTION_UNREFERENCED);
				isSectionUnReferenced = true;		
			}
		}

		// Section dead code (anche se referenziata e richiamata, ma da section a loro volta dead code)
		if (hs_violations.get("R0082_AVOID_DEAD_SECTION").isRuleEnabled()) {
			al_deadCodeSection = this.programCobol.deadCodeSections();
			if (al_deadCodeSection.contains(sectionName)) {
				insUpdateViolationOnMap("R0082_AVOID_DEAD_SECTION:", sectionName, entryProcSection);   		// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0082_AVOID_DEAD_SECTION);
			}
		}
		
		// Section richiamata ricorsivamente
		if (hs_violations.get("R0007_AVOID_RECURSIVE_PERFORM").isRuleEnabled()) {
			if (!isSectionUnReferenced && this.programCobol.isProcInternalNameRecursiveCalled(sectionName)) {
				insUpdateViolationOnMap("R0007_AVOID_RECURSIVE_PERFORM:", sectionName, entryProcSection);   			// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0007_AVOID_RECURSIVE_PERFORM);
			}
		}

		// Conteggio label e itruzioni NON label (la label di chiusura NON viene considerata)
		cntInstrLabel = this.programCobol.sectionLabels(sectionName).size();
		cntInstrNoLabel = this.programCobol.sectionCountNoLabelInstr(sectionName);

		// Section vuota, senza istruzioni e con eventuali label (empty)
		if (hs_violations.get("R0016_AVOID_EMPTY_SECTION").isRuleEnabled()) {
			if (cntInstrNoLabel == 0) {
				insUpdateViolationOnMap("R0016_AVOID_EMPTY_SECTION:", sectionName, entryProcSection);   				// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0016_AVOID_EMPTY_SECTION);
			}
		}
	
		// Section senza paragrafi
		if (hs_violations.get("R0017_AVOID_SECTION_WITH_NO_PARAGRAPH").isRuleEnabled()) {
			if (cntInstrNoLabel > 0 && cntInstrLabel == 0) {
				insUpdateViolationOnMap("R0017_AVOID_SECTION_WITH_NO_PARAGRAPH:", sectionName, entryProcSection);   	// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0017_AVOID_SECTION_WITH_NO_PARAGRAPH);
			}
		}
		
		// Section non documentata
		if (hs_violations.get("R0018_AVOID_UNDOCUMENTED_SECTION").isRuleEnabled()) {
			if (instProcSection.getCommentsBeforeNotEmpty().length == 0) {
				insUpdateViolationOnMap("R0018_AVOID_UNDOCUMENTED_SECTION:", sectionName, entryProcSection);   	// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0018_AVOID_UNDOCUMENTED_SECTION);
			}
		}

		// Section poco documentata
		if (hs_violations.get("R0019_AVOID_LOW_DOCUMENTED_SECTION").isRuleEnabled()) {
			if (instProcSection.getCommentsBeforeNotEmpty().length > 0 
			&&  instProcSection.getCommentsBeforeNotEmpty().length <  hs_violations.get("R0019_AVOID_LOW_DOCUMENTED_SECTION").getThreshold().getThresholdLow()) {
				insUpdateViolationOnMap("R0019_AVOID_LOW_DOCUMENTED_SECTION:", sectionName, entryProcSection);   				// Inserimento/update violazione in map
				insUpdateViolationValueOnMap("R0019_AVOID_LOW_DOCUMENTED_SECTION:", sectionName, instProcSection.getCommentsBeforeNotEmpty().length+"");   				// Inserimento/update violazione in map
				instProcSection.getMetricViolations().add(EnumMetricsViolation.R0019_AVOID_LOW_DOCUMENTED_SECTION);
			}
		}

		
		// Valori dimensionali.
		
		// Le misure sono già state calcolate per le metriche e disponibili
		metricsSection = this.programCobol.getMetricsProgramSectionParagraph(sectionName);
     	sizeSourceSection = metricsSection.getSizeLinesCodePhisical();
     	sizeCommSection = metricsSection.getSizeLinesCommentProc();
     	sizeInstrSection = metricsSection.getSizeInstr();
     	percCommByInstr = metricsSection.getPercComByInstruction();
     	percCommByRow = metricsSection.getPercComByPhisical();
		
     	
     	// % commenti per istruzione 
     	if (hs_violations.get("R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR").isRuleEnabled()) {
         	if (percCommByInstr < hs_violations.get("R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR").getThreshold().getThresholdLow()) {
          		insUpdateViolationOnMap("R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR:", sectionName, entryProcSection);							// Inserimento/update violazione in map
    			insUpdateViolationValueOnMap("R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR:", sectionName, percCommByInstr+"");   				// Inserimento/update violazione in map
         		instProcSection.getMetricViolations().add(EnumMetricsViolation.R0020_AVOID_LOW_SECTION_PERC_COMM_BY_INSTR);
    		}
     	}
     	
     	// % commenti per riga 
    	if (hs_violations.get("R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW").isRuleEnabled()) {
         	if (percCommByRow < hs_violations.get("R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW").getThreshold().getThresholdLow()) {
          		insUpdateViolationOnMap("R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW:", sectionName, entryProcSection);		// Inserimento/update violazione in map
    			insUpdateViolationValueOnMap("R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW:", sectionName, percCommByRow+"");   				// Inserimento/update violazione in map
         		instProcSection.getMetricViolations().add(EnumMetricsViolation.R0021_AVOID_LOW_SECTION_PERC_COMM_BY_ROW);
    		}
    	}
     	
		// Dimensioni in istruzioni
       	if (hs_violations.get("R0022_AVOID_HIGH_SECTION_INSTR_SIZE").isRuleEnabled()) {
    		if (sizeInstrSection > hs_violations.get("R0022_AVOID_HIGH_SECTION_INSTR_SIZE").getThreshold().getThresholdLow()) {
    			insUpdateViolationOnMap("R0022_AVOID_HIGH_SECTION_INSTR_SIZE:", sectionName, entryProcSection);					// Inserimento/update violazione in map
    			insUpdateViolationValueOnMap("R0022_AVOID_HIGH_SECTION_INSTR_SIZE:", sectionName, sizeInstr+"");   				// Inserimento/update violazione in map
    			instProcSection.getMetricViolations().add(EnumMetricsViolation.R0022_AVOID_HIGH_SECTION_INSTR_SIZE);
    		}
       	}
		
     	// Indice di McCabe section
      	if (hs_violations.get("R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY").isRuleEnabled()) {
            if (metricsSection.getIdxMcCabeHigh() > hs_violations.get("R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY").getThreshold().getThresholdHigh()) {
             	insUpdateViolationOnMap("R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY:", sectionName, entryProcSection);											// Inserimento/update violazione in map
    			insUpdateViolationValueOnMap("R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY:", sectionName, metricsSection.getIdxMcCabeHigh()+"");   				// Inserimento/update violazione in map
           	    instProcSection.getMetricViolations().add(EnumMetricsViolation.R0023_AVOID_HIGH_MCBE_SECTION_COMPLEXITY);
    		}
      	}
	}




	/*
	 * ----------------------------------------------------------------
	 * Violazioni specifiche associate a istruzioni dentro un paragrafo
	 * ----------------------------------------------------------------
	 * 
	 * Individuazione violazione R0003_AVOID_GOTO_OUTSIDE_PARAGRAPH
	 * Individuazione violazione R0004_AVOID_GOTO_BACK_SAME_PARAGRAPH
	 * Individuazione violazione R0005_AVOID_GOTO_FWD_TO_END
	 * Individuazione violazione R0006_AVOID_GOTO_FWD_NOT_TO_END
 	 * Individuazione violazione R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE
 	 * Individuazione violazione R0094_AVOID_GOBACK_NOT_IN_MAINLINE
      */
	private void detectViolationInsideParagraph(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Map<String, EnumMetricsViolation> hs_violations) {
		
		InstructionCobolProcedure instProc = null;
		String paragraphName = "";
		String[] ar_labelGoTo = null;
		int numInstrLabel = 0;
		
		paragraphName = ivd.procInternalName;
		
		// GoTO
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
			instProc = (InstructionCobolProcedure) entryProc.getInstruction();
			ar_labelGoTo = instProc.goToGetLabels();
			// Scan label
			for (String labelGoTo : ar_labelGoTo) {
				numInstrLabel = this.programCobol.labelPointer(labelGoTo);
				
				// Violazione goTo outside (l'istruzione di inizio/fine non include la label di inizio/thru)
				if (hs_violations.get("R0003_AVOID_GOTO_OUTSIDE_PARAGRAPH").isRuleEnabled()) {
					if (numInstrLabel < ivd.numInstrStart - 1 
					||  numInstrLabel > ivd.numInstrEnd + 1) {
						insUpdateViolationOnMap("R0003_AVOID_GOTO_OUTSIDE_PARAGRAPH:", paragraphName, entryProc);	// Inserimento/update violazione in map
				   		instProc.getMetricViolations().add(EnumMetricsViolation.R0003_AVOID_GOTO_OUTSIDE_PARAGRAPH);
					    continue;
					}
				}
				
				// Violazione goTo back (anche alla stessa label di paragrafo)
				if (hs_violations.get("R0004_AVOID_GOTO_BACK_SAME_PARAGRAPH").isRuleEnabled()) {
					if (numInstrLabel < instProc.getNumInstr()
					&&  numInstrLabel >= ivd.numInstrStart - 1) {
						insUpdateViolationOnMap("R0004_AVOID_GOTO_BACK_SAME_PARAGRAPH:", paragraphName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0004_AVOID_GOTO_BACK_SAME_PARAGRAPH);
					    continue;
					}
				}
				
				// Violazione goTo End
				if (hs_violations.get("R0005_AVOID_GOTO_FWD_TO_END").isRuleEnabled()) {
					if (numInstrLabel > instProc.getNumInstr() 
					&&  numInstrLabel == ivd.numInstrEnd) {
						insUpdateViolationOnMap("R0005_AVOID_GOTO_FWD_TO_END:", paragraphName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0005_AVOID_GOTO_FWD_TO_END);
					    continue;
					}
				}
				
				// Violazione goTo Fwd
				if (hs_violations.get("R0006_AVOID_GOTO_FWD_NOT_TO_END").isRuleEnabled()) {
					if (numInstrLabel > instProc.getNumInstr()) {
						insUpdateViolationOnMap("R0006_AVOID_GOTO_FWD_NOT_TO_END:", paragraphName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0006_AVOID_GOTO_FWD_NOT_TO_END);
					    continue;
					}
				}

				
			} // end-for labels GoTo
			return;
		} // end-if goTo
		
	    // STOP RUN 
		if (hs_violations.get("R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE").isRuleEnabled()) {
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_STOP) {
				instProc = (InstructionCobolProcedure) entryProc.getInstruction();
				insUpdateViolationOnMap("R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE:", paragraphName, entryProc);		// Inserimento/update violazione in map
				instProc.getMetricViolations().add(EnumMetricsViolation.R0117_AVOID_STOP_RUN_NOT_IN_MAINLINE);
				return;
			}		
		}

	    // GOBACK
		if (hs_violations.get("R0094_AVOID_GOBACK_NOT_IN_MAINLINE").isRuleEnabled()) {
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_GOBACK) {
				instProc = (InstructionCobolProcedure) entryProc.getInstruction();
				insUpdateViolationOnMap("R0094_AVOID_GOBACK_NOT_IN_MAINLINE:", paragraphName, entryProc);		// Inserimento/update violazione in map
				instProc.getMetricViolations().add(EnumMetricsViolation.R0094_AVOID_GOBACK_NOT_IN_MAINLINE);
				return;
			}		
		}
}

	
	/*
	 * -------------------------------------------------------
	 * Violazioni associate a un paragrafo nel suo insieme
	 * -------------------------------------------------------
	 * 
	 * Si utilizzano anche le misure di metriche già calcolate.
	 * 
	 * Individuazione violazione R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE 
	 * Individuazione violazione R0008_AVOID_EMPTY_PARAGRAPH
	 * Individuazione violazione R0009_AVOID_UNDOCUMENTED_PARAGRAPH
	 * Individuazione violazione R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH
 	 * Individuazione violazione R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW
     * Individuazione violazione R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR
     * Individuazione violazione R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY
     * Individuazione violazione R0007_AVOID_RECURSIVE_PERFORM
     * Individuazione violazione R0096_AVOID_PARAGRAPH_NOT_ENDED_BY_EXIT
     * Individuazione violazione R0124_AVOID_PARAGRAPH_IN_PROCEDURE
     * 
     */
	private void detectViolationParagraph(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProcParagraph, Map<String, EnumMetricsViolation> hs_violations) {
		
		Metrics metricsParagraph = null;
		InstructionCobolProcedure instProcParagraph = null;
		ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
		String paragraphName = "";
		int numInstrParagraphStart = 0;
		int numInstrParagraphEnd = 0;
		@SuppressWarnings("unused")
		long sizeSourceParagraph = 0;
		@SuppressWarnings("unused")
		long sizeCommParagraph = 0;
		long sizeInstrParagraph = 0;
	   	double percCommByInstr = 0;
    	double percCommByRow = 0;
 		Double IdxMcCabeHigh = null;
		
		paragraphName = ivd.procInternalName;
		numInstrParagraphStart = ivd.numInstrStart;						// Prima  istruzione corpo paragrafo
		numInstrParagraphEnd = ivd.numInstrEnd;							// Ultima istruzione corpo paragrafo
		instProcParagraph = (InstructionCobolProcedure) entryProcParagraph.getInstruction();
		ar_entryProc = this.programCobol.entriesProcedure();
		
		// Paragrafo presente in procedure division
		if (hs_violations.get("R0124_AVOID_PARAGRAPH_IN_PROCEDURE").isRuleEnabled()) {
			insUpdateViolationOnMap("R0124_AVOID_PARAGRAPH_IN_PROCEDURE:", paragraphName, entryProcParagraph);   		// Inserimento/update violazione in map
			instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0124_AVOID_PARAGRAPH_IN_PROCEDURE);		
		}

		// Paragrafo non terminato da EXIT
		if (hs_violations.get("R0096_AVOID_PARAGRAPH_NOT_ENDED_BY_EXIT").isRuleEnabled()) {
			if ((numInstrParagraphEnd + 1 < ar_entryProc.length &&
				     this.programCobol.entryProcedure(numInstrParagraphEnd).getTypeInstr() == EnumCobolReservedWords.PROC_LABEL &&
				     this.programCobol.entryProcedure(numInstrParagraphEnd + 1).getTypeInstr() != EnumCobolReservedWords.PROC_EXIT
				    )
				||  (this.programCobol.entryProcedure(numInstrParagraphEnd).getTypeInstr() != EnumCobolReservedWords.PROC_LABEL)) {
					insUpdateViolationOnMap("R0096_AVOID_PARAGRAPH_NOT_ENDED_BY_EXIT:", paragraphName, entryProcParagraph);   										// Inserimento/update violazione in map
					instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0096_AVOID_PARAGRAPH_NOT_ENDED_BY_EXIT);
				}
		}
		
		// Paragrafo richiamato ricorsivamente
		if (hs_violations.get("R0007_AVOID_RECURSIVE_PERFORM").isRuleEnabled()) {
			if (this.programCobol.isProcInternalNameRecursiveCalled(paragraphName)) {
				insUpdateViolationOnMap("R0007_AVOID_RECURSIVE_PERFORM:", paragraphName, entryProcParagraph);   										// Inserimento/update violazione in map
				instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0007_AVOID_RECURSIVE_PERFORM);
			}
		}
				
		// Empty Paragraph
		if (hs_violations.get("R0008_AVOID_EMPTY_PARAGRAPH").isRuleEnabled()) {
			if (numInstrParagraphEnd - numInstrParagraphStart == 0) {
				insUpdateViolationOnMap("R0008_AVOID_EMPTY_PARAGRAPH:", paragraphName, entryProcParagraph);								// Inserimento/update violazione in map
				instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0008_AVOID_EMPTY_PARAGRAPH);
			}
		}
		
		// Paragrafo non documentato
		if (hs_violations.get("R0009_AVOID_UNDOCUMENTED_PARAGRAPH").isRuleEnabled()) {
			if (instProcParagraph.getCommentsBeforeNotEmpty().length == 0) {
				insUpdateViolationOnMap("R0009_AVOID_UNDOCUMENTED_PARAGRAPH:", paragraphName, entryProcParagraph);	// Inserimento/update violazione in map
				instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0009_AVOID_UNDOCUMENTED_PARAGRAPH);
			}
		}

		// Paragrafo poco documentato
		if (hs_violations.get("R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH").isRuleEnabled()) {
			if (instProcParagraph.getCommentsBeforeNotEmpty().length > 0 
			&& instProcParagraph.getCommentsBeforeNotEmpty().length < hs_violations.get("R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH").getThreshold().getThresholdLow()) {
				insUpdateViolationOnMap("R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH:", paragraphName, entryProcParagraph);									// Inserimento/update violazione in map
				insUpdateViolationValueOnMap("R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH:", paragraphName, instProcParagraph.getCommentsBeforeNotEmpty().length+"");	// Inserimento/update violazione in map
				instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0010_AVOID_LOW_DOCUMENTED_PARAGRAPH);
			}
		}
		
		// Valori dimensionali.
		
		// Le misure sono già state calcolate per le metriche e disponibili
		try {
			metricsParagraph = this.programCobol.getMetricsProgramSectionParagraph(ivd.procInternalName);
			sizeSourceParagraph = metricsParagraph.getSizeLinesCodePhisical();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return;
		}
     	sizeCommParagraph = metricsParagraph.getSizeLinesCommentProc();
     	sizeInstrParagraph = metricsParagraph.getSizeInstr();
     	percCommByInstr = metricsParagraph.getPercComByInstruction();
     	percCommByRow = metricsParagraph.getPercComByPhisical();
     	
 
     	// % commenti per istruzione 
		if (hs_violations.get("R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR").isRuleEnabled()) {
		   	if (percCommByInstr < hs_violations.get("R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR").getThreshold().getThresholdLow()) {
	      		insUpdateViolationOnMap("R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR:", paragraphName, entryProcParagraph);					// Inserimento/update violazione in map
	      		insUpdateViolationValueOnMap("R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR:", paragraphName, percCommByInstr+"");				// Inserimento/update violazione in map
	      		instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0011_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_INSTR);
	     	}
		}
      	 
     	// % commenti per riga 
		if (hs_violations.get("R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW").isRuleEnabled()) {
		   	if (percCommByRow < hs_violations.get("R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW").getThreshold().getThresholdLow()) {
	      		insUpdateViolationOnMap("R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW:", paragraphName, entryProcParagraph);						// Inserimento/update violazione in map
	     		insUpdateViolationValueOnMap("R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW:", paragraphName, percCommByRow+"");					// Inserimento/update violazione in map
	     		instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0012_AVOID_LOW_PARAGRAPH_PERC_COMM_BY_ROW);
			}
		}
      	
		// Dimensioni in istruzioni del paragrafo
		if (hs_violations.get("R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE").isRuleEnabled()) {
			if (sizeInstrParagraph > hs_violations.get("R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE").getThreshold().getThresholdHigh()) {
				insUpdateViolationOnMap("R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE:", paragraphName, entryProcParagraph);							// Inserimento/update violazione in map
	    		insUpdateViolationValueOnMap("R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE:", paragraphName, sizeInstrParagraph+"");					// Inserimento/update violazione in map
	   			instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0013_AVOID_HIGH_PARAGRAPH_INSTR_SIZE);
			}
		}
		
     	// Indice di McCabe section/paragrafo
		if (hs_violations.get("R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY").isRuleEnabled()) {
	       if (metricsParagraph.getIdxMcCabeHigh() > hs_violations.get("R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY").getThreshold().getThresholdHigh()) {
	        	IdxMcCabeHigh = new Double(metricsParagraph.getIdxMcCabeHigh());
	          	insUpdateViolationOnMap("R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY:", paragraphName, entryProcParagraph);							// Inserimento/update violazione in map
	          	insUpdateViolationValueOnMap("R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY:", paragraphName, IdxMcCabeHigh.toString());				// Inserimento/update violazione in map
	       		instProcParagraph.getMetricViolations().add(EnumMetricsViolation.R0014_AVOID_HIGH_MCBE_PARAGRAPH_COMPLEXITY);
			}
		}
 		
	}


	
	/* ----------------------------------------------
	 * Individuazione violazioni legate alle label.
	 * ----------------------------------------------
	 * 
	 * Il metodo viene richiamato su una label.
	 * 
	 * Individuazione violazione R0026_AVOID_LABEL_UNREFERENCED
	 * Individuazione violazione R0027_AVOID_LABEL_REFERENCED_DUPLICATED
	 * Individuazione violazione R0028_AVOID_LABEL_UNREFERENCED_DUPLICATED
	 * Individuazione violazione R0108_AVOID_NOT_STD_SIZE_LABEL
	 */
	private void detectViolationRelatedToLabel(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Map<String, EnumMetricsViolation> hs_violations) {
		
		InstructionCobolProcedure instProc = null;
		ArrayList<Integer> al_numInstr = null;
		String labelName = "";
		String sectionParagraphName = "";
		int labelSize = 0;
		
		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
		sectionParagraphName = ivd.procInternalName;
		labelSize = instProc.labelGetName().length();
		
		// Label troppo corta o troppo lunga
		if (hs_violations.get("R0108_AVOID_NOT_STD_SIZE_LABEL").isRuleEnabled()) {
			if (labelSize < EnumMetricsViolation.R0108_AVOID_NOT_STD_SIZE_LABEL.getThreshold().getThresholdLow() 
			    ||  labelSize > EnumMetricsViolation.R0108_AVOID_NOT_STD_SIZE_LABEL.getThreshold().getThresholdHigh() ) {
					insUpdateViolationOnMap("R0108_AVOID_NOT_STD_SIZE_LABEL:", sectionParagraphName, entryProc);  						// Inserimento/update violazione in map
					instProc.getMetricViolations().add(EnumMetricsViolation.R0108_AVOID_NOT_STD_SIZE_LABEL);
			}
		}
		
		// Label NON referenziata
		if (hs_violations.get("R0026_AVOID_LABEL_UNREFERENCED").isRuleEnabled()) {
			if (!this.programCobol.isLabelReferenced(instProc.labelGetName())) {
				insUpdateViolationOnMap("R0026_AVOID_LABEL_UNREFERENCED:", sectionParagraphName, entryProc);  						// Inserimento/update violazione in map
				instProc.getMetricViolations().add(EnumMetricsViolation.R0026_AVOID_LABEL_UNREFERENCED);
			}
		}
		
		// Label duplicated referenced
		if (hs_violations.get("R0027_AVOID_LABEL_REFERENCED_DUPLICATED").isRuleEnabled()) {
			if (this.programCobol.isLabelReferenced(instProc.labelGetName())) {
				labelName = instProc.labelGetName();
				al_numInstr = this.programCobol.labelPointers(labelName);
				
				 // Label definita più volte nel programma	
				if (al_numInstr.size() > 1) {
					insUpdateViolationOnMap("R0027_AVOID_LABEL_REFERENCED_DUPLICATED:", sectionParagraphName, entryProc);  			// Inserimento/update violazione in map
					instProc.getMetricViolations().add(EnumMetricsViolation.R0027_AVOID_LABEL_REFERENCED_DUPLICATED);
				}
			}
		}

		// Label duplicated unreferenced
		if (hs_violations.get("R0028_AVOID_LABEL_UNREFERENCED_DUPLICATED").isRuleEnabled()) {
			if (!this.programCobol.isLabelReferenced(instProc.labelGetName())) {
				labelName = instProc.labelGetName();
				al_numInstr = this.programCobol.labelPointers(labelName);
				
				// Label definita più volte nel programma	
				if (al_numInstr.size() > 1) {
					insUpdateViolationOnMap("R0028_AVOID_LABEL_UNREFERENCED_DUPLICATED:", sectionParagraphName, entryProc); 			// Inserimento/update violazione in map
					instProc.getMetricViolations().add(EnumMetricsViolation.R0028_AVOID_LABEL_UNREFERENCED_DUPLICATED);			
				}
			}
		}
	}

	/* -------------------------------------------------------------
     * Violazioni di performance associate a istruzioni sotto loop
     * ------------------------------------------------------------- 
     * 
     * Individuazione violazione R0030_AVOID_FILE_OPEN_CLOSE_INSIDE_LOOP
     * Individuazione violazione R0031_AVOID_INDEXING_NO_USAGE_INDEX_INSIDE_LOOP
     * Individuazione violazione R0032_AVOID_ARITHMETIC_OPERAND_ZONED_INSIDE_LOOP
     * Individuazione violazione R0029_AVOID_COMMIT_INSIDE_LOOP
     * Individuazione violazione R0142_AVOID_SQL_OPEN_CURSOR_INSIDE_LOOP
     * 	
     */
	private void detectViolationSpecificOnlyOnLoopProc(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Map<String, EnumMetricsViolation> hs_violations) {
		
		InstructionCobol instrProc = null;
		InstructionCics instrCics = null;
		InstructionSql instrSql = null;
		String sectionParagraphName = "";

		sectionParagraphName = ivd.procInternalName;
		
		// Istruzione Cics
		if (hs_violations.get("R0029_AVOID_COMMIT_INSIDE_LOOP").isRuleEnabled()) {
			if (entryProc.getInstruction() instanceof InstructionCics) {
				instrCics = (InstructionCics) entryProc.getInstruction();
				if (instrCics.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.CICS_INSTR_SYNCPOINT) {
					insUpdateViolationOnMap("R0029_AVOID_COMMIT_INSIDE_LOOP:", sectionParagraphName, entryProc);   		// Inserimento/update violazione in map
					instrCics.getMetricViolations().add(EnumMetricsViolation.R0029_AVOID_COMMIT_INSIDE_LOOP);			
				}
				return;
			}
		}
		
		// Istruzione Sql
		if (entryProc.getInstruction() instanceof InstructionSql) {
			instrSql = (InstructionSql) entryProc.getInstruction();
			
			// Commit
			if (hs_violations.get("R0029_AVOID_COMMIT_INSIDE_LOOP").isRuleEnabled()) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_COMMIT) {
					insUpdateViolationOnMap("R0029_AVOID_COMMIT_INSIDE_LOOP:", sectionParagraphName, entryProc);   // Inserimento/update violazione in map
					instrSql.getMetricViolations().add(EnumMetricsViolation.R0029_AVOID_COMMIT_INSIDE_LOOP);		
				}
			}
			
			// Open cursor
			if (hs_violations.get("R0142_AVOID_SQL_OPEN_CURSOR_INSIDE_LOOP").isRuleEnabled()) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_OPEN) {
					insUpdateViolationOnMap("R0142_AVOID_SQL_OPEN_CURSOR_INSIDE_LOOP:", sectionParagraphName, entryProc);   // Inserimento/update violazione in map
					instrSql.getMetricViolations().add(EnumMetricsViolation.R0142_AVOID_SQL_OPEN_CURSOR_INSIDE_LOOP);		
				}
			}
			return;
		}
		
		
		// Sicuramente istruzione Cobol
		instrProc = (InstructionCobol) entryProc.getInstruction();
        
		// Commit 
		if (hs_violations.get("R0029_AVOID_COMMIT_INSIDE_LOOP").isRuleEnabled()) {
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_COMMIT) {
				insUpdateViolationOnMap("R0029_AVOID_COMMIT_INSIDE_LOOP:", sectionParagraphName, entryProc);   			// Inserimento/update violazione in map
				instrProc.getMetricViolations().add(EnumMetricsViolation.R0029_AVOID_COMMIT_INSIDE_LOOP);		
				return;
			}
		}
		
		// Open/close Statement
		if (hs_violations.get("R0030_AVOID_FILE_OPEN_CLOSE_INSIDE_LOOP").isRuleEnabled()) {
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_OPEN
			||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_CLOSE) {
				insUpdateViolationOnMap("R0030_AVOID_FILE_OPEN_CLOSE_INSIDE_LOOP:", sectionParagraphName, entryProc);   			// Inserimento/update violazione in map
				instrProc.getMetricViolations().add(EnumMetricsViolation.R0030_AVOID_FILE_OPEN_CLOSE_INSIDE_LOOP);		
				return;
			}
		}
				
		// Move (indexis no index)
		if (hs_violations.get("R0031_AVOID_INDEXING_NO_USAGE_INDEX_INSIDE_LOOP").isRuleEnabled()) {
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_MOVE) {
				detectViolationCobolIndexingNoIndex(ivd, entryProc, sectionParagraphName, "R0031_AVOID_INDEXING_NO_USAGE_INDEX_INSIDE_LOOP:", EnumMetricsViolation.R0031_AVOID_INDEXING_NO_USAGE_INDEX_INSIDE_LOOP);
				return;
			} 		
		}
		
		// Compute, Add, Sub, Mult, Div (campi zoned)
		if (hs_violations.get("R0032_AVOID_ARITHMETIC_OPERAND_ZONED_INSIDE_LOOP").isRuleEnabled()) {
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_COMPUTE
		    ||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_ADD	
		    ||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_SUBTRACT	
		    ||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_MULTIPLY
		    ||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_DIVIDE) {
				detectViolationComputationNotNumeric(ivd, entryProc, sectionParagraphName, "R0032_AVOID_ARITHMETIC_OPERAND_ZONED_INSIDE_LOOP:", EnumMetricsViolation.R0032_AVOID_ARITHMETIC_OPERAND_ZONED_INSIDE_LOOP);
			}
		}

	}

	/* -------------------------------------------
	 * Individuazioni violazioni di indexing
	 * -------------------------------------------
	 * 
     * Individuazione violazione R0031_AVOID_INDEXING_NO_USAGE_INDEX_INSIDE_LOOP
     * Individuazione violazione PE002_COBOL_INDEXING_NO_INDEX_NO_LOOP
     * 
     */
	private void detectViolationCobolIndexingNoIndex(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName, String violation, EnumMetricsViolation violationCode) {
		
		InstructionCobolProcedure instrProc = null;
		DataItemCobolIdentifier moveFrom = null;
		ExpressionCobol[] ar_moveFromIndex = null;
		DataItemCobolIdentifier exprIdentifier = null;

		instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
		moveFrom = instrProc.moveGetIdentifierFrom();
		if (moveFrom.getQualifier().isOccursed()) {
			ar_moveFromIndex = moveFrom.getQualifier().getIndexes();
			// Scan singole espressioni indice
			for (ExpressionCobol exprIndex : ar_moveFromIndex) {
				// Scan singoli elementi espressione indice
				for (ExpressionCobolElement exprElement : exprIndex.getElements()) {							
					if (exprElement.getSymbolType() != EnumSymbolType.COBOL_SYMBOL_DATA_ITEM) {continue;} 		// Interessano solo i data item
					exprIdentifier = exprElement.getDataItemIdentifier();
			        // Campo senza usage o con usage diversa da index
					if (!exprIdentifier.getDataItem().isUsageClause()
					||   exprIdentifier.getDataItem().getUsage() != EnumCobolUsage.USAGE_INDEX) {
						insUpdateViolationOnMap(violation, sectionParagraphName, entryProc);   					// Inserimento/update violazione in map
						instrProc.getMetricViolations().add(violationCode);		
						return;
					}
				} // end-for expression element
			} // end-for expression index
		} // end-if  
	}

	/* -------------------------------------------
	 * Individuazioni troncamento in Move
	 * -------------------------------------------
	 * 
     * Individuazione violazione R0063_AVOID_MOVE_TRUNCATED
      * 
     */
	private void detectViolationCobolMoveTruncated(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName, String violation, EnumMetricsViolation violationCode) {
		
		InstructionCobolProcedure instrProc = null;
		DataItemCobolIdentifier moveFrom = null;
		ArrayList<DataItemCobolIdentifier> ar_moveTo = null;
		int lngBytesFrom = 0;
		int lngBytesTo = 0;
		
		instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
		moveFrom = instrProc.moveGetIdentifierFrom();
		ar_moveTo = instrProc.moveGetIdentifiersTo();
		
		// Il campo From deve essere un data item (no literal, no ..)
		if (moveFrom.getIdentifierType() != EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {
			return;
		}
		
		// Il campo From NON deve essere con reference modification
		if (moveFrom.getQualifier().isThereRefModification()) {
			return;
		}
		
		// Il campo From deve essere alfanumerico (Usage display)
		if (moveFrom.getDataItem().getUsage() != EnumCobolUsage.NOT_ASSIGNED
		&&  moveFrom.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY		
		&&  moveFrom.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY_1) {
			return;
		}
		
		lngBytesFrom = moveFrom.getDataItem().getSizeBytes();
		
		
		// Scan campi riceventi
		for (DataItemCobolIdentifier moveTo : ar_moveTo) {

			// Il campo To deve essere un data item (no literal, no ..)
			if (moveTo.getIdentifierType() != EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {
				continue;
			}
			
			// Il campo To NON deve essere con reference modification
			if (moveTo.getQualifier().isThereRefModification()) {
				return;
			}
			
			// Il campo To deve essere alfanumerico (Usage display)
			if (moveTo.getDataItem().getUsage() != EnumCobolUsage.NOT_ASSIGNED
			&&  moveTo.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY		
			&&  moveTo.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY_1) {
				continue;
			}
			
			lngBytesTo = moveTo.getDataItem().getSizeBytes();

            // Lunghezza campo ricevente = : no operation
			if (lngBytesFrom == lngBytesTo) {
				continue;
			}
			
            // Lunghezza campo ricevente < : troncamento
			if (lngBytesFrom > lngBytesTo) {
				insUpdateViolationOnMap(violation, sectionParagraphName, entryProc);   					// Inserimento/update violazione in map
				instrProc.getMetricViolations().add(violationCode);		
				continue;
			}
		}
	}

	/* ------------------------------------------------
	 * Verifica check campo alfanumerico prima di Move
	 * ------------------------------------------------
	 * 
     * Individuazione violazione R0092_AVOID_UNCHECKED_ALPHA_TO_NUM_MOVE
     * 
     */
	private void detectViolationCobolMoveUncheckedAlphanumeric(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName, String violation, EnumMetricsViolation violationCode) {
		
		InstructionCobolProcedure instrProc = null;
		DataItemCobolIdentifier moveFrom = null;
		ArrayList<DataItemCobolIdentifier> ar_moveTo = null;
		ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
		ProgramCobolEntry<? extends Instruction> entryProcWork  = null;
		InstructionCobolProcedure instrIf = null;
		ExpressionCobol expr = null;
		ExpressionCobolElement[] ar_exprElement = null;
		ExpressionCobolElement exprElement = null;
		String moveFromFieldName = "";
		boolean isMoveFieldToCheck = false;
		boolean isMoveFieldUnchecked = false;
		int i = 0;
		int j = 0;
		int k = 0;
		
		instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
		moveFrom = instrProc.moveGetIdentifierFrom();
		moveFromFieldName = moveFrom.getNameIdentifier();
		ar_moveTo = instrProc.moveGetIdentifiersTo();
		
		
		// Non è gestita l'opzione corresponding
		if (instrProc.moveIsCorr()) {
			return;
		}
		
		// Il campo From deve essere un data item (no literal, no ..)
		if (moveFrom.getIdentifierType() != EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {
			return;
		}
		
		// Il campo From deve essere alfanumerico (Usage display)
		if (moveFrom.getDataItem().getUsage() != EnumCobolUsage.NOT_ASSIGNED
		&&  moveFrom.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY		
		&&  moveFrom.getDataItem().getUsage() != EnumCobolUsage.USAGE_DISPLAY_1) {
			return;
		}
		
		// Scan campi riceventi
		for (DataItemCobolIdentifier moveTo : ar_moveTo) {

			// Il campo To deve essere numerico o zoned
			if (moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMPUTATIONAL_3
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMP_3	
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_PACKED_DECIMAL
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMPUTATIONAL_4
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMP_4
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMPUTATIONAL_5
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMP_5
			||  moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_COMP_X
			|| (moveTo.getDataItem().getUsage() == EnumCobolUsage.USAGE_DISPLAY && moveTo.getDataItem().getGenericType() == EnumDataItemGeneric.DATA_ITEM_NUMERIC)) {
				isMoveFieldToCheck = true;
				break;
			}
			
 		}
		
		// Il campo From NON deve essere verificato NUMERIC prima della Move
		if (!isMoveFieldToCheck) {
			return;
		}
		
		isMoveFieldUnchecked = true;
		
		// Ricerca prima If precedente alla Move
		ar_entryProc = this.programCobol.entriesProcedure();
		for (i = instrProc.getNumInstr() - 1; i > 0; i--) {
			
			entryProcWork = ar_entryProc[i];
			
			// Sicuramente If precedente non trovata
			if (entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
			||  entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION
			||  entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_END_IF
			||  entryProcWork.getInstruction().isTerminatedWithPoint()) {
				break;
			}
			
			// Interessano solo le if
			if (entryProcWork.getTypeInstr() != EnumCobolReservedWords.PROC_IF) {continue;}
			
			// Verifica se If ... campoMoveFrom Is Numeric ...
			instrIf = (InstructionCobolProcedure) entryProcWork.getInstruction();
			expr = instrIf.ifGetCondition();
			
			// Scan elementi espressione
			ar_exprElement =  expr.getElements();
			for (j = 0; j < ar_exprElement.length; j++) {
				exprElement = ar_exprElement[j];
				
				// Operando = al nome del campo da verificare
				if (exprElement.isOperand() 
				&&  exprElement.getSymbolType() == EnumSymbolType.COBOL_SYMBOL_DATA_ITEM
				&&  exprElement.getDataItemIdentifier().getNameIdentifier().equals(moveFromFieldName)) {
					k = j + 1;
					if (k >= ar_exprElement.length) {break;}
					exprElement = ar_exprElement[k];
					// Checked
					if (exprElement.getSymbolType() == EnumSymbolType.COBOL_SYMBOL_FIGURATIVE
					&&  exprElement.getFigurativeType() == EnumCobolFigurativeConstants.NUMERIC) {
						isMoveFieldUnchecked = false;
						break;
					}
				}
			}
			break;
		}
		
		// Inserimento violazione
		if (isMoveFieldUnchecked) {
			insUpdateViolationOnMap(violation, sectionParagraphName, entryProc);   				// Inserimento/update violazione in map
			instrProc.getMetricViolations().add(violationCode);	
		}
	}

	
	/*
	 * ---------------------------------------------------
	 * Individuazioni violazioni numeriche su compute
	 * ---------------------------------------------------
	 * 
     * Individuazione violazione R0034_AVOID_ARITHMETIC_OPERAND_ZONED_NO_LOOP
     * Individuazione violazione R0032_AVOID_ARITHMETIC_OPERAND_ZONED_INSIDE_LOOP
     * 
     */
    private void detectViolationComputationNotNumeric(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName, String violation, EnumMetricsViolation violationCode) {
		
    	DataItemCobolIdentifier computeResult = null;
		ExpressionCobol computeExprAssigned = null;
		DataItemCobolIdentifier exprIdentifier = null;
        InstructionCobolProcedure instrProc = null;
		
        instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
        
		// Violazioni aritmetiche su Compute
		if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_COMPUTE) {
			computeResult = instrProc.computeGetResultIdentifier();
			if (computeResult.getDataItem().getUsage() == EnumCobolUsage.NOT_ASSIGNED
			||  computeResult.getDataItem().getUsage() == EnumCobolUsage.USAGE_DISPLAY
			||  computeResult.getDataItem().getUsage() == EnumCobolUsage.USAGE_DISPLAY_1) {
				insUpdateViolationOnMap(violation, sectionParagraphName, entryProc);   					// Inserimento/update violazione in map
				instrProc.getMetricViolations().add(violationCode);			
				return;
			}
			
			computeExprAssigned = instrProc.computeGetExpressionAssigned();
			
			// Scan singoli elementi espressione assegnata
			for (ExpressionCobolElement exprElement : computeExprAssigned.getElements()) {							
				if (exprElement.getSymbolType() != EnumSymbolType.COBOL_SYMBOL_DATA_ITEM) {continue;} 	// Interessano solo i data item
				exprIdentifier = exprElement.getDataItemIdentifier();
				if (exprIdentifier.getDataItem().getUsage() == EnumCobolUsage.NOT_ASSIGNED
				||  exprIdentifier.getDataItem().getUsage() == EnumCobolUsage.USAGE_DISPLAY
				||  exprIdentifier.getDataItem().getUsage() == EnumCobolUsage.USAGE_DISPLAY_1) {
					insUpdateViolationOnMap(violation, sectionParagraphName, entryProc);   				// Inserimento/update violazione in map
					instrProc.getMetricViolations().add(violationCode);	
					return;
				}
			} // end-for expression element
		}
		
		return;
    }

	/*
	 * ---------------------------------------------------
	 * Individuazioni violazioni numeriche su compute
	 * ---------------------------------------------------
	 * 
     * Individuazione violazione R0135_AVOID_COMPUTE_FOR_SIMPLE_OPERATIONS
     * 
     */
    private void detectViolationComputeUseForSimpleOperation(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName) {
		
		ExpressionCobol computeExprAssigned = null;
        InstructionCobolProcedure instrProc = null;
		int cntOperators = 0;
        
        instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
		computeExprAssigned = instrProc.computeGetExpressionAssigned();
		
		// Scan singoli elementi espressione assegnata
		for (ExpressionCobolElement exprElement : computeExprAssigned.getElements()) {							
			if (exprElement.getSymbolType() == EnumSymbolType.COBOL_SYMBOL_OPERATOR) {
				cntOperators++;
			} 	 
		} // end-for expression element
       
		// Violazioni aritmetiche su Compute
		if (cntOperators <= 1) {
			insUpdateViolationOnMap("R0135_AVOID_COMPUTE_FOR_SIMPLE_OPERATIONS:", sectionParagraphName, entryProc);   					// Inserimento/update violazione in map
			instrProc.getMetricViolations().add(EnumMetricsViolation.R0135_AVOID_COMPUTE_FOR_SIMPLE_OPERATIONS);			
		}
			
		return;
    }

	
   /*
	* ---------------------------------------------------
	* Individuazioni violazioni su When di evaluate
	* ---------------------------------------------------
	* 
	* Individuazione violazione R0129_AVOID_EVALUATE_WHEN_WITH_LOGIC_CONDITIONAL
	* 
    */
   private void detectViolationWhenWithLogicConditional(ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName) {
       
	   ProgramCobolEntry<? extends Instruction> entryProcEvaluate = null;
	   ProgramCobolEntry<? extends Instruction> entryProcWork = null;
	   InstructionCobolProcedure instrProcWhen = null;
	   boolean isThereLogicConditional = false;
       int numInstrEvaluateStart = 0;
       int numInstrEvaluateEnd = 0;
       int i = 0;
       
       // Individuazione inizio/fine evaluate contenente la when
       instrProcWhen = (InstructionCobolProcedure) entryProc.getInstruction();
       numInstrEvaluateStart = entryProc.getNumInstrRelated();
       entryProcEvaluate = this.programCobol.entryProcedure(numInstrEvaluateStart);
       numInstrEvaluateEnd = entryProcEvaluate.getNumInstrRelated();
       
       // Scan istruzioni sotto where
       for (i = instrProcWhen.getNumInstr() + 1; i < numInstrEvaluateEnd; i++) {
    	  entryProcWork = this.programCobol.entryProcedure(i);
    	  
    	  // When successiva: fine controllo
    	  if (entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH
    	  &&  entryProcWork.getNumInstrRelated() == numInstrEvaluateStart) {
			 break;
    	  }
    	  
    	  // Istruzione condizionale o evaluate annidata
    	  if (entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_IF
    	  ||  entryProcWork.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE) {
    		  isThereLogicConditional = true;
  		  }
    	  
 		}    	  
	   
       // When con logica condizionale o altra struttura evaluate
	   if (isThereLogicConditional) {
			insUpdateViolationOnMap("R0129_AVOID_EVALUATE_WHEN_WITH_LOGIC_CONDITIONAL:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
			instrProcWhen.getMetricViolations().add(EnumMetricsViolation.R0129_AVOID_EVALUATE_WHEN_WITH_LOGIC_CONDITIONAL);
	   }
	}

   /*
	* ---------------------------------------------------------------------------
	* Individuazione violazioni su parametri statement call
	* ---------------------------------------------------------------------------
	* 
    * Individiazione violazione R0132_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_COPY
	* Individiazione violazione R0133_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_PGM
    *
    */
	private void detectViolationUninitializedCallParameters(ProgramCobolEntry<? extends Instruction> entryProc, String sectionParagraphName, Set<String> hs_copyWithUninitializedCallParm) {
    	
		ProgramCobolEntry<? extends Instruction> entryData = null;
		ArrayList<DataItemCobolIdentifier> al_identifierParm = null;
		ArrayList<InstructionCobolDataItem> al_dataItemElementaryParm = null;
		ArrayList<InstructionCobolDataItem> al_dataItemElementaryParmNoValueInCopy = null;
		ArrayList<InstructionCobolDataItem> al_dataItemElementaryParmNoValueNotInCopy = null;
        InstructionCobolProcedure instrProcCall = null;
		int numeDefDataItem = 0;
        
		instrProcCall = (InstructionCobolProcedure) entryProc.getInstruction();
         
        // Nessun parametro
        if (!instrProcCall.callIsUsingParms()) {
			return;
		}
        
        // Identificatori completi parametri
        al_identifierParm = instrProcCall.callGetUsingParms();
        al_dataItemElementaryParmNoValueInCopy = new ArrayList<InstructionCobolDataItem> ();
        al_dataItemElementaryParmNoValueNotInCopy = new ArrayList<InstructionCobolDataItem> ();

        // Scan parametri 
        for (DataItemCobolIdentifier identifierParm : al_identifierParm) {
        	
        	// Interessano solo i parametri data item, non costanti, di working, senza value ed elementari
        	if (identifierParm.getIdentifierType() != EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {continue;}
        	entryData = this.programCobol.entryDataDivision(identifierParm.getDataItem().getNumInstr());
        	if (entryData.getProgramSection() != EnumCobolReservedWords.DATA_DIV_WS_SECTION ) {continue;}
           	if (identifierParm.getDataItem().isGroupField() || identifierParm.getDataItem().isValueClause()) {continue;}
           	
           	// Campo elementare senza value
          	if (!identifierParm.getDataItem().isGroupField()) {
          		if (entryData.isUnderCopy()) {
          			al_dataItemElementaryParmNoValueInCopy.add(identifierParm.getDataItem());
				} else {
	         		al_dataItemElementaryParmNoValueNotInCopy.add(identifierParm.getDataItem());
				}
           		continue;
          	}
            
          	// Campo di gruppo
        	    
           	// Estrazione e accodamento campi elementari a qualsiasi livello
           	numeDefDataItem = identifierParm.getDataItem().getNumInstr();
           	al_dataItemElementaryParm = this.programCobol.dataItemsUnderGroup(numeDefDataItem, DATA_ITEMS_ELEMENTARY_FIELDS);
            
           	// Scan data item elementari estratti (alcuni potrebbero essere sotto copy e altri no
           	for (InstructionCobolDataItem dataItemElementaryParm : al_dataItemElementaryParm) {
           		entryData = this.programCobol.entryDataDivision(dataItemElementaryParm.getNumInstr());
          		if (entryData.isUnderCopy()) {
          			hs_copyWithUninitializedCallParm.add(entryData.getUnderCopyName());
          			al_dataItemElementaryParmNoValueInCopy.add(identifierParm.getDataItem());
				} else {
	         		al_dataItemElementaryParmNoValueNotInCopy.add(identifierParm.getDataItem());
				}
			}
 		}
 
        // Inserimento violazioni campi parametri in working non inizializzati non in copy
        for (InstructionCobolDataItem dataItemElementaryParmNoValueNotInCopy : al_dataItemElementaryParmNoValueNotInCopy) {
			insUpdateViolationOnMap("R0133_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_PGM:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
			instrProcCall.getMetricViolations().add(EnumMetricsViolation.R0133_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_PGM);
			insUpdateViolationValueOnMap("R0133_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_PGM:", sectionParagraphName, dataItemElementaryParmNoValueNotInCopy.getDataName());   	// Inserimento/update violazione in map
		}
        
        // Inserimento violazioni campi parametri in working non inizializzati in copy
        for (InstructionCobolDataItem dataItemElementaryParmNoValueInCopy : al_dataItemElementaryParmNoValueInCopy) {
        	entryData = this.programCobol.entryDataDivision(dataItemElementaryParmNoValueInCopy.getNumInstr());
        	hs_copyWithUninitializedCallParm.add(entryData.getUnderCopyName());
			insUpdateViolationOnMap("R0132_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_COPY:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
			instrProcCall.getMetricViolations().add(EnumMetricsViolation.R0132_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_COPY);
			insUpdateViolationValueOnMap("R0132_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_COPY:", sectionParagraphName, dataItemElementaryParmNoValueInCopy.getDataName());   	// Inserimento/update violazione in map
        }


 	}

	
	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni singole di procedure valide solo NON in loop
	 * ---------------------------------------------------------------------------
	 * 
	 * Si tratta di violazioni che possono essere prodotte anche in loop e che 
	 * pertanto devono essere prodotte una sola volta.
	 * 
	 * Individiazione violazione R0033_AVOID_INDEXING_NO_USAGE_INDEX_NO_LOOP
 	 * Individiazione violazione R0034_AVOID_ARITHMETIC_OPERAND_ZONED_NO_LOOP
 	 * 
  	 */
   private void detectViolationSpecificOnlyNotOnLoopProc(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Map<String, EnumMetricsViolation> hs_violations) {
	   	
	    String sectionParagraphName = "";
	   	sectionParagraphName = ivd.procInternalName;

     	// Move
	   	if (hs_violations.get("R0033_AVOID_INDEXING_NO_USAGE_INDEX_NO_LOOP").isRuleEnabled()) {
	   		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MOVE) {
		   		// Move a(i) i not Usage Index
				detectViolationCobolIndexingNoIndex(ivd, entryProc, sectionParagraphName, "R0033_AVOID_INDEXING_NO_USAGE_INDEX_NO_LOOP:", EnumMetricsViolation.R0033_AVOID_INDEXING_NO_USAGE_INDEX_NO_LOOP);
				return;
			}
		}
   		
		// Compute, Add, Sub, Mult, Div (campi zoned)
	   	if (hs_violations.get("R0034_AVOID_ARITHMETIC_OPERAND_ZONED_NO_LOOP").isRuleEnabled()) {
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_COMPUTE
		    ||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_ADD	
		    ||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SUBTRACT	
		    ||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MULTIPLY
		    ||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DIVIDE) {
				detectViolationComputationNotNumeric(ivd, entryProc, sectionParagraphName, "R0034_AVOID_ARITHMETIC_OPERAND_ZONED_NO_LOOP:", EnumMetricsViolation.R0034_AVOID_ARITHMETIC_OPERAND_ZONED_NO_LOOP);
			    return;
			}
	   	}
 
   }


	
	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni singole di procedure valide sia in loop che non
	 * ---------------------------------------------------------------------------
	 * 
	 * Individiazione violazione R0024_AVOID_HIGH_PERFORM_INNER_INSTR_SIZE 
	 * Individiazione violazione R0025_AVOID_HIGH_LEVEL_NESTING_IF
 	 * Individiazione violazione R0035_AVOID_PERFORM_VARYING_K_ZONED
	 * Individiazione violazione R0037_AVOID_CALL_STATIC
	 * Individiazione violazione R0040_AVOID_INSTR_FORBIDDEN_FOR_CICS
	 * Individiazione violazione R0044_AVOID_MERGE_STATEMENT
	 * Individiazione violazione R0045_AVOID_ALTER_STATEMENT
	 * Individiazione violazione R0046_AVOID_GOTO_PARAGRAPH
	 * Individiazione violazione R0047_AVOID_GOTO_FROM_OUTSIDE_TO_LABEL_INSIDE_SECTION
	 * Individiazione violazione R0048_AVOID_CICS_HANDLE_ABEND 
	 * Individiazione violazione R0049_AVOID_CICS_HANDLE_CONDITION 
 	 * Individiazione violazione R0050_AVOID_CICS_HANDLE_AID
	 * Individiazione violazione R0051_AVOID_CICS_IGNORE_CONDITION 
	 * Individiazione violazione R0055_AVOID_DISPLAY_UPON_CONSOLE
	 * Individiazione violazione R0057_AVOID_READ_WITHOUT_AT_END
 	 * Individiazione violazione R0059_AVOID_EVALUATE_WITHOUT_WHEN_OTHER   
	 * Individiazione violazione R0061_AVOID_MOVE_REFERENCE_MODIFICATION  
	 * Individiazione violazione R0062_AVOID_CORRESPONDING_OPTION   				 
     * Individiazione violazione R0063_AVOID_MOVE_TRUNCATED			 
	 * Individiazione violazione R0064_AVOID_PERFORM_THRU       			 
	 * Individiazione violazione R0066_AVOID_EVALUATE_CLOSED_BY_DOT 
	 * Individiazione violazione R0067_AVOID_IF_CLOSED_BY_DOT       		 
	 * Individuazione violazione R0077_AVOID_UNCHECKED_FILE_STATUS
	 * Individiazione violazione R0070_AVOID_NEXT_SENTENCE   
	 * Individiazione violazione R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE
	 * Individiazione violazione R0092_AVOID_UNCHECKED_ALPHA_TO_NUM_MOVE  	
	 * Individiazione violazione R0093_AVOID_CICS_COMMAREA_AND_LENGTH_MISSING	
	 * Individiazione violazione R0119_AVOID_HIGH_CONDITIONS_NUMBER	 
	 * Individiazione violazione R0120_AVOID_COPY_INSIDE_PROCEDURE_DIVISION
	 * Individiazione violazione R0121_AVOID_INITIALIZE_STATEMENT
	 * Individiazione violazione R0129_AVOID_EVALUATE_WHEN_WITH_LOGIC_CONDITIONAL
	 * Individiazione violazione R0130_AVOID_MAGIC_LITERAL_ALPHANUMERIC
	 * Individiazione violazione R0131_AVOID_MAGIC_LITERAL_NUMERIC
	 * Individiazione violazione R0132_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_COPY
	 * Individiazione violazione R0133_AVOID_UNINITIALIZED_CALL_PARAMETER_DEFINED_INSIDE_PGM
	 * Individiazione violazione R0136_AVOID_IF_TRUE_EMPTY
	 * Individiazione violazione R0137_AVOID_IF_ELSE_EMPTY
	 * 
  	 */
    private void detectViolationNotSpecificOnLoopProc(InnerViolationDetecting ivd, ProgramCobolEntry<? extends Instruction> entryProc, Set<String> hs_copyWithUninitializedCallParm, Map<String, EnumMetricsViolation> hs_violations) {
    	
       	ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
       	ProgramCobolEntry<? extends Instruction> entryProcWork = null;
    	InstructionCobolDataItem varyingDataItem = null;
      	InstructionCobol instrCopy = null;
      	InstructionCobolProcedure instProc = null;
       	InstructionCobolProcedure instProcEvaluate = null;
       	InstructionCobolProcedure instProcIf = null;
      	InstructionCobolProcedure instProcRead = null;
      	InstructionCobolEnvironment instrProcSelect = null;
      	InstructionCics instCics = null;
    	DataItemCobolIdentifier varyingIdentifier = null;
      	ExpressionCobol expr = null;
       	EnumCobolReservedWords typeInstrNext = null;
       	ArrayList<String> ar_fileNameOpenInput = null;
        String copyName = "";
      	String[] ar_labelGoTo = null;
 	    String sectionParagraphName = "";
 	    String sectionParagraphNameGoTo = "";
    	String fileName = "";
    	String fileStatusName = "";
    	String fieldEibresp = "";
        boolean isThereWhenOther = false; 
        int numInstr = 0;
        int numInstrStart = 0;
        int numInstrEnd = 0;
        int numInstrNext = 0;
        int cntInstrInnerPerform = 0;
        int lvlNesting = 0;
    	int i = 0;
    	
    	sectionParagraphName = ivd.procInternalName;
    	
    	// Istruzioni vietate sotto Cics
    	if (hs_violations.get("R0040_AVOID_INSTR_FORBIDDEN_FOR_CICS").isRuleEnabled()) {
    	   	if (this.programCobol.isCicsProgram()) {
            	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DISPLAY
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_ACCEPT		
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_ENTRY	
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_OPEN		
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_CLOSE	
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_READ		
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_WRITE		
            	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_REWRITE	
               	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DELETE		
               	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MERGE		
              	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SORT		
             	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_START		
             	||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_STOP) {
            		instProc = (InstructionCobolProcedure) entryProc.getInstruction();	
         			insUpdateViolationOnMap("R0040_AVOID_INSTR_FORBIDDEN_FOR_CICS:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
         			instProc.getMetricViolations().add(EnumMetricsViolation.R0040_AVOID_INSTR_FORBIDDEN_FOR_CICS);
            	}
    		}
		}
      	
      	// Sort
    	if (hs_violations.get("R0138_AVOID_SORT_STATEMENT").isRuleEnabled()) {
        	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SORT) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
          		insUpdateViolationOnMap("R0138_AVOID_SORT_STATEMENT:", sectionParagraphName, entryProc);					// Inserimento/update violazione in map
          		instProc.getMetricViolations().add(EnumMetricsViolation.R0138_AVOID_SORT_STATEMENT);
          		return;
        	}
    	}

      	// Merge
       	if (hs_violations.get("R0044_AVOID_MERGE_STATEMENT").isRuleEnabled()) {
           	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MERGE) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
          		insUpdateViolationOnMap("R0044_AVOID_MERGE_STATEMENT:", sectionParagraphName, entryProc);					// Inserimento/update violazione in map
          		instProc.getMetricViolations().add(EnumMetricsViolation.R0044_AVOID_MERGE_STATEMENT);
          		return;
        	}
       	}

		// Copy
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
			// Si considerano solo i copy visibili nel sorgente
			if (!entryProc.isUnderCopy()) {
    			instrCopy = (InstructionCobol) entryProc.getInstruction();
    			copyName = instrCopy.copyGetName();
    			
    			// Copy in procedure division
    	     	if (hs_violations.get("R0120_AVOID_COPY_INSIDE_PROCEDURE_DIVISION").isRuleEnabled()) {
      				insUpdateViolationOnMap("R0120_AVOID_COPY_INSIDE_PROCEDURE_DIVISION:", sectionParagraphName, entryProc);   				// Inserimento/update violazione in map
     				insUpdateViolationValueOnMap("R0120_AVOID_COPY_INSIDE_PROCEDURE_DIVISION:", sectionParagraphName, copyName);   			// Inserimento/update violazione in map
    	     	}
    	     	
      		 	// Dead code
      	     	if (hs_violations.get("R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE").isRuleEnabled()) {
         		 	if (this.programCobol.deadCodeCopyProc().contains(copyName)) {
          				insUpdateViolationOnMap("R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE:", sectionParagraphName, entryProc);   				// Inserimento/update violazione in map
         				insUpdateViolationValueOnMap("R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE:", sectionParagraphName, copyName);   			// Inserimento/update violazione in map
    				}
      	     	}
			}
			return;
		}

		// Initialize
	    if (hs_violations.get("R0121_AVOID_INITIALIZE_STATEMENT").isRuleEnabled()) {
	   		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_INITIALIZE) {
				insUpdateViolationOnMap("R0121_AVOID_INITIALIZE_STATEMENT:", sectionParagraphName, entryProc);   				// Inserimento/update violazione in map
				insUpdateViolationValueOnMap("R0121_AVOID_INITIALIZE_STATEMENT:", sectionParagraphName, copyName);   			// Inserimento/update violazione in map
			    return;
			}		
	    }

    	// GoTo
    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
    		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
 			ar_labelGoTo = instProc.goToGetLabels();
    		// Scan label
			for (String labelGoTo : ar_labelGoTo) {
			    
				// Violazione goTo paragraph
				if (hs_violations.get("R0046_AVOID_GOTO_PARAGRAPH").isRuleEnabled()) {
					if (this.programCobol.isParagraph(labelGoTo)) {
						insUpdateViolationOnMap("R0046_AVOID_GOTO_PARAGRAPH:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
						instProc.getMetricViolations().add(EnumMetricsViolation.R0046_AVOID_GOTO_PARAGRAPH);
					    continue;
					}
				}
	
				// Violazione goTo label inside Section
				if (hs_violations.get("R0047_AVOID_GOTO_FROM_OUTSIDE_TO_LABEL_INSIDE_SECTION").isRuleEnabled()) {
					numInstr = this.programCobol.labelPointer(labelGoTo);
					entryProcWork = this.programCobol.entryProcedure(numInstr);
					if (entryProcWork.isUnderProcInternal()) {
						sectionParagraphNameGoTo = this.programCobol.procInternalNameOwner(numInstr);
						// Label dentro section
						if (!sectionParagraphNameGoTo.equals(sectionParagraphName) 
						&&  this.programCobol.isSection(sectionParagraphName)) {
							insUpdateViolationOnMap("R0047_AVOID_GOTO_FROM_OUTSIDE_TO_LABEL_INSIDE_SECTION:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
							instProc.getMetricViolations().add(EnumMetricsViolation.R0047_AVOID_GOTO_FROM_OUTSIDE_TO_LABEL_INSIDE_SECTION);
						    continue;
						}
					}
				}
			}  
			return;
    	}
     	
    	// Perform  
    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
     		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
     		
     		// Varying K
     		if (hs_violations.get("R0035_AVOID_PERFORM_VARYING_K_ZONED").isRuleEnabled()) {
         		if (instProc.performIsWithVarying() || instProc.performIsWithTimes()) {
         			if (instProc.performIsWithVarying() ) {
         				varyingIdentifier = instProc.performGetVarying();
    				} else {
    					varyingIdentifier = instProc.performGetTimes();
    				}
            		varyingDataItem = varyingIdentifier.getDataItem();
                    if ((varyingDataItem.getUsage() == EnumCobolUsage.USAGE_DISPLAY   ||
                         varyingDataItem.getUsage() == EnumCobolUsage.USAGE_DISPLAY_1 ||	
                         varyingDataItem.getUsage() == EnumCobolUsage.NOT_ASSIGNED
                        )    
                    &&  (varyingDataItem.getGenericType() == EnumDataItemGeneric.DATA_ITEM_NUMERIC)) {
                    	insUpdateViolationOnMap("R0035_AVOID_PERFORM_VARYING_K_ZONED:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
                    	instProc.getMetricViolations().add(EnumMetricsViolation.R0035_AVOID_PERFORM_VARYING_K_ZONED);	
                    }
             		return;
    			}
     		}
     		
     		// Inner 
    		if (hs_violations.get("R0024_AVOID_HIGH_PERFORM_INNER_INSTR_SIZE").isRuleEnabled()) {
         		if (instProc.performIsInnerPerform()) {
         			numInstrEnd = entryProc.getNumInstrRelated();
         			cntInstrInnerPerform = numInstrEnd - instProc.getNumInstr() - 1;
         			if (cntInstrInnerPerform > EnumMetricsViolation.R0024_AVOID_HIGH_PERFORM_INNER_INSTR_SIZE.getThreshold().getThresholdHigh()) {
                    	insUpdateViolationOnMap("R0024_AVOID_HIGH_PERFORM_INNER_INSTR_SIZE:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
                    	instProc.getMetricViolations().add(EnumMetricsViolation.R0024_AVOID_HIGH_PERFORM_INNER_INSTR_SIZE);	
         			}
             		return;
        		}
    		}
     		
    		// Thru
      		if (instProc.performIsWithThru()) {
      	   		if (hs_violations.get("R0064_AVOID_PERFORM_THRU").isRuleEnabled()) {
      	           	insUpdateViolationOnMap("R0064_AVOID_PERFORM_THRU:", sectionParagraphName, entryProc);						// Inserimento/update violazione in map
                 	instProc.getMetricViolations().add(EnumMetricsViolation.R0064_AVOID_PERFORM_THRU);	
      	   		}
      	   	    if (hs_violations.get("R0065_AVOID_PERFORM_THRU_PARAGRAPH_NOT_SINGLE").isRuleEnabled()) {
              		numInstrStart = instProc.performGetFromNumInstr();
            		numInstrEnd = instProc.performGetThruNumInstr();
            		// Perform thru paragrafo1 thru paragrafo2
            		if (!this.programCobol.isEntrySection(numInstrStart)) {
                		for (i = numInstrStart + 1; i < numInstrEnd; i++) {
                 			// Altri paragrafi fra paragrafo1 e paragrafo2
            				if (this.programCobol.isEntryLabel(i)) {
                            	insUpdateViolationOnMap("R0065_AVOID_PERFORM_THRU_PARAGRAPH_NOT_SINGLE:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
                            	instProc.getMetricViolations().add(EnumMetricsViolation.R0065_AVOID_PERFORM_THRU_PARAGRAPH_NOT_SINGLE);	
            				    break;
            				}
            			} // end-for
        			}
     	   	    }
      		}
      		return;
		}
    	
       	// Move
    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MOVE) {
    		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
    		
     		// Move Corr
        	if (hs_violations.get("R0062_AVOID_CORRESPONDING_OPTION").isRuleEnabled()) {
        		if (instProc.moveIsCorr()) {
        			insUpdateViolationOnMap("R0062_AVOID_CORRESPONDING_OPTION:", sectionParagraphName, entryProc);							// Inserimento/update violazione in map
        			instProc.getMetricViolations().add(EnumMetricsViolation.R0062_AVOID_CORRESPONDING_OPTION);	
        		}
        	}
        	
    		// Move field(pos:lng) To ...
        	if (hs_violations.get("R0061_AVOID_MOVE_REFERENCE_MODIFICATION").isRuleEnabled()) {
        		if (instProc.moveIsRefMod()) {
        			insUpdateViolationOnMap("R0061_AVOID_MOVE_REFERENCE_MODIFICATION:", sectionParagraphName, entryProc);						// Inserimento/update violazione in map
        			instProc.getMetricViolations().add(EnumMetricsViolation.R0061_AVOID_MOVE_REFERENCE_MODIFICATION);
        		}
        	}
        	
     		// Move A TO B         (B smaller then A)
        	if (hs_violations.get("R0063_AVOID_MOVE_TRUNCATED").isRuleEnabled()) {
    			detectViolationCobolMoveTruncated(ivd, entryProc, sectionParagraphName, "R0063_AVOID_MOVE_TRUNCATED:", EnumMetricsViolation.R0063_AVOID_MOVE_TRUNCATED);
        	}
			
			// Move campoX TO campoNum
        	if (hs_violations.get("R0092_AVOID_UNCHECKED_ALPHA_TO_NUM_MOVE").isRuleEnabled()) {
    			detectViolationCobolMoveUncheckedAlphanumeric(ivd, entryProc, sectionParagraphName, "R0092_AVOID_UNCHECKED_ALPHA_TO_NUM_MOVE:", EnumMetricsViolation.R0092_AVOID_UNCHECKED_ALPHA_TO_NUM_MOVE);
        	}
			return;
		}
		
    	// Compute
    	if (hs_violations.get("R0135_AVOID_COMPUTE_FOR_SIMPLE_OPERATIONS").isRuleEnabled()) {
          	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_COMPUTE) {
            	detectViolationComputeUseForSimpleOperation(ivd, entryProc, sectionParagraphName);
        	}
    	}
    	 
		// Evaluate-When con istruzioni condizionali 
    	if (hs_violations.get("R0129_AVOID_EVALUATE_WHEN_WITH_LOGIC_CONDITIONAL").isRuleEnabled()) {
    		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH) {
    			detectViolationWhenWithLogicConditional(entryProc, sectionParagraphName);
    		}
    	}

    	// Next Sentence
    	if (hs_violations.get("R0070_AVOID_NEXT_SENTENCE").isRuleEnabled()) {
        	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_NEXT_SENTENCE) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
       			insUpdateViolationOnMap("R0070_AVOID_NEXT_SENTENCE:", sectionParagraphName, entryProc);						// Inserimento/update violazione in map
       			instProc.getMetricViolations().add(EnumMetricsViolation.R0070_AVOID_NEXT_SENTENCE);
       			return;
    		}
    	}
    	
       	// If
    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF) {
    		instProcIf = (InstructionCobolProcedure) entryProc.getInstruction();
    		numInstrStart = instProcIf.getNumInstr();
    		numInstrEnd = entryProc.getNumInstrRelated();
    		instProc = (InstructionCobolProcedure) this.programCobol.instructionProcedure(numInstrEnd);
    		
    		// Non chiusa da END-IF
           	if (hs_violations.get("R0067_AVOID_IF_CLOSED_BY_DOT").isRuleEnabled()) {
        		if (instProc.getTypeInstr() != EnumCobolReservedWords.PROC_END_IF) {
           			insUpdateViolationOnMap("R0067_AVOID_IF_CLOSED_BY_DOT:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
           			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0067_AVOID_IF_CLOSED_BY_DOT);
        		}
           	}

    		// Nesting level eccessivo 
           	if (hs_violations.get("R0025_AVOID_HIGH_LEVEL_NESTING_IF").isRuleEnabled()) {
        		lvlNesting = this.programCobol.getIfNestingLevel(instProcIf.getNumInstr());
        		if (lvlNesting > EnumMetricsViolation.R0025_AVOID_HIGH_LEVEL_NESTING_IF.getThreshold().getThresholdHigh()) {
        			insUpdateViolationOnMap("R0025_AVOID_HIGH_LEVEL_NESTING_IF:", sectionParagraphName, entryProc);				// Inserimento/update violazione in map
          			insUpdateViolationValueOnMap("R0025_AVOID_HIGH_LEVEL_NESTING_IF:", sectionParagraphName, lvlNesting+"");	// Inserimento/update violazione in map
          			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0025_AVOID_HIGH_LEVEL_NESTING_IF);
           		}
           	}
           	
    		// High number of conditions (And/Or operators count)
           	if (hs_violations.get("R0119_AVOID_HIGH_CONDITIONS_NUMBER").isRuleEnabled()) {
        		expr = instProcIf.ifGetCondition();
        		if (expr.getCountConditions() > EnumMetricsViolation.R0119_AVOID_HIGH_CONDITIONS_NUMBER.getThreshold().getThresholdHigh()) {
          			insUpdateViolationOnMap("R0119_AVOID_HIGH_CONDITIONS_NUMBER:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
          			insUpdateViolationValueOnMap("R0119_AVOID_HIGH_CONDITIONS_NUMBER:", sectionParagraphName, entryProc.getLevelDeepEntry()+"");	// Inserimento/update violazione in map
          			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0119_AVOID_HIGH_CONDITIONS_NUMBER);
    			}
           	}

           	// Magic literal alphanumeric
          	if (hs_violations.get("R0130_AVOID_MAGIC_LITERAL_ALPHANUMERIC").isRuleEnabled()) {
         		if (expr.getOperandsLiteralAlpha().length > 0) {
          			insUpdateViolationOnMap("R0130_AVOID_MAGIC_LITERAL_ALPHANUMERIC:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
            		instProcIf.getMetricViolations().add(EnumMetricsViolation.R0130_AVOID_MAGIC_LITERAL_ALPHANUMERIC);
    			}
          	}

          	// Magic literal numeric
         	if (hs_violations.get("R0131_AVOID_MAGIC_LITERAL_NUMERIC").isRuleEnabled()) {
        		if (expr.getOperandsLiteralNumeric().length > 0) {
          			insUpdateViolationOnMap("R0131_AVOID_MAGIC_LITERAL_NUMERIC:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
           			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0131_AVOID_MAGIC_LITERAL_NUMERIC);
    			}
         	}
         	
     		// Empty if true
         	if (hs_violations.get("R0136_AVOID_IF_TRUE_EMPTY").isRuleEnabled()) {
        		if (this.programCobol.getIfTrueEntries(numInstrStart).size() == 0) {
          			insUpdateViolationOnMap("R0136_AVOID_IF_TRUE_EMPTY:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
          			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0136_AVOID_IF_TRUE_EMPTY);
    			}
         	}
         	
       		// Empty if false
         	if (hs_violations.get("R0137_AVOID_IF_ELSE_EMPTY").isRuleEnabled()) {
        		if (this.programCobol.isIfWithElse(numInstrStart)  && this.programCobol.getIfFalseEntries(numInstrStart).size() == 0) {
          			insUpdateViolationOnMap("R0137_AVOID_IF_ELSE_EMPTY:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
          			instProcIf.getMetricViolations().add(EnumMetricsViolation.R0137_AVOID_IF_ELSE_EMPTY);
        		}
         	}
       		return;
		}  
    	
       	// Evaluate
    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE) {
    		instProcEvaluate = (InstructionCobolProcedure) entryProc.getInstruction();
    		numInstrStart = instProcEvaluate.getNumInstr();
    		numInstrEnd = entryProc.getNumInstrRelated();
    		instProc = (InstructionCobolProcedure) this.programCobol.instructionProcedure(numInstrEnd);
    		
    		// Non è END-EVALUATE
        	if (hs_violations.get("R0066_AVOID_EVALUATE_CLOSED_BY_DOT").isRuleEnabled()) {
        		if (instProc.getTypeInstr() != EnumCobolReservedWords.PROC_END_EVALUATE) {
           			insUpdateViolationOnMap("R0066_AVOID_EVALUATE_CLOSED_BY_DOT:", sectionParagraphName, entryProc);	// Inserimento/update violazione in map
           			instProcEvaluate.getMetricViolations().add(EnumMetricsViolation.R0066_AVOID_EVALUATE_CLOSED_BY_DOT);
        		}
        	}

    		// Verifica presenza WHEN OTHER
        	if (hs_violations.get("R0059_AVOID_EVALUATE_WITHOUT_WHEN_OTHER").isRuleEnabled()) {
        		isThereWhenOther = false;    
        		for (i = numInstrStart; i < numInstrEnd; i++) {
        			entryProcWork =  this.programCobol.entriesProcedure()[i];
        			if (entryProcWork.getTypeInstr() != EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH) {continue;}
        			instProc = (InstructionCobolProcedure) entryProcWork.getInstruction();
        			// E' when Other
        			if (instProc.whenIsOther()) {
        				isThereWhenOther = true; 
        				break;
    				}
        		}
                 // Evaluate senza When Other
    			if (!isThereWhenOther) {
          			insUpdateViolationOnMap("R0059_AVOID_EVALUATE_WITHOUT_WHEN_OTHER:", sectionParagraphName, entryProc);	// Inserimento/update violazione in map
          			instProcEvaluate.getMetricViolations().add(EnumMetricsViolation.R0059_AVOID_EVALUATE_WITHOUT_WHEN_OTHER);
    			}
        	}
			return;
		}
    	
      	// Display
       	if (hs_violations.get("R0055_AVOID_DISPLAY_UPON_CONSOLE").isRuleEnabled()) {
       	   	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DISPLAY) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
        		if (instProc.displayIsWithUpon() && instProc.displayGetIdentifierUpon().getIdentifierType() == EnumCobolReservedWords.ENV_NAME_CONSOLE) {
            		insUpdateViolationOnMap("R0055_AVOID_DISPLAY_UPON_CONSOLE:", sectionParagraphName, entryProc);					// Inserimento/update violazione in map
          			instProc.getMetricViolations().add(EnumMetricsViolation.R0055_AVOID_DISPLAY_UPON_CONSOLE);
        		}
        		return;
        	}
      	}
 
      	// Alter
      	if (hs_violations.get("R0045_AVOID_ALTER_STATEMENT").isRuleEnabled()) {
        	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_ALTER) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
          		insUpdateViolationOnMap("R0045_AVOID_ALTER_STATEMENT:", sectionParagraphName, entryProc);				// Inserimento/update violazione in map
          		instProc.getMetricViolations().add(EnumMetricsViolation.R0045_AVOID_ALTER_STATEMENT);
          		return;
        	}
      	}
        
      	// Call
      	if (hs_violations.get("R0037_AVOID_CALL_STATIC").isRuleEnabled()) {
        	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_CALL) {
        		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
        		// Call statica
        		if (!instProc.isDynamic()) {
             		insUpdateViolationOnMap("R0037_AVOID_CALL_STATIC:", sectionParagraphName, entryProc);				// Inserimento/update violazione in map
             		instProc.getMetricViolations().add(EnumMetricsViolation.R0037_AVOID_CALL_STATIC);
          		}
        		// Campi in parametri call non inizializzati
        		detectViolationUninitializedCallParameters(entryProc, sectionParagraphName, hs_copyWithUninitializedCallParm);
        		return;
         	}
      	}
    	
    	// Individuo tipo istruzione successiva
    	typeInstrNext = EnumCobolReservedWords.NOT_ASSIGNED;
    	numInstrNext = entryProc.getInstruction().getNumInstr() + 1;
    	if (numInstrNext < this.programCobol.entriesProcedure().length) {
    		typeInstrNext = this.programCobol.entryProcedure(numInstrNext).getTypeInstr();
		}
    	
      	// Read without At End
		if (hs_violations.get("R0057_AVOID_READ_WITHOUT_AT_END").isRuleEnabled()) {
	    	if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_READ) {
	    		instProcRead = (InstructionCobolProcedure) entryProc.getInstruction();
	    		fileName = instProcRead.readGetFileNameInternal();
	    		ar_entryProc = this.programCobol.entriesProcedure();
	    		// Cerco open file
	    		for (ProgramCobolEntry<? extends Instruction> entryProcLoop : ar_entryProc) {
					if (entryProcLoop.getTypeInstr() != EnumCobolReservedWords.PROC_OPEN) {continue;}
					instProc = (InstructionCobolProcedure) entryProcLoop.getInstruction();
					ar_fileNameOpenInput = instProc.openGetInputFiles();
					for (String fileNameOpenInput : ar_fileNameOpenInput) {
						// File aperto in input, deve esserci AT END dopo la read 
						if (fileNameOpenInput.equals(fileName)) {
							// Read ultima istruzione del programma
							if (instProcRead.getNumInstr() == this.programCobol.entriesProcedure().length - 1) {
				           		insUpdateViolationOnMap("R0057_AVOID_READ_WITHOUT_AT_END:", sectionParagraphName, entryProc);	// Inserimento/update violazione in map
				           		instProcRead.getMetricViolations().add(EnumMetricsViolation.R0057_AVOID_READ_WITHOUT_AT_END);
				           		break;
							} 
							// Nessuna AT END in istruzione successiva 
							if (typeInstrNext != EnumCobolReservedWords.PROC_AT_END
							&&  typeInstrNext != EnumCobolReservedWords.PROC_NOT_AT_END) {
				           		insUpdateViolationOnMap("R0057_AVOID_READ_WITHOUT_AT_END:", sectionParagraphName, entryProc);	// Inserimento/update violazione in map
				           		instProcRead.getMetricViolations().add(EnumMetricsViolation.R0057_AVOID_READ_WITHOUT_AT_END);
				           		break;
							}
					     }
					} // end-for files open input
					break;
				} // end-for entries
	      	}
		}

  
 		// Test unchecked file status dopo Read/Write/Rewrite/Delete
		if (hs_violations.get("R0077_AVOID_UNCHECKED_FILE_STATUS").isRuleEnabled()) {
			if (isInstrCobolToTestFileStatus(entryProc.getTypeInstr())) {
				// Solo se istruzione successiva non è già di controllo operazione
				if (typeInstrNext != EnumCobolReservedWords.PROC_AT_END
				&&  typeInstrNext != EnumCobolReservedWords.PROC_NOT_AT_END
				&&  typeInstrNext != EnumCobolReservedWords.PROC_INVALID_KEY
				&&  typeInstrNext != EnumCobolReservedWords.PROC_NOT_INVALID_KEY
				&&  typeInstrNext != EnumCobolReservedWords.PROC_AT_END_OF_PAGE
				&&  typeInstrNext != EnumCobolReservedWords.PROC_NOT_AT_END_OF_PAGE
				&&  typeInstrNext != EnumCobolReservedWords.PROC_AT_EOP
				&&  typeInstrNext != EnumCobolReservedWords.PROC_NOT_AT_EOP) {
		      		instProc = (InstructionCobolProcedure) entryProc.getInstruction();
		    		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_READ) {
		    			fileName = instProc.readGetFileNameInternal();
		    		} else if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_WRITE) {
		    			fileName = instProc.writeGetFileNameInternal();
					} else if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_REWRITE) {
		    			fileName = instProc.rewriteGetFileNameInternal();
					} if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_DELETE) {
		    			fileName = instProc.deleteGetFileNameInternal();
					}
					instrProcSelect = this.programCobol.getSelectStatement(fileName);
					// Potrebbe NON essere presente la Select
					if (instrProcSelect != null) {
						fileStatusName = instrProcSelect.selectGetFileStatus1();
						if (!isStatusFieldChecked(entryProc, instProc.getNumInstr(), fileStatusName)) {
				      		insUpdateViolationOnMap("R0077_AVOID_UNCHECKED_FILE_STATUS:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
				      		instrProcSelect.getMetricViolations().add(EnumMetricsViolation.R0077_AVOID_UNCHECKED_FILE_STATUS);
						}
					}
				}
				return;
	    	}
		}

    	
    	// Exec Cics
    	if (entryProc.getInstruction() instanceof InstructionCics) {
			instCics =  (InstructionCics) entryProc.getInstruction();
			
			// Handle Abend
			if (hs_violations.get("R0048_AVOID_CICS_HANDLE_ABEND").isRuleEnabled()) {
				if (instCics.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.CICS_INSTR_HANDLE_ABEND) {
		      		insUpdateViolationOnMap("R0048_AVOID_CICS_HANDLE_ABEND:", sectionParagraphName, entryProc);				// Inserimento/update violazione in map
		      		instCics.getMetricViolations().add(EnumMetricsViolation.R0048_AVOID_CICS_HANDLE_ABEND);
				}
			}
			
			// Handle Aid
			if (hs_violations.get("R0050_AVOID_CICS_HANDLE_AID").isRuleEnabled()) {
				if (instCics.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.CICS_INSTR_HANDLE_AID) {
		      		insUpdateViolationOnMap("R0050_AVOID_CICS_HANDLE_AID:", sectionParagraphName, entryProc);				// Inserimento/update violazione in map
		      		instCics.getMetricViolations().add(EnumMetricsViolation.R0050_AVOID_CICS_HANDLE_AID);
				}
			}
			
			// Handle Condition
			if (hs_violations.get("R0049_AVOID_CICS_HANDLE_CONDITION").isRuleEnabled()) {
				if (instCics.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.CICS_INSTR_HANDLE_CONDITION) {
		      		insUpdateViolationOnMap("R0049_AVOID_CICS_HANDLE_CONDITION:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
		      		instCics.getMetricViolations().add(EnumMetricsViolation.R0049_AVOID_CICS_HANDLE_CONDITION);
				}
			}

			// Ignore Condition
			if (hs_violations.get("R0051_AVOID_CICS_IGNORE_CONDITION").isRuleEnabled()) {
				if (hs_violations.get("R0051_AVOID_CICS_IGNORE_CONDITION").isRuleEnabled()) {
					if (instCics.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.CICS_INSTR_IGNORE_CONDITION) {
			      		insUpdateViolationOnMap("R0051_AVOID_CICS_IGNORE_CONDITION:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
			      		instCics.getMetricViolations().add(EnumMetricsViolation.R0051_AVOID_CICS_IGNORE_CONDITION);
					}
				}
			}
			
			// Test unchecked response 
			if (hs_violations.get("R0078_AVOID_UNCHECKED_CICS_OPERATION").isRuleEnabled()) {
				if (isInstrCicsToTestEibresp(instCics.getTypeInstrPrecompiler())) {
					// RESP specificato, si deve testare il campo indicato nell'istruzione
					if (instCics.isThereOperand("RESP")) {
						fieldEibresp = instCics.getOperand("RESP").getNameIdentifier();
					} else {
						fieldEibresp = "EIBRESP";
					}
					// EIBRESP non testato immediatamente dopo exec cics 
					if (!isStatusFieldChecked(entryProc, instCics.getNumInstr(), fieldEibresp)) {
			      		insUpdateViolationOnMap("R0078_AVOID_UNCHECKED_CICS_OPERATION:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
			      		instCics.getMetricViolations().add(EnumMetricsViolation.R0078_AVOID_UNCHECKED_CICS_OPERATION);
					}
				}
			}
			
			// In XcTl, Link, Return e Start, Commarea specificata senza length
			if (hs_violations.get("R0078_AVOID_UNCHECKED_CICS_OPERATION").isRuleEnabled()) {
				if (instCics.isThereOperand("COMMAREA") && !instCics.isThereOperand("LENGTH")) {
		      		insUpdateViolationOnMap("R0093_AVOID_CICS_COMMAREA_AND_LENGTH_MISSING:", sectionParagraphName, entryProc);		// Inserimento/update violazione in map
		      		instCics.getMetricViolations().add(EnumMetricsViolation.R0093_AVOID_CICS_COMMAREA_AND_LENGTH_MISSING);
				}
			}
			return;
		}
    	
	}

	/*
     * Restituisce se l'istruzione Cobol è fra quelle di cui
     * si deve testare il file status dopo l'esecuzione
     * 
     */
	private boolean isInstrCobolToTestFileStatus(EnumCobolReservedWords typeInstrCobol) {
		
		// File control + Temporary storage/Transient data (TS o TD)
		if (typeInstrCobol == EnumCobolReservedWords.PROC_READ
		||  typeInstrCobol == EnumCobolReservedWords.PROC_WRITE		
		||  typeInstrCobol == EnumCobolReservedWords.PROC_REWRITE		
		||  typeInstrCobol == EnumCobolReservedWords.PROC_DELETE) {		
			return true;
		}	
		return false;
	}



	/*
     * Restituisce se l'istruzione Cics è fra quelle di cui
     * si deve testare EIBRESP dopo l'esecuzione
     * 
     */
	private boolean isInstrCicsToTestEibresp(EnumPrecompilerReservedWords typeInstrPrecompiler) {
		
		// File control + Temporary storage/Transient data (TS o TD)
		if (typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_READ
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_WRITE		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_REWRITE		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_DELETE		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_UNLOCK		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_STARTBR		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_READNEXT		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_READPREV		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_ENDBR		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_WRITEQ		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_READQ		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.CICS_INSTR_DELETEQ	) {
			return true;
		}	
		return false;
	}

	/*
     * Restituisce se l'istruzione Sql è fra quelle di cui
     * si deve testare Sqlcode dopo l'esecuzione
     * 
     */
	private boolean isInstrSqlToTestSqlcode(EnumPrecompilerReservedWords typeInstrPrecompiler) {
		
		// File control + Temporary storage/Transient data (TS o TD)
		if (typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_SELECT
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_INSERT	
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_DELETE	
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_UPDATE		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_FETCH		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_OPEN		
		||  typeInstrPrecompiler == EnumPrecompilerReservedWords.SQL_CLOSE) {
			return true;
		}	
		return false;
	}


	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni di identification division
	 * ---------------------------------------------------------------------------
	 * 
 	 * Individiazione violazione R0073_AVOID_UNDOCUMENTED_PGM_TITLE
	 * Individiazione violazione R0074_AVOID_LOW_DOCUMENTED_PGM
	 * Individiazione violazione R0118_AVOID_PROGRAM_ID_UNEQUAL_FILE_NAME
	 */
    private void detectViolationGlobalId(Map<String, EnumMetricsViolation> hs_violations) {
    	
       	ProgramCobolEntry<? extends Instruction>[] ar_entryIdentification = null;
       	ProgramCobolEntry<? extends Instruction> entryIdentification = null;
       	Instruction instructionGeneric = null;
       	String metricViolationId = "";
       	int numCommBeforeIdDiv = 0;
    	int i = 0;
    	
       	ar_entryIdentification = this.programCobol.entriesIdentification();

    	// Scan istruzioni identification division
       	if (hs_violations.get("R0118_AVOID_PROGRAM_ID_UNEQUAL_FILE_NAME").isRuleEnabled()) {
         	for (i = 0; i < ar_entryIdentification.length; i++) {
         		entryIdentification = ar_entryIdentification[i];
          		if (entryIdentification.getTypeInstr() == EnumCobolReservedWords.ID_DIV_PROGRAM_ID) {
         		   	// Source name diverso da program-id
         	    	if (!this.programCobol.programName.equals(this.programCobol.getProgramId())) {
         	    		instructionGeneric = entryIdentification.getInstruction();
         	       		insUpdateViolationOnMap("R0118_AVOID_PROGRAM_ID_UNEQUAL_FILE_NAME:", "", entryIdentification);						// Inserimento/update violazione in map
         	       	    insUpdateViolationValueOnMap("R0118_AVOID_PROGRAM_ID_UNEQUAL_FILE_NAME:", "", this.programCobol.getProgramId());	// Inserimento/update violazione in map
         	    		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0118_AVOID_PROGRAM_ID_UNEQUAL_FILE_NAME);
         			}
    			}
          	}
       	}
    	
    	// Cerco identification division: potrebbero essereci istruzioni copy prima
     	for (i = 0; i < ar_entryIdentification.length; i++) {
    	   	entryIdentification = ar_entryIdentification[i];
         	if (entryIdentification.getTypeInstr() == EnumCobolReservedWords.ID_DIVISION) {
         		break;
         	}
 		}
    	
      	instructionGeneric = entryIdentification.getInstruction();
    	numCommBeforeIdDiv = instructionGeneric.getCommentsBefore().length;
 
    	// Nessun commento prima di identification division
    	if (hs_violations.get("R0073_AVOID_UNDOCUMENTED_PGM_TITLE").isRuleEnabled()) {
        	if (numCommBeforeIdDiv == 0) {
        		insUpdateViolationOnMap("R0073_AVOID_UNDOCUMENTED_PGM_TITLE:", "", entryIdentification);						// Inserimento/update violazione in map
        		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0073_AVOID_UNDOCUMENTED_PGM_TITLE);
        		return;
    		}
    	}
    	
    	// Commenti insufficienti prima di identification division
    	if (hs_violations.get("R0074_AVOID_LOW_DOCUMENTED_PGM_TITLE").isRuleEnabled()) {
        	if (numCommBeforeIdDiv < EnumMetricsViolation.R0074_AVOID_LOW_DOCUMENTED_PGM_TITLE.getThreshold().getThresholdLow()) {
        		insUpdateViolationOnMap("R0074_AVOID_LOW_DOCUMENTED_PGM_TITLE:", "", entryIdentification);						// Inserimento/update violazione in map
           	    insUpdateViolationValueOnMap("R0074_AVOID_LOW_DOCUMENTED_PGM_TITLE:", "", numCommBeforeIdDiv+"");				// Inserimento/update violazione in map
        		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0074_AVOID_LOW_DOCUMENTED_PGM_TITLE);
        		return;
    		}
    	}
    	
    	// Violazioni rilevate al momento dell'analisi
    	for (ProgramCobolEntry<? extends Instruction> entryId : ar_entryIdentification) {
    		instructionGeneric = entryId.getInstruction();
    		// Scan violazioni rilevate durante l'analisi
    		for (EnumMetricsViolation metricViolation : instructionGeneric.getMetricViolations()) {
   			    metricViolationId = metricViolation.name() + ":";
         		insUpdateViolationOnMap(metricViolationId, "", entryId);										// Inserimento/update violazione in map
     		}
		}
   	}

	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni di environment division
	 * ---------------------------------------------------------------------------
	 * 
	 * Individiazione violazione R0041_AVOID_INSTR_SELECT_FOR_CICS  
	 * Individiazione violazione R0058_AVOID_SELECT_WITHOUT_FILE_STATUS
	 * 
	 */
    private void detectViolationGlobalEnv(Map<String, EnumMetricsViolation> hs_violations) {
    	
    	ProgramCobolEntry<? extends Instruction>[] ar_entryEnv = null;
      	InstructionCobolEnvironment instructionEnv = null;
      	Instruction instructionGeneric = null;
     	String metricViolationId = "";
      	
     	ar_entryEnv = this.programCobol.entriesEnvironment();
     	
     	// Scan entries
     	for (ProgramCobolEntry<? extends Instruction> entryEnv : ar_entryEnv) {
     		
     		// Scan violazioni rilevate durante l'analisi
       		instructionGeneric = entryEnv.getInstruction();
   		    for (EnumMetricsViolation metricViolation : instructionGeneric.getMetricViolations()) {
    			metricViolationId = metricViolation.name() + ":";
       			insUpdateViolationOnMap(metricViolationId, "", entryEnv);													// Inserimento/update violazione in map
			}

     		// Select statement
			if (entryEnv.getTypeInstr() == EnumCobolReservedWords.ENV_DIV_SELECT) {
				instructionEnv = (InstructionCobolEnvironment) entryEnv.getInstruction();
				
	     		// Solo se programma Cics
				if (hs_violations.get("R0041_AVOID_INSTR_SELECT_FOR_CICS").isRuleEnabled()) {
		     		if (this.programCobol.isCicsProgram()) {
	     	      		insUpdateViolationOnMap("R0041_AVOID_INSTR_SELECT_FOR_CICS:", "", entryEnv);							// Inserimento/update violazione in map
	     	      		instructionEnv.getMetricViolations().add(EnumMetricsViolation.R0041_AVOID_INSTR_SELECT_FOR_CICS);
		     		}
				}

				// File status omesso
				if (hs_violations.get("R0058_AVOID_SELECT_WITHOUT_FILE_STATUS").isRuleEnabled()) {
		     		if (instructionEnv.selectGetFileStatus1().equals("")) {
	    	      		insUpdateViolationOnMap("R0058_AVOID_SELECT_WITHOUT_FILE_STATUS:", "", entryEnv);						// Inserimento/update violazione in map
	    	      		instructionEnv.getMetricViolations().add(EnumMetricsViolation.R0058_AVOID_SELECT_WITHOUT_FILE_STATUS);
		     		}
				}
			}
     	}
  	}

    
	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni di data division
	 * ---------------------------------------------------------------------------
	 * 
	 * Individiazione violazione R0036_AVOID_BLOCK_N_RECORDS
	 * Individiazione violazione R0042_AVOID_INSTR_FD_SD_FOR_CICS 
	 * Individiazione violazione R0043_AVOID_BYNARY_FIELDS_NO_SYNC
	 * Individiazione violazione R0060_AVOID_SQLCA_NOT_INCLUDED_IN_SQL_PGM
	 * Individiazione violazione R0079_AVOID_UNUSED_PGM_FIELD
	 * Individiazione violazione R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE
	 * Individiazione violazione R0084_AVOID_UNINITIALIZED_PGM_DATA_FIELD
	 * Individiazione violazione R0085_AVOID_UNINITIALIZED_COPY_FIELD
	 * Individiazione violazione R0086_AVOID_LOW_PERC_FIELD_COMM_BY_ROW
	 * Individiazione violazione R0087_AVOID_LOW_PERC_FIELD_COMM_BY_INSTR
 	 * Individuazione violazione R0095_AVOID_USE_OF_POINTERS
 	 * Individuazione violazione R0099_AVOID_NESTED_COPY
 	 * Individiazione violazione R0105_AVOID_UNCLOSED_FIELD_DEF_BY_DOT (eventualmente rilevata in analisi e presente nell'istruzione)
	 * Individuazione violazione R0109_AVOID_NOT_STD_SIZE_FIELD_NAME
 	 * Individiazione violazione R0122_AVOID_REDEFINES_CLAUSE
 	 * Individiazione violazione R0125_AVOID_VALUE_CLAUSE_IN_LINKAGE
 	 * Individiazione violazione R0126_AVOID_LINKAGE_DATA_NOT_IN_COPYBOOK
 	 * Individuazione violazione R0134_AVOID_UNINITIALIZED_CALL_PARAMETER_AREA_COPY
 	 */
    private void detectViolationGlobalData(Set<String> hs_copyWithUninitializedCallParm, ArrayList<Integer> al_sqlNumInstrData, Map<String, EnumMetricsViolation> hs_violations) {
    	
    	ProgramCobolEntry<? extends Instruction>[] ar_entryData = null;
    	Instruction instructionGeneric = null;
    	InstructionSql instructionSqlInclude = null;
    	InstructionSql instrSql = null;
     	InstructionCobol copyStmt = null;
     	InstructionCobolDataItem dataItem = null;
     	InstructionCobolDataStruct instructionDataStruct = null;
       	String metricViolationId = "";
    	String copyName = "";
     	boolean isThereCopySqlca = false;
    	int percCommByInstr = 0;
    	int percCommByRow = 0;

  	
     	// Calcolo % commenti
     	percCommByInstr = (this.programCobol.getSizeCommData()*100 / this.programCobol.getSizeInstrData());
     	percCommByRow = (this.programCobol.getSizeCommData()*100 / this.programCobol.getSizeSourceData());
     	
     	// % commenti per istruzione dati
     	if (hs_violations.get("R0087_AVOID_LOW_PERC_FIELD_COMM_BY_INSTR").isRuleEnabled()) {
         	if (percCommByInstr < EnumMetricsViolation.R0087_AVOID_LOW_PERC_FIELD_COMM_BY_INSTR.getThreshold().getThresholdLow()) {
         		insUpdateViolationValueOnMap("R0087_AVOID_LOW_PERC_FIELD_COMM_BY_INSTR:", "", percCommByInstr+"");					// Inserimento/update violazione in map
         	}
     	}
     	
     	// % commenti per riga di definizione dati
     	if (hs_violations.get("R0086_AVOID_LOW_PERC_FIELD_COMM_BY_ROW").isRuleEnabled()) {
         	if (percCommByRow < EnumMetricsViolation.R0086_AVOID_LOW_PERC_FIELD_COMM_BY_ROW.getThreshold().getThresholdLow()) {
          		insUpdateViolationValueOnMap("R0086_AVOID_LOW_PERC_FIELD_COMM_BY_ROW:", "", percCommByRow+"");						// Inserimento/update violazione in map
    		}
     	}
     	
     	
     	// Scan entries data division
     	ar_entryData = this.programCobol.entriesData();
     	for (ProgramCobolEntry<? extends Instruction> entryData : ar_entryData) {
     	
    		// Scan violazioni rilevate durante l'analisi, anche Sql
       		instructionGeneric = entryData.getInstruction();
			for (EnumMetricsViolation metricViolation : instructionGeneric.getMetricViolations()) {
				metricViolationId = metricViolation.name() + ":";
				insUpdateViolationOnMap(metricViolationId, "", entryData);														// Inserimento/update violazione in map
			}
            
			// Se istruzione Sql intabello numero
			if (entryData.getInstruction() instanceof InstructionSql) {
				instrSql = (InstructionSql) entryData.getInstruction();
				al_sqlNumInstrData.add(instrSql.getNumInstr());
			}			
			
     	    // Solo se programma Cics
			if (hs_violations.get("R0042_AVOID_INSTR_FD_SD_FOR_CICS").isRuleEnabled()) {
	     		if (this.programCobol.isCicsProgram()) {
	       			if (entryData.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_FD
	    			||  entryData.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_SD	) {
	    				instructionGeneric = entryData.getInstruction();
	    	      		insUpdateViolationOnMap("R0042_AVOID_INSTR_FD_SD_FOR_CICS:", "", entryData);								// Inserimento/update violazione in map
	    	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0042_AVOID_INSTR_FD_SD_FOR_CICS);
	       			}
	  			}
			}
      		
    		// FD con Block n records
			if (hs_violations.get("R0036_AVOID_BLOCK_N_RECORDS").isRuleEnabled()) {
	       		if (entryData.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_FD) {
	       			instructionDataStruct = (InstructionCobolDataStruct) entryData.getInstruction();
	       			if (instructionDataStruct.fdGetBlockFrom() != null && !instructionDataStruct.fdIsBlockZero()) {
	       	      		insUpdateViolationOnMap("R0036_AVOID_BLOCK_N_RECORDS:", "", entryData);									// Inserimento/update violazione in map
	       	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0036_AVOID_BLOCK_N_RECORDS);
	       			}
				}
			}
    		
       		// Copy o Sql Include
      		if (entryData.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY 
      		||  entryData.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) {
      			copyName = "";
      			// Copy
      			if (entryData.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY ) {
    				copyStmt = (InstructionCobol) entryData.getInstruction();
    				copyName = copyStmt.copyGetName();
				}
      			// Sql statement
      			if (entryData.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_SQL) {
      				instructionSqlInclude = (InstructionSql) entryData.getInstruction();
      				if (instructionSqlInclude.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
      					copyName = instructionSqlInclude.sqlIncludeGetName();
					}
				}
      			// Copy o sql include
      			if (!copyName.equals("")) {
          			if (copyName.equals("SQLCA")) {
           				isThereCopySqlca = true;
    				}
          			
          	    	// Copy nested
          			if (hs_violations.get("R0099_AVOID_NESTED_COPY").isRuleEnabled()) {
             	    	if (this.programCobol.getCopyNested().contains(copyName)) {
                			insUpdateViolationOnMap("R0099_AVOID_NESTED_COPY:", "", entryData);   											// Inserimento/update violazione in map
              	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0099_AVOID_NESTED_COPY);
              			}
         			}
          			
           		 	// Copy non utilizzato (dead code)
          			if (hs_violations.get("R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE").isRuleEnabled()) {
            		 	if (this.programCobol.deadCodeCopyData().contains(copyName)) {
              				insUpdateViolationOnMap("R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE:", "", entryData);   				// Inserimento/update violazione in map
              	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0080_AVOID_DEAD_COPY_OR_SQL_INCLUDE);
             			}
          			}
          		 	
                    // Copy contenente campi non inizializzati parametri di qualche call
          			if (hs_violations.get("R0134_AVOID_UNINITIALIZED_CALL_PARAMETER_AREA_COPY").isRuleEnabled()) {
              		    if (hs_copyWithUninitializedCallParm.contains(copyName)) {
              				insUpdateViolationOnMap("R0134_AVOID_UNINITIALIZED_CALL_PARAMETER_AREA_COPY:", "", entryData);   	// Inserimento/update violazione in map
             	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0134_AVOID_UNINITIALIZED_CALL_PARAMETER_AREA_COPY);
         				}
          			}
				}
        	}
      		
       		// A questo punto interessano solo le definizioni dati
     		if (!(entryData.getInstruction() instanceof InstructionCobolDataItem)) {continue;}							
 
     		dataItem = (InstructionCobolDataItem) entryData.getInstruction();
     		
     		// Dimensioni nome campo errate
     		if (hs_violations.get("R0109_AVOID_NOT_STD_SIZE_FIELD_NAME").isRuleEnabled()) {
              	if (dataItem.getDataName().length() < EnumMetricsViolation.R0109_AVOID_NOT_STD_SIZE_FIELD_NAME.getThreshold().getThresholdLow()
              	||  dataItem.getDataName().length() > EnumMetricsViolation.R0109_AVOID_NOT_STD_SIZE_FIELD_NAME.getThreshold().getThresholdHigh()) {
         	      	insUpdateViolationOnMap("R0109_AVOID_NOT_STD_SIZE_FIELD_NAME:", "", entryData);					// Inserimento/update violazione in map
         	      	insUpdateViolationValueOnMap("R0109_AVOID_NOT_STD_SIZE_FIELD_NAME:", "", dataItem.getDataName().length()+"");	// Inserimento/update violazione in map
         	      	dataItem.getMetricViolations().add(EnumMetricsViolation.R0109_AVOID_NOT_STD_SIZE_FIELD_NAME);
             	}
     		}
     		
			// Campo con clausola redefines
     		if (hs_violations.get("R0122_AVOID_REDEFINES_CLAUSE").isRuleEnabled()) {
     			if (dataItem.isRedefinesClause()) {
       	      		insUpdateViolationOnMap("R0122_AVOID_REDEFINES_CLAUSE:", "", entryData);							// Inserimento/update violazione in map
       	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0122_AVOID_REDEFINES_CLAUSE);
     			}
     		}
  			
			// Campo in linkage con value
     		if (hs_violations.get("R0125_AVOID_VALUE_CLAUSE_IN_LINKAGE").isRuleEnabled()) {
     			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
     		  			&&  dataItem.isValueClause()) {
     		   	      		insUpdateViolationOnMap("R0125_AVOID_VALUE_CLAUSE_IN_LINKAGE:", "", entryData);							// Inserimento/update violazione in map
     		   	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0125_AVOID_VALUE_CLAUSE_IN_LINKAGE);
     		 			}
     		}
     		
			// Campo in linkage elementare/gruppo non codificato dentro copy
     		if (hs_violations.get("R0126_AVOID_LINKAGE_DATA_NOT_IN_COPYBOOK").isRuleEnabled()) {
     			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
     		  			&& !entryData.isUnderCopy()) {
     		   	      		insUpdateViolationOnMap("R0126_AVOID_LINKAGE_DATA_NOT_IN_COPYBOOK:", "", entryData);							// Inserimento/update violazione in map
     		   	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0126_AVOID_LINKAGE_DATA_NOT_IN_COPYBOOK);
     		 			}
     		}
     		
			// Campo in working senza value NON in modulo copy
    		if (hs_violations.get("R0084_AVOID_UNINITIALIZED_PGM_DATA_FIELD").isRuleEnabled()) {
     			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_WS_SECTION 
     		 			&& !entryData.isUnderCopy()
     		 			&& !dataItem.getDataName().equals("FILLER")
     		 			&&  dataItem.getLevelNumber() != 88
     					&& !dataItem.isGroupField()
     					&& !dataItem.isRedefinesClause()
     					&& !dataItem.isRenamesClause()
     		 			&& !dataItem.isValueClause()) {
     		   	      		insUpdateViolationOnMap("R0084_AVOID_UNINITIALIZED_PGM_DATA_FIELD:", "", entryData);							// Inserimento/update violazione in map
     		   	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0084_AVOID_UNINITIALIZED_PGM_DATA_FIELD);
     		 			}
    		}
     		
			// Campo in working senza value in modulo copy
       		if (hs_violations.get("R0085_AVOID_UNINITIALIZED_COPY_FIELD").isRuleEnabled()) {
     			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_WS_SECTION 
     		 			&&  entryData.isUnderCopy()
     		 			&& !dataItem.getDataName().equals("FILLER")
     		 			&&  dataItem.getLevelNumber() != 88
     					&& !dataItem.isGroupField()
     					&& !dataItem.isRedefinesClause()
     					&& !dataItem.isRenamesClause()
     		 			&& !dataItem.isValueClause()) {
     		   	      		insUpdateViolationOnMap("R0085_AVOID_UNINITIALIZED_COPY_FIELD:", "", entryData);							// Inserimento/update violazione in map
     		   	      		instructionGeneric.getMetricViolations().add(EnumMetricsViolation.R0085_AVOID_UNINITIALIZED_COPY_FIELD);
     		 			}
       		}

     		// Campo binario senza SYNCRONIZED
       		if (hs_violations.get("R0043_AVOID_BYNARY_FIELDS_NO_SYNC").isRuleEnabled()) {
         		if ((dataItem.getUsage() == EnumCobolUsage.USAGE_BINARY
         	     		||   dataItem.getUsage() == EnumCobolUsage.USAGE_COMP		
         	     		||   dataItem.getUsage() == EnumCobolUsage.USAGE_COMP_4		
         	     		||   dataItem.getUsage() == EnumCobolUsage.USAGE_COMPUTATIONAL		
         	     		||   dataItem.getUsage() == EnumCobolUsage.USAGE_COMPUTATIONAL_4)
         	     		&&  (!dataItem.isSincronizedClause())) {
         	  	      		insUpdateViolationOnMap("R0043_AVOID_BYNARY_FIELDS_NO_SYNC:", "", entryData);							// Inserimento/update violazione in map
         	  	      		dataItem.getMetricViolations().add(EnumMetricsViolation.R0043_AVOID_BYNARY_FIELDS_NO_SYNC);
         	     		}
       		}
     		
     		// Campo Pointer
       		if (hs_violations.get("R0095_AVOID_USE_OF_POINTERS").isRuleEnabled()) {
        		if ((dataItem.getUsage() == EnumCobolUsage.USAGE_POINTER)) {
      	      		insUpdateViolationOnMap("R0095_AVOID_USE_OF_POINTERS:", "", entryData);							// Inserimento/update violazione in map
      	      		dataItem.getMetricViolations().add(EnumMetricsViolation.R0095_AVOID_USE_OF_POINTERS);
         		}
       		}
     		
     		// Field unused (dead code) solo se campo NON definito dentro un copy
      		if (hs_violations.get("R0079_AVOID_UNUSED_PGM_FIELD").isRuleEnabled()) {
        		if (!entryData.isUnderCopy() && entryData.isDeadCode()) {
     	      		insUpdateViolationOnMap("R0079_AVOID_UNUSED_PGM_FIELD:", "", entryData);									// Inserimento/update violazione in map
    	      		dataItem.getMetricViolations().add(EnumMetricsViolation.R0079_AVOID_UNUSED_PGM_FIELD);
    			}
      		}
  		}
     	
     	// Program Sql e SQLCA non presente
     	if (hs_violations.get("R0060_AVOID_SQLCA_NOT_INCLUDED_IN_SQL_PGM").isRuleEnabled()) {
         	if (this.programCobol.isSqlProgram() && !isThereCopySqlca) {
    	      	insUpdateViolationOnMap("R0060_AVOID_SQLCA_NOT_INCLUDED_IN_SQL_PGM:", "", this.programCobol.entryDataDivision(0));	// Inserimento/update violazione in map
         		insUpdateViolationValueOnMap("R0060_AVOID_SQLCA_NOT_INCLUDED_IN_SQL_PGM:", "", "SQLCA");							// Inserimento/update violazione in map
          	}
     	}
 	}

	

	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni di procedure division da verifiche complessive
	 * ---------------------------------------------------------------------------
	 * 
 	 * Individiazione violazione R0039_AVOID_FILE_OPEN_SINGLE 	
 	 * Individuazione violazione R0052_AVOID_FILE_OPEN_NOT_CLOSED
 	 * Individuazione violazione R0053_AVOID_FILE_DEFINED_NOT_USED
	 * Individuazione violazione R0054_AVOID_FILE_OPEN_NOT_USED
 	 * Individuazione violazione R0068_AVOID_HIGH_SECTIONS_NUMBER
	 * Individuazione violazione R0069_AVOID_HIGH_PARAGRAPHS_NUMBER
	 * Individuazione violazione R0071_AVOID_HIGH_PGM_ROWS_SOURCE_SIZE
	 * Individuazione violazione R0072_AVOID_HIGH_PGM_INSTR_SIZE
	 * Individuazione violazione R0075_AVOID_LOW_PGM_PERC_COMM_BY_ROW 
	 * Individuazione violazione R0076_AVOID_LOW_PGM_PERC_COMM_BY_INSTR
	 * Individiazione violazione R0081_AVOID_DEAD_CODE_UNREACHABLE
	 * Individuazione violazione R0083_AVOID_DEAD_PARAGRAPH
	 * Individuazione violazione R0088_AVOID_HIGH_MCBE_PGM_COMPLEXITY
	 * Individuazione violazione R0106_AVOID_INSTR_START_BEFORE_AREA_A (rilevata in fase di analisi)
	 * 
	 */
    private void detectViolationGlobalProc(ArrayList<Integer> al_openFileNumInstr
    									 , ArrayList<String> al_openFile
							    		 , ArrayList<String> al_closeFile
							    		 , ArrayList<String> al_usedFile
							    		 , Map<String, EnumMetricsViolation> hs_violations
							    		  ) {
    	
    	ProgramCobolEntry<? extends Instruction> entryProc = null;
        ProgramCobolEntry<? extends Instruction>[] ar_entriesData = null;
     	ProgramCobolEntry<? extends Instruction>[] ar_entriesEnv = null;
     	ProgramCobolEntry<? extends Instruction> entryIdDivision = null;				// Per aggancio violazioni generiche di programma
       	InstructionCobolDataStruct instrFd = null;
       	InstructionCobolEnvironment instrSelect = null;
       	InstructionCobolProcedure instrProcOpen = null;
      	Instruction instrGeneric = null;
      	Instruction instrProc = null;
  	    Set<ProgramCobolEntry<? extends Instruction>> set_definedFile = null;	// Files definiti da FD/Select in data division
  	    ArrayList<String> al_openFileInstr = null;
  	    ArrayList<String> al_deadCodePatragraph = null;
        ArrayList<Integer> al_deadCodeNumInstr =null;
        String sectionParagraph = "";
  		String definedFile = "";
     	int i = 0;
    	int countSections = 0;
      	int countParagraphs = 0;
      	int countInstrProc = 0;
      	int sizeSource = 0;
       	int percCommByInstr = 0;
    	int percCommByRow = 0;
        Double idxMcCabeTot = null;
        Double rateCommByInstr = null;
        Double rateCommByRow = null;
  
        entryIdDivision = this.programCobol.entryIdentificationDivision(0);					// Di servizio per aggancio violazioni generiche
        
        // Paragrafi non richiamati (dead code)
        if (hs_violations.get("R0083_AVOID_DEAD_PARAGRAPH").isRuleEnabled()) {
            al_deadCodePatragraph = this.programCobol.deadCodeParagraphs();
            for (String deadCodeParagraph : al_deadCodePatragraph) {
            	i = this.programCobol.labelPointer(deadCodeParagraph);
            	entryProc = this.programCobol.entryProcedure(i);
            	instrProc = entryProc.getInstruction();
             	insUpdateViolationOnMap("R0083_AVOID_DEAD_PARAGRAPH:", deadCodeParagraph, entryProc);							// Inserimento/update violazione in map
             	instrProc.getMetricViolations().add(EnumMetricsViolation.R0083_AVOID_DEAD_PARAGRAPH);	
    		}
        }
        
        // Istruzioni non raggiungibili (dead code)
        if (hs_violations.get("R0081_AVOID_DEAD_CODE_UNREACHABLE").isRuleEnabled()) {
            al_deadCodeNumInstr = this.programCobol.deadCodeUnreachable();
            for (Integer numInstr : al_deadCodeNumInstr) {
            	entryProc = this.programCobol.entryProcedure(numInstr);
            	sectionParagraph = this.programCobol.procInternalNameOwner(numInstr);
             	instrProc = entryProc.getInstruction();
             	insUpdateViolationOnMap("R0081_AVOID_DEAD_CODE_UNREACHABLE:", sectionParagraph, entryProc);					// Inserimento/update violazione in map
             	instrProc.getMetricViolations().add(EnumMetricsViolation.R0081_AVOID_DEAD_CODE_UNREACHABLE);	
    		}
        }
        
      	// Recupero % commenti già calcolati per metriche
     	rateCommByInstr = new Double(this.metricsProgram.getPercComByInstruction());
     	rateCommByRow = new Double(this.metricsProgram.getPercComByPhisical());
     	
     	// % commenti per istruzione   
        if (hs_violations.get("R0076_AVOID_LOW_PGM_PERC_COMM_BY_INSTR").isRuleEnabled()) {
         	if (rateCommByInstr < hs_violations.get("R0076_AVOID_LOW_PGM_PERC_COMM_BY_INSTR").getThreshold().getThresholdLow()) {
             	insUpdateViolationOnMap("R0076_AVOID_LOW_PGM_PERC_COMM_BY_INSTR:", "", entryIdDivision);								// Inserimento/update violazione in map
          		insUpdateViolationValueOnMap("R0076_AVOID_LOW_PGM_PERC_COMM_BY_INSTR:", "", percCommByInstr+"");						// Inserimento/update violazione in map
    		}
        }
     	
     	// % commenti per riga 
        if (hs_violations.get("R0075_AVOID_LOW_PGM_PERC_COMM_BY_ROW").isRuleEnabled()) {
         	if (rateCommByRow < hs_violations.get("R0075_AVOID_LOW_PGM_PERC_COMM_BY_ROW").getThreshold().getThresholdLow()) {
         		insUpdateViolationOnMap("R0075_AVOID_LOW_PGM_PERC_COMM_BY_ROW:", "", entryIdDivision);
         		insUpdateViolationValueOnMap("R0075_AVOID_LOW_PGM_PERC_COMM_BY_ROW:", "", percCommByRow+"");						// Inserimento/update violazione in map
    		}
        }
     	
      	// Conteggio section e paragrafi presenti
 		countSections = this.programCobol.getCountSections();
 		countParagraphs = this.programCobol.getCountParagraphs();

       	// Numero section definite
 		if (hs_violations.get("R0068_AVOID_HIGH_SECTIONS_NUMBER").isRuleEnabled()) {
 	    	if (countSections >  hs_violations.get("R0068_AVOID_HIGH_SECTIONS_NUMBER").getThreshold().getThresholdHigh()) {
 	     		insUpdateViolationOnMap("R0068_AVOID_HIGH_SECTIONS_NUMBER:", "", entryIdDivision);
 	 	      	insUpdateViolationValueOnMap("R0068_AVOID_HIGH_SECTIONS_NUMBER:", "", countSections+"");				// Inserimento/update violazione in map
 			}
 		}
    	
     	// Numero paragrafi definiti
 		if (hs_violations.get("R0069_AVOID_HIGH_PARAGRAPHS_NUMBER").isRuleEnabled()) {
 	    	if (countParagraphs >  hs_violations.get("R0069_AVOID_HIGH_PARAGRAPHS_NUMBER").getThreshold().getThresholdHigh()) {
 	    		insUpdateViolationOnMap("R0069_AVOID_HIGH_PARAGRAPHS_NUMBER:", "", entryIdDivision);
 	 	      	insUpdateViolationValueOnMap("R0069_AVOID_HIGH_PARAGRAPHS_NUMBER:", "", countParagraphs+"");			// Inserimento/update violazione in map
 			}
 		}
    	
    	// Numero righe sorgente
 		if (hs_violations.get("R0071_AVOID_HIGH_PGM_ROWS_SOURCE_SIZE").isRuleEnabled()) {
 	    	sizeSource = this.programCobol.getSizeSource();
 	    	if (this.programCobol.getSizeSource() > hs_violations.get("R0071_AVOID_HIGH_PGM_ROWS_SOURCE_SIZE").getThreshold().getThresholdHigh()) {
 	    		insUpdateViolationOnMap("R0071_AVOID_HIGH_PGM_ROWS_SOURCE_SIZE:", "", entryIdDivision);
 		      	insUpdateViolationValueOnMap("R0071_AVOID_HIGH_PGM_ROWS_SOURCE_SIZE:", "", sizeSource+"");			// Inserimento/update violazione in map
 			}
 		}
    	
     	// Numero istruzioni programma
 		if (hs_violations.get("R0072_AVOID_HIGH_PGM_INSTR_SIZE").isRuleEnabled()) {
 	    	countInstrProc = this.programCobol.entriesProcedure().length;
 	    	if (this.programCobol.entriesProcedure().length > hs_violations.get("R0072_AVOID_HIGH_PGM_INSTR_SIZE").getThreshold().getThresholdHigh()) {
 	       		insUpdateViolationOnMap("R0072_AVOID_HIGH_PGM_INSTR_SIZE:", "", entryIdDivision);
 		      	insUpdateViolationValueOnMap("R0072_AVOID_HIGH_PGM_INSTR_SIZE:", "", countInstrProc+"");		// Inserimento/update violazione in map
 			}
 		}

    	// Indice di McCabe max a livello programma (la somma di mainline e procedure interne)
		if (hs_violations.get("R0088_AVOID_HIGH_MCBE_PGM_COMPLEXITY").isRuleEnabled()) {
	    	idxMcCabeTot = new Double(this.metricsProgram.getIdxMcCabeTot());
	    	if (idxMcCabeTot > hs_violations.get("R0088_AVOID_HIGH_MCBE_PGM_COMPLEXITY").getThreshold().getThresholdHigh()*1d) {
	      		insUpdateViolationOnMap("R0088_AVOID_HIGH_MCBE_PGM_COMPLEXITY:", "", entryIdDivision);
		      	insUpdateViolationValueOnMap("R0088_AVOID_HIGH_MCBE_PGM_COMPLEXITY:", "", idxMcCabeTot.toString());				// Inserimento/update violazione in map
			}
		}
    	
   	    // Individuo files definiti da FD o Select (potrebbe esserci select e non FD o viceversa)
      	set_definedFile = new HashSet<ProgramCobolEntry<? extends Instruction>> ();
      	ar_entriesData = this.programCobol.entriesData();
      	for (ProgramCobolEntry<? extends Instruction> entryData : ar_entriesData) {
			if (entryData.getTypeInstr() != EnumCobolReservedWords.DATA_DIV_FD) {continue;}
			set_definedFile.add(entryData);
		}
      	ar_entriesEnv = this.programCobol.entriesEnvironment();
      	for (ProgramCobolEntry<? extends Instruction> entryEnv : ar_entriesEnv) {
			if (entryEnv.getTypeInstr() != EnumCobolReservedWords.ENV_DIV_SELECT) {continue;}
			instrSelect = (InstructionCobolEnvironment) entryEnv.getInstruction();
			set_definedFile.add(entryEnv);
		}
 
    	// Files definiti non usati (open/close/read/..)
		if (hs_violations.get("R0053_AVOID_FILE_DEFINED_NOT_USED").isRuleEnabled()) {
	    	for (ProgramCobolEntry<? extends Instruction> entryEnvData : set_definedFile) {
	      		if (entryEnvData.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_FD) {
	      			instrFd = (InstructionCobolDataStruct) entryEnvData.getInstruction();
	    			instrGeneric = instrFd;
	    			definedFile = instrFd.fdGetFileNameInternal();
				} else {
		   			instrSelect = (InstructionCobolEnvironment) entryEnvData.getInstruction();
		   			instrGeneric = instrSelect;
	    			definedFile = instrSelect.selectGetFileNameInternal();
				}
				if (!al_openFile.contains(definedFile)
				&&  !al_closeFile.contains(definedFile)	
				&&  !al_usedFile.contains(definedFile)) {
	 	      		insUpdateViolationOnMap("R0053_AVOID_FILE_DEFINED_NOT_USED:", "", entryEnvData);						// Inserimento/update violazione in map
			      	insUpdateViolationValueOnMap("R0053_AVOID_FILE_DEFINED_NOT_USED:", "", definedFile);				   // Inserimento/update violazione in map
			      	instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0053_AVOID_FILE_DEFINED_NOT_USED);
				}
	 		}
		}

    	// Scan numeri istruzioni open
    	for (Integer numInstrOpen : al_openFileNumInstr) {
    		entryProc = this.programCobol.entryProcedure(numInstrOpen);
    		instrProcOpen = (InstructionCobolProcedure) entryProc.getInstruction();
    		sectionParagraph = this.programCobol.procInternalNameOwner(numInstrOpen);
    		al_openFileInstr = new ArrayList<String> ();
       		al_openFileInstr.addAll(instrProcOpen.openGetInputFiles());
      		al_openFileInstr.addAll(instrProcOpen.openGetOutputFiles());
      		al_openFileInstr.addAll(instrProcOpen.openGetExtendFiles());
      		al_openFileInstr.addAll(instrProcOpen.openGetIOFiles());
 
       	   	// Open singola con altre open presenti nel programma
    		if (hs_violations.get("R0039_AVOID_FILE_OPEN_SINGLE").isRuleEnabled()) {
            	if (al_openFileNumInstr.size() > 1 && al_openFileInstr.size() == 1) {
      	      		insUpdateViolationOnMap("R0039_AVOID_FILE_OPEN_SINGLE:", sectionParagraph, entryProc);						// Inserimento/update violazione in map
      	      	    instrProcOpen.getMetricViolations().add(EnumMetricsViolation.R0039_AVOID_FILE_OPEN_SINGLE);
        		}
    		}

      	   	// Scan files aperti nell'istruzione  
        	for (String openFileName : al_openFileInstr) {
        		
        		// File aperto e non chiuso
        		if (hs_violations.get("R0052_AVOID_FILE_OPEN_NOT_CLOSED").isRuleEnabled()) {
         			if (!al_closeFile.contains(openFileName)) {
        		      	insUpdateViolationValueOnMap("R0052_AVOID_FILE_OPEN_NOT_CLOSED:", sectionParagraph, openFileName);					// Inserimento/update violazione in map
          	      		insUpdateViolationOnMap("R0052_AVOID_FILE_OPEN_NOT_CLOSED:", sectionParagraph, entryProc);						// Inserimento/update violazione in map
          	      	    instrProcOpen.getMetricViolations().add(EnumMetricsViolation.R0052_AVOID_FILE_OPEN_NOT_CLOSED);
         			}
        		}
 
     	       	// File aperto non utilizzato
        		if (hs_violations.get("R0054_AVOID_FILE_OPEN_NOT_USED").isRuleEnabled()) {
         			if (!al_usedFile.contains(openFileName)) {
        		      	insUpdateViolationValueOnMap("R0054_AVOID_FILE_OPEN_NOT_USED:", sectionParagraph, openFileName);						// Inserimento/update violazione in map
         	      		insUpdateViolationOnMap("R0054_AVOID_FILE_OPEN_NOT_USED:", sectionParagraph, entryProc);						// Inserimento/update violazione in map
          	      	    instrProcOpen.getMetricViolations().add(EnumMetricsViolation.R0054_AVOID_FILE_OPEN_NOT_USED);
         			}
        		}
        	}
   		}
   	}

	/* ---------------------------------------------------------------------------
	 * Violazioni Sql rilevabili solo dopo analisi data e proc division
	 * ---------------------------------------------------------------------------
	 * 
	 * Individiazione violazione R0140_AVOID_SQL_SELECT_STAR
 	 * Individiazione violazione R0141_AVOID_SQL_USE
	 * Individiazione violazione R0143_AVOID_SQL_UNCLOSED_CURSOR
 	 * Individiazione violazione R0144_AVOID_SQL_DECLARED_AND_UNUSED_CURSOR
	 * Individiazione violazione R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER
 	 * Individiazione violazione R0146_AVOID_SQL_HIGH_TABLES_NUMBER
 	 * Individiazione violazione R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER
  	 * Individiazione violazione R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER
 	 * Individiazione violazione R0149_AVOID_SQL_DECLARE_CURSOR_WITH_NO_ORDER_BY
	 * Individiazione violazione R0150_AVOID_SQL_SELECT_WITH_UNION
 	 * Individiazione violazione R0151_AVOID_SQL_SELECT_WITH_DISTINCT
	 * Individiazione violazione R0152_AVOID_SQL_SELECT_WITH_GROUP_BY
	 * Individiazione violazione R0154_AVOID_SQL_SELECT_WITH_NO_WHERE
	 * Individiazione violazione R0155_AVOID_SQL_DELETE_WITH_NO_WHERE
	 * Individiazione violazione R0156_AVOID_SQL_UPDATE_WITH_NO_WHERE
 	 * Individiazione violazione R0153_AVOID_SQL_DYNAMIC
 	 * Individiazione violazione R0157_AVOID_SQL_WHERE_WITH_LIKE_PREDICATE
 	 * Individiazione violazione R0159_AVOID_SQL_UNCHECKED_CODE
 	 * 
     */
    private void detectViolationGlobalSql(Set<String> hs_sqlCursorOpen
							    		, Set<String> hs_sqlCursorClose
							    		, Set<String> hs_sqlCursorFetch
							    		, ArrayList<Integer> al_sqlNumInstrProc
							    		, ArrayList<Integer> al_sqlNumInstrData
							    		, Map<String, EnumMetricsViolation> hs_violations) {
    	
    	ProgramCobolEntry<? extends Instruction> entryProc = null;
    	SqlSelectStatement sqlSelectDescriptor = null;
    	SqlDeleteStatement sqlDeleteDescriptor = null;
    	SqlUpdateStatement sqlUpdateDescriptor = null;
    	SqlDeclareCursorStatement sqlDeclareCursorStmt = null;
    	SqlSearchConditions sqlWhere = null;
    	InstructionSql instrSql = null;
    	String sectionParagraphName = "";
       	String sqlCursor = "";
     	int numTables = 0;
    	int numTablesJoinedMax = 0;
    	int numSubselectNestedMax = 0;
      	int numSearchConditions = 0;
       	
     	// Scan istruzioni sql procedure division
       	for (Integer numInstr : al_sqlNumInstrProc) {
       		
       		entryProc = this.programCobol.entryProcedure(numInstr);
        	instrSql = (InstructionSql) entryProc.getInstruction();
           	sectionParagraphName = this.programCobol.procInternalNameOwner(instrSql.getNumInstr());
           	sqlWhere = null;
           	numTables = 0;
           	numTablesJoinedMax = 0;
           	
           	// Sql vietato
           	if (hs_violations.get("R0141_AVOID_SQL_USE").isRuleEnabled()) {
          		insUpdateViolationOnMap("R0141_AVOID_SQL_USE:", sectionParagraphName, entryProc);					// Inserimento/update violazione in map
          		instrSql.getMetricViolations().add(EnumMetricsViolation.R0141_AVOID_SQL_USE);
           	}
      		
     		// Declare cursor
     		if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DECLARE_CURSOR) {
     			sqlDeclareCursorStmt = instrSql.sqlDeclareCursorGetDescriptor();
     			sqlCursor = sqlDeclareCursorStmt.getCursorName();
     			
     			// Nessuna Close esplicita del cursore
     			if (hs_violations.get("R0143_AVOID_SQL_UNCLOSED_CURSOR").isRuleEnabled()) {
        			if (!hs_sqlCursorClose.contains(sqlCursor)) {
           	      		insUpdateViolationOnMap("R0143_AVOID_SQL_UNCLOSED_CURSOR:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
           	      	    instrSql.getMetricViolations().add(EnumMetricsViolation.R0143_AVOID_SQL_UNCLOSED_CURSOR);
    				}
    			}
     			
      			// Cursore definito e non utilizzato
     			if (hs_violations.get("R0144_AVOID_SQL_DECLARED_AND_UNUSED_CURSOR").isRuleEnabled()) {
         			if (!hs_sqlCursorOpen.contains(sqlCursor) && !hs_sqlCursorFetch.contains(sqlCursor)) {
          	      		insUpdateViolationOnMap("R0144_AVOID_SQL_DECLARED_AND_UNUSED_CURSOR:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
           	      	    instrSql.getMetricViolations().add(EnumMetricsViolation.R0144_AVOID_SQL_DECLARED_AND_UNUSED_CURSOR);
    				}
     			}
     			
     			// Order By omesso 
     			if (hs_violations.get("R0149_AVOID_SQL_DECLARE_CURSOR_WITH_NO_ORDER_BY").isRuleEnabled()) {
        			sqlSelectDescriptor = sqlDeclareCursorStmt.getSelectStatement();
         			if (!sqlSelectDescriptor.getFullSelect().isOrderBySubselect()) {
         	      		insUpdateViolationOnMap("R0149_AVOID_SQL_DECLARE_CURSOR_WITH_NO_ORDER_BY:", sectionParagraphName, entryProc);								// Inserimento/update violazione in map
           	      	    instrSql.getMetricViolations().add(EnumMetricsViolation.R0149_AVOID_SQL_DECLARE_CURSOR_WITH_NO_ORDER_BY);
    				}
    			}
      			
				// Where omessa
     			if (hs_violations.get("R0154_AVOID_SQL_SELECT_WITH_NO_WHERE").isRuleEnabled()) {
    				if (sqlSelectDescriptor.getFullSelect().isSubSelect()) {
    	     			sqlWhere = sqlSelectDescriptor.getFullSelect().getSubselectInto().getWhere();
    					if (!sqlSelectDescriptor.getFullSelect().getSubselectInto().isWhere()) {
    			      		insUpdateViolationOnMap("R0154_AVOID_SQL_SELECT_WITH_NO_WHERE:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
    			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0154_AVOID_SQL_SELECT_WITH_NO_WHERE);
    					}
    				}
     			}
     			
				numTables = sqlSelectDescriptor.getFullSelect().getSubselectInto().getEntities().size();
				numSubselectNestedMax = sqlSelectDescriptor.getMaxSubselectNestedNumber();
				numTablesJoinedMax = sqlSelectDescriptor.getMaxJoinedTablesNumber();
 			}
     		
			// Select
			if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_SELECT) {
				sqlSelectDescriptor = instrSql.sqlSelectGetDescriptor();
				numSubselectNestedMax = sqlSelectDescriptor.getMaxSubselectNestedNumber();
				
				// Select *
				if (hs_violations.get("R0140_AVOID_SQL_SELECT_STAR").isRuleEnabled()) {
					if (sqlSelectDescriptor.isSelectStar()) {
			      		insUpdateViolationOnMap("R0140_AVOID_SQL_SELECT_STAR:", sectionParagraphName, entryProc);					// Inserimento/update violazione in map
			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0140_AVOID_SQL_SELECT_STAR);
					}
				}
				
				// Select ... Union ...
				if (hs_violations.get("R0150_AVOID_SQL_SELECT_WITH_UNION").isRuleEnabled()) {
					if (sqlSelectDescriptor.getFullSelect().isFullSelectWithLinkedTo()) {
			      		insUpdateViolationOnMap("R0150_AVOID_SQL_SELECT_WITH_UNION:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0150_AVOID_SQL_SELECT_WITH_UNION);
					}
				}

				// Select Distinct .....
				if (hs_violations.get("R0151_AVOID_SQL_SELECT_WITH_DISTINCT").isRuleEnabled()) {
					if (sqlSelectDescriptor.getFullSelect().isSubSelect()) {
						if (sqlSelectDescriptor.getFullSelect().getSubselectInto().isSelectDistinct()) {
				      		insUpdateViolationOnMap("R0151_AVOID_SQL_SELECT_WITH_DISTINCT:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
				      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0151_AVOID_SQL_SELECT_WITH_DISTINCT);
						}
					}
				}
				
				// Select ... Group By ...
				if (hs_violations.get("R0152_AVOID_SQL_SELECT_WITH_GROUP_BY").isRuleEnabled()) {
					if (sqlSelectDescriptor.getFullSelect().isSubSelect()) {
						if (sqlSelectDescriptor.getFullSelect().getSubselectInto().isGroupBy()) {
				      		insUpdateViolationOnMap("R0152_AVOID_SQL_SELECT_WITH_GROUP_BY:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
				      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0152_AVOID_SQL_SELECT_WITH_GROUP_BY);
						}
					}
				}

				// Where omessa
				if (hs_violations.get("R0154_AVOID_SQL_SELECT_WITH_NO_WHERE").isRuleEnabled()) {
					if (sqlSelectDescriptor.getFullSelect().isSubSelect()) {
						sqlWhere = sqlSelectDescriptor.getFullSelect().getSubselectInto().getWhere();
						if (!sqlSelectDescriptor.getFullSelect().getSubselectInto().isWhere()) {
				      		insUpdateViolationOnMap("R0154_AVOID_SQL_SELECT_WITH_NO_WHERE:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
				      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0154_AVOID_SQL_SELECT_WITH_NO_WHERE);
						}
					}
				}
				
				numTables = sqlSelectDescriptor.getFullSelect().getSubselectInto().getEntities().size();
				numTablesJoinedMax = sqlSelectDescriptor.getFullSelect().getMaxJoinedTablesNumber();
			}
			
			// Delete con where omessa
			if (hs_violations.get("R0155_AVOID_SQL_DELETE_WITH_NO_WHERE").isRuleEnabled()) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DELETE) {
					sqlDeleteDescriptor = instrSql.sqlDeleteGetDescriptor();
					numTables = sqlDeleteDescriptor.getEntities().size();
					numSubselectNestedMax = sqlDeleteDescriptor.getMaxSubselectNestedNumber();
					sqlWhere = sqlDeleteDescriptor.getWhere();
					if (!sqlDeleteDescriptor.isWhere()) {
			      		insUpdateViolationOnMap("R0155_AVOID_SQL_DELETE_WITH_NO_WHERE:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0155_AVOID_SQL_DELETE_WITH_NO_WHERE);
					}
				}
			}

			// Update con where omessa
			if (hs_violations.get("R0156_AVOID_SQL_UPDATE_WITH_NO_WHERE").isRuleEnabled()) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_UPDATE) {
					sqlUpdateDescriptor = instrSql.sqlUpdateGetDescriptor();
					numTables = sqlUpdateDescriptor.getEntities().size();
					numSubselectNestedMax = sqlUpdateDescriptor.getMaxSubselectNestedNumber();
					sqlWhere = sqlUpdateDescriptor.getWhere();
					if (!sqlUpdateDescriptor.isWhere()) {
			      		insUpdateViolationOnMap("R0156_AVOID_SQL_UPDATE_WITH_NO_WHERE:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0156_AVOID_SQL_UPDATE_WITH_NO_WHERE);
					}
				}
			}

			// Where codificata
			if (sqlWhere != null) {
				
				// Con predicato Like
				if (hs_violations.get("R0157_AVOID_SQL_WHERE_WITH_LIKE_PREDICATE").isRuleEnabled()) {
					for (SqlSearchConditions searchCondition : sqlWhere.getSearchConditionsElementary()) {
						if (searchCondition.getPredicate().getTypePredicate() == EnumSqlPredicate.LIKE) {
				      		insUpdateViolationOnMap("R0157_AVOID_SQL_WHERE_WITH_LIKE_PREDICATE:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
				      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0157_AVOID_SQL_WHERE_WITH_LIKE_PREDICATE);
						}
					}
				}

				// Con troppe condizioni di search elementari
				if (hs_violations.get("R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER").isRuleEnabled()) {
					numSearchConditions = sqlWhere.getSearchConditionsElementary().size();
					if (numSearchConditions > EnumMetricsViolation.R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER.getThreshold().getThresholdHigh()) {
			      		insUpdateViolationOnMap("R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
			      		insUpdateViolationValueOnMap("R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER:", sectionParagraphName, numSearchConditions+"");								// Inserimento/update violazione in map
			      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0145_AVOID_SQL_HIGH_WHERE_CONDITIONS_NUMBER);
					}
				}
			}
			
			// Numero tabelle in join eccessivo
			if (hs_violations.get("R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER").isRuleEnabled()) {
				if (numTablesJoinedMax > hs_violations.get("R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER").getThreshold().getThresholdHigh()) {
		      		insUpdateViolationOnMap("R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
		      		insUpdateViolationValueOnMap("R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER:", sectionParagraphName, numTablesJoinedMax+"");								// Inserimento/update violazione in map
		      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0148_AVOID_SQL_HIGH_TABLES_JOINED_NUMBER);
				}
			}
			
			// Numero subselect nested eccessivo
			if (hs_violations.get("R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER").isRuleEnabled()) {
				if (numSubselectNestedMax > hs_violations.get("R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER").getThreshold().getThresholdHigh()) {
		      		insUpdateViolationOnMap("R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
		      		insUpdateViolationValueOnMap("R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER:", sectionParagraphName, numSubselectNestedMax+"");								// Inserimento/update violazione in map
		      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0147_AVOID_SQL_HIGH_SUBSELECT_NESTED_NUMBER);
				}
			}
			 
			// Numero tabelle utilizzato eccessivo
			// Select ... FROM tb1, tb2, tbn
			if (hs_violations.get("R0146_AVOID_SQL_HIGH_TABLES_NUMBER").isRuleEnabled()) {
	 			if (numTables > hs_violations.get("R0146_AVOID_SQL_HIGH_TABLES_NUMBER").getThreshold().getThresholdHigh()) {
		      		insUpdateViolationOnMap("R0146_AVOID_SQL_HIGH_TABLES_NUMBER:", sectionParagraphName, entryProc);										// Inserimento/update violazione in map
		      		insUpdateViolationValueOnMap("R0146_AVOID_SQL_HIGH_TABLES_NUMBER:", sectionParagraphName, numTables+"");								// Inserimento/update violazione in map
		      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0146_AVOID_SQL_HIGH_TABLES_NUMBER);
				}
			}
			
			// SqlCode non testato immediatamente dopo exec sql 
			if (hs_violations.get("R0159_AVOID_SQL_UNCHECKED_CODE").isRuleEnabled()) {
	 			if (isInstrSqlToTestSqlcode(instrSql.getTypeInstrPrecompiler()) && !isStatusFieldChecked(entryProc, instrSql.getNumInstr(), "SQLCODE")) {
		      		insUpdateViolationOnMap("R0159_AVOID_SQL_UNCHECKED_CODE:", sectionParagraphName, entryProc);			// Inserimento/update violazione in map
		      		instrSql.getMetricViolations().add(EnumMetricsViolation.R0159_AVOID_SQL_UNCHECKED_CODE);
				}
			}
			
		    //  Dynamic Sql
			if (hs_violations.get("R0153_AVOID_SQL_DYNAMIC").isRuleEnabled()) {
				if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_PREPARE
				||	instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_EXECUTE	
				||	instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_EXECUTE_IMMEDIATE) {
					insUpdateViolationOnMap("R0153_AVOID_SQL_DYNAMIC:", sectionParagraphName, entryProc);   // Inserimento/update violazione in map
					instrSql.getMetricViolations().add(EnumMetricsViolation.R0153_AVOID_SQL_DYNAMIC);		
				}
			}
  		}
	}

 
	/* ----------------------------------------------------------- 
	 * Individuazione violazioni del programma nel suo complesso
	 * ----------------------------------------------------------- 
	 * 
	 * Individuazione violazione R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY
 	 * Individuazione violazione R0101_AVOID_ID_DIVISION_MISSING
	 * Individuazione violazione R0102_AVOID_ENV_DIVISION_MISSING
	 * Individuazione violazione R0103_AVOID_DATA_DIVISION_MISSING
	 * Individuazione violazione R0100_AVOID_COPY_ACROSS_DIVISION
	 * 
	 */
    private void detectViolationGlobalProgram(Map<String, EnumMetricsViolation> hs_violations) {
    	
       	ProgramCobolEntry<? extends Instruction> entry1 = null;
       	ProgramCobolEntry<? extends Instruction> entry2 = null;
      	ProgramCobolEntry<? extends Instruction> entryIdDiv = null;
     	ProgramCobolEntry<? extends Instruction> entryEnvDiv = null;
     	ProgramCobolEntry<? extends Instruction> entryDataDiv = null;
    	Instruction instrGeneric = null;
      	
    	// Id division omessa 
    	if (hs_violations.get("R0101_AVOID_ID_DIVISION_MISSING").isRuleEnabled()) {
          	entryIdDiv = this.programCobol.entryIdentificationDivision(0);
          	instrGeneric = entryIdDiv.getInstruction();
        	if (entryIdDiv.getTypeInstr() != EnumCobolReservedWords.ID_DIVISION) {
        		insUpdateViolationOnMap("R0101_AVOID_ID_DIVISION_MISSING:", "", entryIdDiv);
        		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0101_AVOID_ID_DIVISION_MISSING);
    		}
    	}
 
    	// Env division omessa (senza istruzioni o manca lo statement di divisione)
    	if (hs_violations.get("R0102_AVOID_ENV_DIVISION_MISSING").isRuleEnabled()) {
           	if (this.programCobol.entriesEnvironment().length == 0) {
           		entryEnvDiv = new ProgramCobolEntry<Instruction> ();
           		insUpdateViolationOnMap("R0102_AVOID_ENV_DIVISION_MISSING:", "", entryEnvDiv);
    		}
          	if (this.programCobol.entriesData().length > 0) {
        	   	entryEnvDiv = this.programCobol.entryEnvironmentDivision(0);
        	   	instrGeneric = entryEnvDiv.getInstruction();
        	   	if (entryEnvDiv.getTypeInstr() != EnumCobolReservedWords.ENV_DIVISION) {
        	   		insUpdateViolationOnMap("R0102_AVOID_ENV_DIVISION_MISSING:", "", entryEnvDiv);
        	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0102_AVOID_ENV_DIVISION_MISSING);
        	   	}
    		}
    	}
    	
    	// Data division omessa (senza istruzioni o manca lo statement di divisione)
    	if (hs_violations.get("R0103_AVOID_DATA_DIVISION_MISSING").isRuleEnabled()) {
          	if (this.programCobol.entriesEnvironment().length == 0) {
           		entryDataDiv = new ProgramCobolEntry<Instruction> ();
           		insUpdateViolationOnMap("R0103_AVOID_DATA_DIVISION_MISSING:", "", entryDataDiv);
    		}
          	if (this.programCobol.entriesData().length > 0) {
        	   	entryDataDiv = this.programCobol.entryDataDivision(0);
        	   	instrGeneric = entryDataDiv.getInstruction();
        	   	if (entryDataDiv.getTypeInstr() != EnumCobolReservedWords.DATA_DIVISION) {
        	   		insUpdateViolationOnMap("R0103_AVOID_DATA_DIVISION_MISSING:", "", entryDataDiv);
        	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0103_AVOID_DATA_DIVISION_MISSING);
        	   	}
    		}
    	}
     	
    	// Copy a cavallo di identification e environment
      	if (this.programCobol.entriesEnvironment().length > 0) {
           	entry1 = this.programCobol.entryIdentificationDivision(this.programCobol.entriesIdentification().length - 1);
           	entry2 = this.programCobol.entryEnvironmentDivision(0);
           	if (entry1 != null && entry2 != null
           	&&  entry1.isUnderCopy() 
        	&&  entry2.isUnderCopy()
        	&&  entry1.getUnderCopyName().equals(entry2.getUnderCopyName())) {
           		// cerco ultimo copy statement di identification
           		for (int i = this.programCobol.entriesIdentification().length - 1; i >= 0; i--) {
           			entryIdDiv = this.programCobol.entryIdentificationDivision(i);
           			if (entryIdDiv.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
           				
           				// Copy  across division
           				if (hs_violations.get("R0100_AVOID_COPY_ACROSS_DIVISION").isRuleEnabled()) {
                   	   		insUpdateViolationOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entryIdDiv);
                	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0100_AVOID_COPY_ACROSS_DIVISION);
                	   		insUpdateViolationValueOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entry1.getUnderCopyName());
          				}
             	   		
            	   		// Division statement inside copy
           				if (hs_violations.get("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY").isRuleEnabled()) {
                	      	insUpdateViolationOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "", entryDataDiv);
                	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY);
                	      	insUpdateViolationValueOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "","ENVIRONMENT DIVISION");		    // Inserimento/update violazione in map
           				}
           			    break;
           			}
    			}
    		}
      	}
    	
    	// Copy a cavallo di environment e data
      	if (this.programCobol.entriesEnvironment().length > 0 && this.programCobol.entriesData().length > 0) {
           	if (this.programCobol.entriesEnvironment().length > 0
   	       	&&  this.programCobol.entriesData().length > 0) {
   	          	entry1 = this.programCobol.entryEnvironmentDivision(this.programCobol.entriesEnvironment().length - 1);
   	           	entry2 = this.programCobol.entryDataDivision(0);
   	        	if (entry1 != null && entry2 != null
   	        	&&  entry1.isUnderCopy() 
   	        	&&  entry2.isUnderCopy()
   	        	&&  entry1.getUnderCopyName().equals(entry2.getUnderCopyName())) {
   	           		// cerco ultimo copy statement di environment
   	           		for (int i = this.programCobol.entriesEnvironment().length - 1; i >= 0; i--) {
   	           			entryEnvDiv = this.programCobol.entryEnvironmentDivision(i);
   	           			if (entryEnvDiv.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
   	           				
   	           				// Copy  across division
   	           			    if (hs_violations.get("R0100_AVOID_COPY_ACROSS_DIVISION").isRuleEnabled()) {
   	  	            	   		insUpdateViolationOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entryEnvDiv);
   	   	            	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0100_AVOID_COPY_ACROSS_DIVISION);
   	   	            	      	insUpdateViolationValueOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entry1.getUnderCopyName());				// Inserimento/update violazione in map
   	           			    }
    	            	   		
   	            	      	// Division statement inside copy
   	           			    if (hs_violations.get("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY").isRuleEnabled()) {
   	   	            	      	insUpdateViolationOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "", entryDataDiv);
   	   	            	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY);
   	   	            	      	insUpdateViolationValueOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "","DATA DIVISION");		    // Inserimento/update violazione in map
   	           			    }
   	           			    break;
   	           			}
   	    			}
   	     		}
   			}
      	}
     	
    	// Copy a cavallo di data e procedure
       	if (this.programCobol.entriesData().length > 0
       	&&  this.programCobol.entriesProcedure().length > 0) {
          	entry1 = this.programCobol.entryDataDivision(this.programCobol.entriesData().length - 1);
           	entry2 = this.programCobol.entryProcedure(0);
        	if (entry1 != null && entry2 != null
        	&&  entry1.isUnderCopy() 
        	&&  entry2.isUnderCopy()
        	&&  entry1.getUnderCopyName().equals(entry2.getUnderCopyName())) {
          		// Cerco ultimo copy statement di Data
           		for (int i = this.programCobol.entriesData().length - 1; i >= 0; i--) {
           			entryDataDiv = this.programCobol.entryDataDivision(i);
           			if (entryDataDiv.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY 
           			&& !entryDataDiv.isEntryPrecompiler()) {
           				
           				// Copy  across division
           				if (hs_violations.get("R0100_AVOID_COPY_ACROSS_DIVISION").isRuleEnabled()) {
                	   		insUpdateViolationOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entryDataDiv);
                	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0100_AVOID_COPY_ACROSS_DIVISION);
                	      	insUpdateViolationValueOnMap("R0100_AVOID_COPY_ACROSS_DIVISION:", "", entry1.getUnderCopyName());				// Inserimento/update violazione in map
           				}
            	   		
            	      	// Division statement inside copy
           				if (hs_violations.get("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY").isRuleEnabled()) {
                	      	insUpdateViolationOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "", entryDataDiv);
                	   		instrGeneric.getMetricViolations().add(EnumMetricsViolation.R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY);
                	      	insUpdateViolationValueOnMap("R0089_AVOID_COBOL_DIVISION_STMT_INSIDE_COPY:", "","PROCEDURE DIVISION");		    // Inserimento/update violazione in map
           				}
           			    break;
           			}
    			}
    		}
      	}
         	
	}


	/* ---------------------------------------------------------------------------
	 * Individuazione violazioni da verificare via user exit esterna
	 * ---------------------------------------------------------------------------
	 * 
 	 * Si tratta di violazioni a standard di nomenclatura, lunghezza campi etc.
 	 * 
	 * Individuazione violazioni R0110_AVOID_NOT_STD_PGM_NAME
	 * Individuazione violazioni R0111_AVOID_NOT_STD_SECTION_NAME
	 * Individuazione violazioni R0112_AVOID_NOT_STD_PARAGRAPH_NAME
	 * Individuazione violazioni R0113_AVOID_NOT_STD_LABEL_NAME
	 * Individiazione violazione R0114_AVOID_NOT_STD_FIELD_NAME
	 * Individiazione violazione R0115_AVOID_NOT_STD_PARAGRAPH_THRU_NAME
	 * Individiazione violazione R0116_AVOID_NOT_STD_SECTION_THRU_NAME
	 */
    private void detectViolationByUserExit(Map<String, EnumMetricsViolation> hs_violations) throws ExceptionAmrita {
    	
      	ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
      	ProgramCobolEntry<? extends Instruction>[] ar_entryData = null;
      	ProgramCobolEntry<? extends Instruction> entryProcThru = null;
    	InstructionCobolProcedure instrProc = null;
    	InstructionCobolProcedure instrProcThru = null;
    	InstructionCobolDataItem instrData = null;
    	UserExitInfo userExitInfo = null;
     	userExitInfo = new UserExitInfo();
     	String labelName = "";
       	String sectionName = "";
       	String sectionNameThru = "";
     	String paragraphName = "";
       	String paragraphNameThru = "";
       	String sectionParagraph = "";
        int numInstr = 0;
        
    	userExitInfo.setProgramCobol(this.programCobol);

    	// Nome programma
    	if (hs_violations.get("R0110_AVOID_NOT_STD_PGM_NAME").isRuleEnabled()) {
         	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_PGM);
        	userExitInfo.setNameToEvaluate(this.pgmNameUnderParsing);
        	this.userExitGenericActivate(userExitInfo);
        	if (userExitInfo.getReturnCode() != 0) {
    			insUpdateViolationOnMapOnlyRow("R0110_AVOID_NOT_STD_PGM_NAME:", "", 0);   						// Inserimento/update violazione in map
    	      	insUpdateViolationValueOnMap("R0110_AVOID_NOT_STD_PGM_NAME:", "", this.pgmNameUnderParsing );	// Inserimento/update violazione in map
    		}
    	}
    	
      	ar_entryProc = this.programCobol.entriesProcedure();
  
     	// Scan istruzioni di procedure division
    	for (ProgramCobolEntry<? extends Instruction> entryProc : ar_entryProc) {
    		
     		// Section
    		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
    			instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
 				sectionName = instrProc.sectionGetName();
 				
 				// Ctrl section name via exit
 				if (hs_violations.get("R0111_AVOID_NOT_STD_SECTION_NAME").isRuleEnabled()) {
 			       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_SECTION);
 		        	userExitInfo.setNameToEvaluate(sectionName);
 		        	this.userExitGenericActivate(userExitInfo);
 		        	if (userExitInfo.getReturnCode() != 0) {
 		    	      	insUpdateViolationOnMap("R0111_AVOID_NOT_STD_SECTION_NAME:", sectionName, entryProc);								// Inserimento/update violazione in map
 		    	      	instrProc.getMetricViolations().add(EnumMetricsViolation.R0111_AVOID_NOT_STD_SECTION_NAME);
 		        	}
 				}
	        	
	        	// Thru section label
	        	numInstr = instrProc.sectionGetLastNumInstr();
	        	entryProcThru = this.programCobol.entryProcedure(numInstr);
	        	instrProcThru = (InstructionCobolProcedure) entryProcThru.getInstruction();
	        	
	        	// Section terminata da label + Exit
	        	if (hs_violations.get("R0116_AVOID_NOT_STD_SECTION_THRU_NAME").isRuleEnabled()) {
		        	if (instrProcThru.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
		        		sectionNameThru = instrProcThru.labelGetName();
				       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_SECTION_THRU);
				       	userExitInfo.setActiveSectionName(sectionName);
			        	userExitInfo.setNameToEvaluate(sectionNameThru);
			        	this.userExitGenericActivate(userExitInfo);
			        	if (userExitInfo.getReturnCode() != 0) {
			    	      	insUpdateViolationOnMap("R0116_AVOID_NOT_STD_SECTION_THRU_NAME:", sectionName, entryProc);								// Inserimento/update violazione in map
			    	      	instrProc.getMetricViolations().add(EnumMetricsViolation.R0116_AVOID_NOT_STD_SECTION_THRU_NAME);
			        	}
					}
	        	}
	        	continue;
			}
    		
     		// Label/paragrafo 
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				labelName = instrProc.labelGetName();
				
				// Paragrafo
				if (instrProc.labelIsParagraph()) {
					paragraphName = labelName;
					
		    		// Controllo paragraph name via exit esterna abilitato
					if (hs_violations.get("R0112_AVOID_NOT_STD_PARAGRAPH_NAME").isRuleEnabled()) {
				       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_PARAGRAPH);
			        	userExitInfo.setNameToEvaluate(instrProc.labelGetName());
			        	this.userExitGenericActivate(userExitInfo);
			        	if (userExitInfo.getReturnCode() != 0) {
			    	      	insUpdateViolationOnMap("R0112_AVOID_NOT_STD_PARAGRAPH_NAME:", paragraphName, entryProc);						// Inserimento/update violazione in map
			    	      	instrProc.getMetricViolations().add(EnumMetricsViolation.R0112_AVOID_NOT_STD_PARAGRAPH_NAME);
			        	}
	 				}
					
		        	// Thru paragraph label
		        	numInstr = instrProc.labelGetLastNumInstrParagraph();
		        	entryProcThru = this.programCobol.entryProcedure(numInstr);
		        	instrProcThru = (InstructionCobolProcedure) entryProc.getInstruction();
		        	
		        	// Paragrafo terminato da label + Exit
		        	if (hs_violations.get("R0115_AVOID_NOT_STD_PARAGRAPH_THRU_NAME").isRuleEnabled()) {
			        	if (instrProcThru.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
			        		paragraphNameThru = instrProcThru.labelGetName();
					       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_PARAGRAPH_THRU);
					       	userExitInfo.setActiveParagraphName(paragraphName);
				        	userExitInfo.setNameToEvaluate(paragraphNameThru);
				        	this.userExitGenericActivate(userExitInfo);
				        	if (userExitInfo.getReturnCode() != 0) {
				    	      	insUpdateViolationOnMap("R0115_AVOID_NOT_STD_PARAGRAPH_THRU_NAME:", paragraphNameThru, entryProcThru);								// Inserimento/update violazione in map
				    	      	instrProcThru.getMetricViolations().add(EnumMetricsViolation.R0115_AVOID_NOT_STD_PARAGRAPH_THRU_NAME);
				        	}
						}
		        	}
					continue;
      			} // end-if paragraph
				
	   			// Label non thru di section/paragraph
				
				// Controllo label name via exit esterna abilitato
				if (hs_violations.get("R0113_AVOID_NOT_STD_LABEL_NAME").isRuleEnabled()) {
					instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
					sectionParagraph = this.programCobol.procInternalNameOwner(instrProc.getNumInstr());
					if (!labelName.equals(sectionNameThru) 
					&&  !labelName.equals(paragraphNameThru)) {
				       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_LABEL);
			        	userExitInfo.setNameToEvaluate(labelName);
			        	this.userExitGenericActivate(userExitInfo);
			        	if (userExitInfo.getReturnCode() != 0) {
			    	      	insUpdateViolationOnMap("R0113_AVOID_NOT_STD_LABEL_NAME:", sectionParagraph, entryProc);								// Inserimento/update violazione in map
			    	      	instrProc.getMetricViolations().add(EnumMetricsViolation.R0113_AVOID_NOT_STD_LABEL_NAME);
			        	}
						continue;
					}
				}
				
			} // end-if label/paragraph
			
  		} // end-for instr
 
      	
    	// Controlli sui nomi dei campi definiti
     	if (!hs_violations.get("R0114_AVOID_NOT_STD_FIELD_NAME").isRuleEnabled()) {
         	ar_entryData = this.programCobol.entriesData();

           	// Scan definizioni di data division
        	for (ProgramCobolEntry<? extends Instruction> entryData : ar_entryData) {
        		
        		// Interessano solo le definizioni dei campi
        		if (!(entryData.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
        		
        		instrData = (InstructionCobolDataItem) entryData.getInstruction();
        		
           		// Controllo validità nome campo
    	       	userExitInfo.setUserExitOperation(EnumUserExit.CTRL_NAME_FIELD);
    	       	userExitInfo.setActiveCobolDivision(entryData.getProgramDivision());
    	       	userExitInfo.setActiveCobolSection(entryData.getProgramSection());
    	       	userExitInfo.setNameToEvaluate(instrData.getDataName());
            	this.userExitGenericActivate(userExitInfo);
            	if (userExitInfo.getReturnCode() != 0) {
        	      	insUpdateViolationOnMap("R0114_AVOID_NOT_STD_FIELD_NAME:", "", entryData);					// Inserimento/update violazione in map
         	      	instrData.getMetricViolations().add(EnumMetricsViolation.R0114_AVOID_NOT_STD_FIELD_NAME);
            	}
         	}
     	}
  	}

	/*
	 * ----------------------------------------------------------------------------
	 * Inserimento codici violazioni dovute a sorgente corrotto 
	 * ----------------------------------------------------------------------------
	 * 
	 * Individuazione violazione R0107_AVOID_LABEL_AT_COL_GREATER_8
	 * Individuazione violazione R0106_AVOID_INSTR_START_BEFORE_AREA_A
	 * Individuazione violazione R0104_AVOID_SOURCE_ROW_TABSET
	 * Individuazione violazione R0105_AVOID_UNCLOSED_FIELD_DEF_BY_DOT
	 * Individuazione violazione R0158_AVOID_SQL_WITH_DEPRECATED_SYNTAX
	 */
	private void detectViolationsBadSource(Map<String, EnumMetricsViolation> hs_violations) {
		
		ArrayList<Integer> al_numRow = null;
		
		// Righe shiftate a sinistra a causa di label non a colonna 8 (Cobol MF)
		if (hs_violations.get("R0107_AVOID_LABEL_AT_COL_GREATER_8").isRuleEnabled()) {
			al_numRow = this.programCobol.getNumRowsShiftedLeft();
			for (Integer numRow : al_numRow) {
	   	      	insUpdateViolationOnMapOnlyRow("R0107_AVOID_LABEL_AT_COL_GREATER_8:", "", numRow);	// Inserimento/update violazione in map
			}
		}
		
		// Righe shiftate a destra a causa di istruzioni prima di colonna 8 (Cobol MF)
		// Si può trattare di istruzioni in tutte le divisioni cobol
		if (hs_violations.get("R0106_AVOID_INSTR_START_BEFORE_AREA_A").isRuleEnabled()) {
			al_numRow = this.programCobol.getNumRowsShiftedRight();
			for (Integer numRow : al_numRow) {
		      	insUpdateViolationOnMapOnlyRow("R0106_AVOID_INSTR_START_BEFORE_AREA_A:", "", numRow);	// Inserimento/update violazione in map
			}
		}
		
		// Righe con caratteri di tabulazione
		if (hs_violations.get("R0104_AVOID_SOURCE_ROW_TABSET").isRuleEnabled()) {
			al_numRow = this.programCobol.getNumRowsWithBadChar();
			for (Integer numRow : al_numRow) {
				insUpdateViolationOnMapOnlyRow("R0104_AVOID_SOURCE_ROW_TABSET:", "", numRow);	// Inserimento/update violazione in map
			}
		}
		
		// Righe con istruzioni di definizione dati non terminate da un punto
		// Si tratta di statement di data division
		if (hs_violations.get("R0105_AVOID_UNCLOSED_FIELD_DEF_BY_DOT").isRuleEnabled()) {
			al_numRow = this.programCobol.getNumRowsWithDataUnclosed();
			for (Integer numRow : al_numRow) {
				insUpdateViolationOnMapOnlyRow("R0105_AVOID_UNCLOSED_FIELD_DEF_BY_DOT:", "", numRow);	// Inserimento/update violazione in map
			}
		}
		
		// Righe con istruzioni Sql dalla codifica deprecabile
		if (hs_violations.get("R0158_AVOID_SQL_WITH_DEPRECATED_SYNTAX").isRuleEnabled()) {
			al_numRow = this.programCobol.getNumRowsWithBadCodingSql();
			for (Integer numRow : al_numRow) {
				insUpdateViolationOnMapOnlyRow("R0158_AVOID_SQL_WITH_DEPRECATED_SYNTAX:", "", numRow);			// Inserimento/update violazione in map
			}
		}
	}

	

    /* --------------------------------------------------------------
     * Controllo verifica test status file/Cics/Sql
     * --------------------------------------------------------------
     * 
     * Si può trattare di istruzioni READ/WRITE/REWRITE/DELETE o Exec Cics ...
     * oppure Exec Sql
     * Viene fornito il nome del campo di status da testare
     * 
     * Il check deve essere:
     * 1) Immediatamente dopo l'istruzione sul campo di FILE STATUS/EIBRESP/SQLCODE 
     * 2) la prima istruzione della proc interna  immediatamente richiamata
     *    WRITE ...
     *    PERFORM CTRL-STATUS
     *    ...
     *    ...
     *    CTRL-STATUS.
     *       IF FILE-STATUS = ...
     *       
     *          oppure
     *       
     *       EVALUATE FILE-STATUS
     *         WHEN value
     *          ....
     * 3) Dopo una MOVE subito l'istruzione, su un livello 88
     *    WRITE ..
     *    MOVE FILE-STATUS TO CAMPO con livello 88
     *    IF WITE-OK
     *  
     * L'istruzione e l'entry fornito sono l'istruzione di accesso sotto esame
     * 
     */
	private boolean isStatusFieldChecked(ProgramCobolEntry<? extends Instruction> entryProcToTest, int numInstrToTest, String fieldStatusName) {
		
		ProgramCobolEntry<? extends Instruction> entryProc = null;
		InstructionCobolProcedure instrProc = null;
		InstructionCobolDataItem dataItemFileStatus = null;
		InstructionCics instrCics = null;
		InstructionSql instrSql = null;
		ArrayList<InstructionCobolDataItem> al_dataItemLvl88 = null;
		ArrayList<DataItemCobolIdentifier> al_moveTo = null;
		ArrayList<String> al_fieldNameToTest = null;
		ArrayList<String> al_fieldNameTested = null;
		DataItemCobolIdentifier moveFrom = null;
		InstructionCobolDataItem moveTo = null;
		int i = 0;
		
		// Ultima istruzione del programma
		if (numInstrToTest == this.programCobol.entriesProcedure().length) {
			return false;
		}
		
		al_fieldNameToTest = new ArrayList<String> ();
		al_fieldNameTested = new ArrayList<String> ();
		
		// Individuazione campi di cui verificare l'esistenza di un test dopo il num istruzione fornito
        // Si tratta di:
		//   Campo di status origine
		//   Campi livello 88 direttamente associati al campo di status origine
		//   Campo di prima assegnazione del campo di status origine
		//   Campi livello 88 direttamente associati al campo di prima assegnazione del campo di status origine
		
		// Si verifica l'esistenza di un test esplicito con lo stesso nome di file-status
		al_fieldNameTested.add(fieldStatusName);

		// Estraggo il data item che corrisponde al nome del campo di file-status
		dataItemFileStatus = this.programCobol.dataItemDefinition(fieldStatusName);
		
		// Nel caso di campo di precompilatore (come EIBRESP, SQLCODE, ...) potrebbe non essere disponibile
	    //   al_dataItemLvl88 contiene gli eventuali livelli 88 direttamente associati al campo di status
	    if (dataItemFileStatus != null) {
	    	// Estraggo tutti i nomi di livello 88 associati da testare
			al_dataItemLvl88 = this.programCobol.dataItemsLvl88(dataItemFileStatus);
	    	for (InstructionCobolDataItem dataItemLvl88 : al_dataItemLvl88) {
	    		al_fieldNameToTest.add(dataItemLvl88.getDataName());
			}
		}
		
		// Cerco, nell'ordine,  la prima istruzione If/Evaluate/Perform dopo quella fornita
	    // La ricerca si considera negative se:
	    //   Si incontra un paragrafo, una section, una Exit
	    //   Si stava testando un FILE-STATUS e si incontra una nuova istruzione cobol READ/WRITE/..
	    //   Si stava testando un EIBRESP     e si incontra una nuova istruzione Cics  READ/READNEXT/..
	    //   Si stava testando un SQLCODE     e si incontra una nuova istruzione Sql   SELECT/INSERT(..
		for (i = numInstrToTest + 1; i < this.programCobol.entriesProcedure().length; i++) {
			
			entryProc = this.programCobol.entryProcedure(i);
            
			// Fine ricerca sicuramente negativa
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION
			||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EXIT) {
				i = this.programCobol.entriesProcedure().length;
				break;
			}

			// Paragrafo
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				if (instrProc.labelIsParagraph()) {
					i = this.programCobol.entriesProcedure().length;
					break;
				}
			}
			
			// Nuova istruzione da testare prima di test istruzione cobol corrente
			if (entryProcToTest.getInstruction() instanceof InstructionCobolProcedure && isInstrCobolToTestFileStatus(entryProc.getTypeInstr())) {
				i = this.programCobol.entriesProcedure().length;
				break;
			}
			// Nuova istruzione da testare prima di test istruzione Cics corrente
			if (entryProc.getInstruction() instanceof InstructionCics) {
				instrCics = (InstructionCics) entryProc.getInstruction();
				if (isInstrCicsToTestEibresp(instrCics.getTypeInstrPrecompiler())) {
					i = this.programCobol.entriesProcedure().length;
					break;
				}
			}
			// Nuova istruzione da testare prima di test istruzione Sql corrente
			if (entryProc.getInstruction() instanceof InstructionSql) {
				instrSql = (InstructionSql) entryProc.getInstruction();
				if (isInstrSqlToTestSqlcode(instrSql.getTypeInstrPrecompiler())) {
					i = this.programCobol.entriesProcedure().length;
					break;
				}
			}
			
			// Istruzione di test o perform a eventuale routine di test
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF
			||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE
			||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
				break;
			}
			
			// Move file-status a campo con livello 88
			if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MOVE) {
				instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
				moveFrom = instrProc.moveGetIdentifierFrom();
				// Il check si trasferisce al campo assegnato
				if (moveFrom.getNameIdentifier().equals(fieldStatusName)) {
					al_moveTo = instrProc.moveGetIdentifiersTo();
					// Una singola Move che assegna il campo di status a un altro campo
					if (al_moveTo.size() == 1) {
						moveTo = al_moveTo.get(0).getDataItem();
						al_fieldNameToTest.add(moveTo.getDataName());
				    	// Estraggo tutti i nomi di livello 88 associati da testare
						al_dataItemLvl88 = this.programCobol.dataItemsLvl88(moveTo);
				    	for (InstructionCobolDataItem dataItemLvl88 : al_dataItemLvl88) {
				    		al_fieldNameToTest.add(dataItemLvl88.getDataName());
						}
					}
				}
			}
		}
		
		// Fine programma o nuovo/a paragrafo/section e nessuna espressione condizionale: sicuramente unchecked
		if (i >= this.programCobol.entriesProcedure().length) {
			return false;
		}
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		||  entryProc.getTypeInstr()  == EnumCobolReservedWords.PROC_SECTION) {
			return false;
		}
		
		// Nomi operandi in IF o Evaluate	
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF
		||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE) {
			extractCondizionalOperands(entryProc, al_fieldNameTested);  
		}
		
		// Perform: recupero la prima istruzione in procedura interna (section/paragrafo)
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
			instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
			// Solo se Perform o perform thru
			if (!instrProc.performIsInnerPerform()) {
				numInstrToTest = instrProc.performGetFromNumInstr();
				// Cerco la prima istruzione If/Evaluate
				for (i = numInstrToTest + 1; i < this.programCobol.entriesProcedure().length; i++) {
					entryProc = this.programCobol.entryProcedure(i);
					if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF
					||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE
					||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
					||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
						break;
					}
					// Move file-status a campo con livello 88
					if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_MOVE) {
						instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
						moveFrom = instrProc.moveGetIdentifierFrom();
						// Il check si trasferisce al campo assegnato
						if (moveFrom.getNameIdentifier().equals(fieldStatusName)) {
							al_moveTo = instrProc.moveGetIdentifiersTo();
							// Una singola Move che assegna il campo di status a un altro campo
							if (al_moveTo.size() == 1) {
								moveTo = al_moveTo.get(0).getDataItem();
								al_fieldNameToTest.add(moveTo.getDataName());
						    	// Estraggo tutti i nomi di livello 88 associati da testare
								al_dataItemLvl88 = this.programCobol.dataItemsLvl88(moveTo);
						    	for (InstructionCobolDataItem dataItemLvl88 : al_dataItemLvl88) {
						    		al_fieldNameToTest.add(dataItemLvl88.getDataName());
								}
							}
						}
					}
				}
				// Estrazione operandi da condizione
				if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF
				||  entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE) {
					extractCondizionalOperands(entryProc, al_fieldNameTested);  
				}
			}
		}

		// Verifica se almeno un potenziale campo da testare è stato testato nel posto corretto
		
		// Scan possibili candidati
		for (String fieldNameToTest : al_fieldNameTested) {
			if (al_fieldNameTested.contains(fieldNameToTest)) {
				return true;
			}
		}
		
		// Unchecked.
		// Nessun test diretto, indiretto o su un livello 88
		// nelle istruzioni successive a quella fornita o nella prima
		// perform richiamata
		
		return false;
	}

    /*
     * Accoda gli operandi presenti nella condizione di IF
     * o nell'espressione di Evaluate 
     * 
     */
    private void extractCondizionalOperands(ProgramCobolEntry<? extends Instruction> entryProc, ArrayList<String> al_fieldNameTested) {

		InstructionCobolProcedure instrProc = null;
		ExpressionCobolElement exprElementEvaluate = null;
		ArrayList<ExpressionCobol> al_expr = null;
		ExpressionCobol expr = null;
  	
		// IF : estrazione nomi operandi nella condizione
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_IF) {
			instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
			expr = instrProc.ifGetCondition();
			// Scan elementi espressione
			for (ExpressionCobolElement exprElement : expr.getElements()) {
				
				// Interessano solo gli operandi NON literal
				if (!exprElement.isOperand()
				||   exprElement.getDataItemIdentifier().getQualifier().getSymbolType() == EnumSymbolType.SQL_SYMBOL_LITERAL_ALPHA
				||   exprElement.getDataItemIdentifier().getQualifier().getSymbolType() == EnumSymbolType.SQL_SYMBOL_LITERAL_NUM) {
					continue;
				}
				
				// Si evitano i doppioni
				if (al_fieldNameTested.contains(exprElement.getDataItemIdentifier().getNameIdentifier())) {
					continue;
				}
				al_fieldNameTested.add(exprElement.getDataItemIdentifier().getNameIdentifier());
			}
		}
		
		// EVALUATE: estrazione nomi operandi nell'espressione da valutare
		if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_EVALUATE) {
			instrProc = (InstructionCobolProcedure) entryProc.getInstruction();
			al_expr = instrProc.evaluateGetExpressions();
			// Ci deve essere una sola espressione, non deve essere codificata la clausola ALSO 
			if (al_expr.size() == 1) {
				// Deve essere codificato un solo campo da valutare, ovvero il campo di status o una sua assegnazione diretta
				expr = al_expr.get(0);
				if (expr.getElements().length == 1) {
					exprElementEvaluate = expr.getElements()[0];
					// Deve essere un operando 
					if (exprElementEvaluate.isOperand()) {
						al_fieldNameTested.add(exprElementEvaluate.getDataItemIdentifier().getNameIdentifier()); 
					}
				}
			}
		}

    	return;
	}


    
	/* -----------------------------------------------------------------------
	 * Inserimento/update violazione in map riferita a numero istruzione
	 * -----------------------------------------------------------------------
	 * 
	 * Viene fornito l'entry contenente l'istruzione con violazione
	 * Viene fornita la violazione terminata con :
	 * Viene fornita la section/paragrafo eventuale
	 * Viene creato l'entry della map se non esiste
	 * Viene accodato il numero di istruzione fornito
	 * Viene accodato il numero di riga sorgente relativo all'istruzione
	 * 
	 */
    private void insUpdateViolationOnMap(String violation, String sectionParagraphName, ProgramCobolEntry<? extends Instruction> entry) {
    	
       	ProgramCobolEntry<? extends Instruction> ar_entry[] = null;
       	ProgramCobolEntry<? extends Instruction> entryLoop = null;
        Instruction instrGeneric = null;
        Instruction instrProc = null;
        InstructionSql instrSql = null; 
        InstructionCics instrCics = null; 
        InstructionCobolEnvironment instrEnv = null; 
        InstructionCobol instrId = null; 
        InstructionCobolDataItem instrDataItem = null; 
        
        
    	String mapViolationData = "";
       	String numRow = "";
       	String numRowUnderCopy = "";
    	int numInstr = 0;
    	int numRowNotUnderCopy = 0;
    	
    	if (entry.getInstruction() instanceof InstructionCics) {
    		instrCics = (InstructionCics) entry.getInstruction();
         	numInstr = instrCics.getNumInstr();
        	numRow = instrCics.getRowStartSource()+"";
		} else if (entry.getInstruction() instanceof InstructionSql) {
    		instrSql = (InstructionSql) entry.getInstruction();
         	numInstr = instrSql.getNumInstr();
        	numRow = instrSql.getRowStartSource()+"";
		} else if (entry.getTypeInstr() == EnumCobolReservedWords.ID_DIVISION) {
			instrId = (InstructionCobol) entry.getInstruction();
         	numInstr = 0;
        	numRow = instrId.getRowStartSource()+"";
		} else if (entry.getInstruction() instanceof InstructionCobolEnvironment) {
			instrEnv = (InstructionCobolEnvironment) entry.getInstruction();
         	numInstr = instrEnv.getNumInstr();
        	numRow = instrEnv.getRowStartSource()+"";
		} else if (entry.getInstruction() instanceof InstructionCobolDataItem) {
			instrDataItem = (InstructionCobolDataItem) entry.getInstruction();
         	numInstr = instrDataItem.getNumInstr();
        	numRow = instrDataItem.getRowStartSource()+"";
		} else {
			instrProc = (InstructionCobol) entry.getInstruction();
	     	numInstr = instrProc.getNumInstr();
	    	numRow = instrProc.getRowStartSource()+"";
		}
    	
    	// Istruzione sotto copy: il numero di riga deve essere quello dello statement copy
    	numRowUnderCopy = "-1";
    	if (entry.isUnderCopy()) {
    		instrGeneric = entry.getInstruction();
    		numRowUnderCopy = instrGeneric.getRowStartSource()+"";
			if (entry.getProgramDivision() == EnumCobolReservedWords.ID_DIVISION) {
				ar_entry = this.programCobol.entriesIdentification();
			} else if (entry.getProgramDivision() == EnumCobolReservedWords.ENV_DIVISION) {
				ar_entry = this.programCobol.entriesEnvironment();
			} else if (entry.getProgramDivision() == EnumCobolReservedWords.DATA_DIVISION) {
				ar_entry = this.programCobol.entriesData();
			} else if (entry.getProgramDivision() == EnumCobolReservedWords.PROC_DIVISION) {
				ar_entry = this.programCobol.entriesProcedure();
			}
			// Cerco all'indietro il primo statement NON sotto copy
			numRowNotUnderCopy = 0;
			for (int i = numInstr - 1;i >= 0; i--) {
				entryLoop = ar_entry[i];
				if (entryLoop.isUnderCopy()) {continue;}
				instrProc = entryLoop.getInstruction();
				numRowNotUnderCopy = instrProc.getRowStartSource();
				break;
			}
			// Numero riga nel sorgente copy originale
			numRow = numRowNotUnderCopy+"";
		}
    	
    	
    	// Inserimento/update violazione in map (numero istruzione)
    	if (map_metricViolation.get(violation + sectionParagraphName) == null) {map_metricViolation.put(violation + sectionParagraphName, "");} 
    	mapViolationData = map_metricViolation.get(violation + sectionParagraphName);
    	map_metricViolation.put(violation + sectionParagraphName, mapViolationData + " " + numInstr);
    	if (violation.equals("R0026_AVOID_LABEL_UNREFERENCED:") && sectionParagraphName.equals("")) {
    	   	mapViolationData = map_metricViolation.get("R0026_AVOID_LABEL_UNREFERENCED:");
		}
    	
    	
    	// Inserimento/update violazione in map (numero riga)
    	if (map_metricViolationRow.get(violation + sectionParagraphName) == null) {map_metricViolationRow.put(violation + sectionParagraphName, "");} 
    	mapViolationData = map_metricViolationRow.get(violation + sectionParagraphName);
    	map_metricViolationRow.put(violation + sectionParagraphName, mapViolationData + " " + numRow);
    	
    	// Inserimento/update violazione in map (numero riga dentro copy)
    	if (map_metricViolationRowCopy.get(violation + sectionParagraphName) == null) {map_metricViolationRowCopy.put(violation + sectionParagraphName, "");} 
    	mapViolationData = map_metricViolationRowCopy.get(violation + sectionParagraphName);
    	map_metricViolationRowCopy.put(violation + sectionParagraphName, mapViolationData + " " + numRowUnderCopy);
    	
    	// Se non esistono creo entry map per value
     	if (map_metricViolationValue.get(violation + sectionParagraphName) == null) {map_metricViolationValue.put(violation + sectionParagraphName, "");} 
	}

	/* -----------------------------------------------------------------------
	 * Inserimento/update violazione in map riferita a numero riga
	 * -----------------------------------------------------------------------
	 * 
	 * Viene fornita la violazione terminata con :
	 * Viene fornita la section/paragrafo eventuale
	 * Viene creato l'entry della map se non esiste
	 * Viene accodato il numero di istruzione fornito
	 * Viene accodato il numero di riga sorgente relativo all'istruzione
	 * 
	 */
    private void insUpdateViolationOnMapOnlyRow(String violation, String sectionParagraphName, int numRow) {
    	
     	String mapViolationData = "";
 
    	// Inserimento/update violazione in map (numero riga)
    	if (map_metricViolationRow.get(violation + sectionParagraphName) == null) {map_metricViolationRow.put(violation + sectionParagraphName, "");} 
    	mapViolationData = map_metricViolationRow.get(violation + sectionParagraphName);
    	map_metricViolationRow.put(violation + sectionParagraphName, mapViolationData + " " + numRow);
    	
    	// Se non esistono creo entry map per numero istruzione e value
    	if (map_metricViolation.get(violation + sectionParagraphName) == null) {map_metricViolation.put(violation + sectionParagraphName, "");} 
    	if (map_metricViolationValue.get(violation + sectionParagraphName) == null) {map_metricViolationValue.put(violation + sectionParagraphName, "");} 
	}

	/* -----------------------------------------------------------------------
	 * Inserimento/update valore violazione in map
	 * -----------------------------------------------------------------------
	 * 
	 * Viene fornito il valore della violazione (per esempio valore di soglia)
	 * Viene fornita la section/paragrafo eventuale
	 * Viene creato l'entry della map se non esiste
	 * Viene accodato il valore 
	 * 
	 */
    private void insUpdateViolationValueOnMap(String violation,  String sectionParagraphName, String value) {
    	
     	String mapViolationData = "";
       	
    	// Inserimento/update violazione in map (numero istruzione)
    	if (map_metricViolationValue.get(violation + sectionParagraphName) == null) {map_metricViolationValue.put(violation + sectionParagraphName, "");} 
    	mapViolationData = map_metricViolationValue.get(violation + sectionParagraphName);
    	map_metricViolationValue.put(violation + sectionParagraphName, mapViolationData + " " + value);
    	
 	}


	/*

	// Maintenability
	MN001_SHARED_FAN_IN(EnumMetricsViolationSeverity.C_MAJOR),                       	// Programmi chiamanti > soglia
	MN002_SHARED_FAN_OUT(EnumMetricsViolationSeverity.C_MAJOR),                      	// Programmi chiamati  > soglia
	
	// Performances
 	PE008_COBOL_CALL_DYNAMIC_LARGE_PGM_IN_LOOP(EnumMetricsViolationSeverity.C_MAJOR),	// Programma Cobol grande richiamato dinamicamente in un loop
	 * 
	 */
	
	/**  
	 * Calcolo metriche supplementari a livello di programma<br>
     * <p>
     *  
     * Si calcolano solo le metriche abilitate nel pilot di esecuzione
     * 
     */
	public void metricsMeasurePgmAddOn() throws ExceptionAmrita, SQLException {
		
		// Metriche di complessità strutturale
		if (di.optMetricsAll || di.optMetricsComplexityStructure) {
			this.metricsProgram.evaluateMeasuresComplexityStructure();  
		}
		// Metriche di complessità funzionale generica
		if (di.optMetricsAll || di.optMetricsComplexityFunction) {
			this.metricsProgram.evaluateMeasuresComplexityFunction();  
		}
		// Metriche di function point
		if (di.optMetricsAll || di.optMetricsFunctionPoint) {
			this.metricsProgram.evaluateMeasuresFunctionPoint();  
			this.metricsProgram.computeIdxFP();
		}
		// Metriche di rehosting 
		if (di.optMetricsAll || di.optMetricsRehosting) {
			this.metricsProgram.evaluateMeasuresRehosting();  
			this.metricsProgram.computeIdxRH();
		}

	}


	/**  
	 * Memorizzazione metriche nelle strutture db per aggiornamento finale.<br>
	 *<p>
	 * Si tratta delle metriche generali di programma<br>
	 * di quelle di dettaglio di ogni sezione e le violazioni<br>
	 * <p>
	 * 
	 */
    public void storeMetricsOnDbStructure(boolean isMetricsProgramToStore, boolean isMetricsProgramDetailToStore) {

    	EntityMetricValue entityMetric = null;
    	
    	// Metriche generali di programma  
    	if (isMetricsProgramToStore) {
    		entityMetric = new EntityMetricValue();  
           	this.entityMetricProgram = entityMetric;								// X update info violazioni successivamente
           	// Oggetto per inserimento su db
         	metricsProgram.setSystem(this.di.systemInput);
         	metricsProgram.setSubSystem(this.di.subSystemInput);
        	metricsProgram.dbPopulateMetric(entityMetric);
        	this.analyzerDbInfo.addObjMetric(entityMetric); 						// Inserimento in tabella metriche programma per update db finale
		}
		
    	// Metriche mainline del programma
        // Metriche section/paragrafi richiamati
    	if (isMetricsProgramDetailToStore) {
    		// Mainline
          	entityMetric = new EntityMetricValue();          							// Oggetto per inserimento su db
           	metricsProgramMainline.setSystem(this.di.systemInput);
         	metricsProgramMainline.setSubSystem(this.di.subSystemInput);
         	metricsProgramMainline.dbPopulateMetric(entityMetric);
        	this.analyzerDbInfo.addObjMetric(entityMetric); 						// Inserimento in tabella metriche programma per update db finale
        	// Section/Paragrafu
        	for (Metrics metricsSection : this.al_metricsProgramSection) {
        		metricsSection.setSystem(this.di.systemInput);
        		metricsSection.setSubSystem(this.di.subSystemInput);
               	entityMetric = new EntityMetricValue();          						// Oggetto per inserimento su db
              	metricsSection.dbPopulateMetric(entityMetric);
            	this.analyzerDbInfo.addObjMetric(entityMetric); 					// Inserimento in tabella metriche programma per update db finale
    		}
		}
    
    }

    /**
     * Impostazioni necessarie a fronte di esecuzione PROCESS_PGM_LEVEL.<br>
     * <p>
     * Vengono restorate le map dei GoTo e delle labelSection<br> 
	 * necessarie per la generazione del grafo di programma come processo<br>
	 * a livello di programma post analisi.<br>
	 * Queste map sono memorizzate nel descrittore del programma {@link ProgramCobol}<br>
	 * a fine analisi del programma<br>
     * <p>
     * Vengono inoltre riallocati gli oggetti {@link Metrics} a livello programma, <br>
     * mainline e singole section/paragrafi.<br>
     * <p>
     */
	public void setForProcessPgmLevel() {
		
		this.map_GoTo = programCobol.getAnalysisMapGoTo();
		this.map_LabelSection = programCobol.getAnalysisMapLabelSection();
		
		allocateForMetrics();
		this.al_metricsProgramSection = new ArrayList<Metrics> ();
		
        // Per cumulare gli aggiornamenti per violazione da aggiornare a fine elaborazione (stessa key)
		if (this.di.optMetricsSqualeDetectViolation) {
		    this.map_metricViolation = new HashMap<String, String> ();
		    this.map_metricViolationRow = new HashMap<String, String> ();
		    this.map_metricViolationRowCopy = new HashMap<String, String> ();
		    this.map_metricViolationValue = new HashMap<String, String> ();
		}

		// Richiesto calcolo metriche di dettaglio mainline/section
		if (this.di.optMetricsDetail) {
			this.programCobol.getMetricsProgramSections().clear(); 
		}

	}




	/*
     * -------------------------------------------------------------------------
     * Analisi copy in data division e marcatura se non utilizzati.
     * Verifica se copy CICS_MAPSET e in questo caso recuperoCics mapName e inserimento relazioni
	 *   PGM_CICS_MAP,                  		// 064  MAP
	 *   PGM_CICS_MAPSET                		// 065  MAPSET
     * -------------------------------------------------------------------------
     * 
     * Si Verifica che almeno un campo di copy sia utilizzato 
     * Si marca l'entry copy dead code se nessun campo è utilizzzato
     * Si aggiorna il descrittore programma con il nome del copy
     * Si aggiorna il descrittore programma con il nome del copy dead code 
     * Si inserisce la relazione PGM_COPY_UNUSED 
     * Si inserisce l'opzione PGM_WITH_COPY_UNUSED
     * 
     */
	@SuppressWarnings("unchecked")
	private void finalPgmDataDeadCodeCopy() throws ExceptionAmrita, SQLException {
		
		Map<String, Object[]> map_Copy = null;     // Coppie nome copy/true se campi utilizzati
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		ProgramCobolEntry<? extends Instruction> entryCopy = null;
		InstructionCobol instrCopy = null;
		InstructionSql instrSqlInclude = null;
		InstructionCobolDataItem dataItemCobol = null;
		Object ar_infoCopy[] = null;
		String copyName = "";
		String mapName = "";
		String mapsetName = "";
		boolean isCopyUsed = false;
		int i;
		
		// Solo se opzione dead code abilitata
		if (!di.optDetectDeadCode) {
			return;
		}
		
		// Struttura di controllo e inizializzazione
		// Questo metodo può essere richiamato post analisi dai processi a livello di programma
		map_Copy = new HashMap<String, Object[]>();
		this.programCobol.deadCodeCopyData().clear();
		
		// Ciclo generale di analisi data division
		ar_entryDataDivision = this.programCobol.entriesData();
		for (i = 0; i < ar_entryDataDivision.length; i++) {
			
			entryDataDivision = ar_entryDataDivision[i];
			
		    // Copy: creo entry in map
		    if (entryDataDivision.getInstruction() instanceof InstructionCobol
		    &&  entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
		    	instrCopy = (InstructionCobol) entryDataDivision.getInstruction();
		    	copyName = instrCopy.copyGetName();
				ar_infoCopy = new Object[2];
				ar_infoCopy[0] = entryDataDivision;
				ar_infoCopy[1] = false;					// Default copy con tutti i campi NON utilizzati
				map_Copy.put(copyName, ar_infoCopy);
                continue;
			}
		    // Sql Include: creo entry in map
		    if (entryDataDivision.getInstruction() instanceof InstructionSql) {
		    	instrSqlInclude = (InstructionSql) entryDataDivision.getInstruction();
		    	if (instrSqlInclude.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
			    	copyName = instrSqlInclude.sqlIncludeGetName();
					ar_infoCopy = new Object[2];
					ar_infoCopy[0] = entryDataDivision;
					ar_infoCopy[1] = false;					// Default copy con tutti i campi NON utilizzati
					map_Copy.put(copyName, ar_infoCopy);
	                continue;
				}
			}
			
			// Data item NON sotto copy: skip
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
			if (! entryDataDivision.isUnderCopy()) {continue;}
			
		    // Data item NON referenziato
			dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
		    if (!programCobol.isDataItemUsedByAnyProcInstr(dataItemCobol.getDataName(), INSTR_USE_DATA_ITEM_INPUT)
		    &&  !programCobol.isDataItemUsedByAnyProcInstr(dataItemCobol.getDataName(), INSTR_USE_DATA_ITEM_OUTPUT)) {
		    	continue;
			}
		    
		    // Data referenziato: il copy NON è dead code
		    ar_infoCopy[1] = true;	
		    
 					
		} // end-for
		
		
		// Scan copy incontrati
		for (Entry<String, Object[]> copyEntry : map_Copy.entrySet()) {
			
			copyName = copyEntry.getKey();
					
			ar_infoCopy = copyEntry.getValue();
			entryCopy = (ProgramCobolEntry<? extends Instruction>) ar_infoCopy[0];
			isCopyUsed =  (Boolean) ar_infoCopy[1];
			
			// Inserisco nome copy in struttura pgm
			this.programCobol.getCopyNamesData().add(copyName);
			
			// Copy con campi utilizzati: skip
			if (isCopyUsed) {
				continue;
			}
			
			// E' un copy dead code: mark istruzione dead code
			entryCopy.setDeadCode(true);
			
			// Inserisco nel descrittore del programma il copy dead code
			this.programCobol.deadCodeCopyData().add(copyEntry.getKey());
						
			// Nessun campo del copy utilizzato: inserimento opzione programma
			EntityObjectOption entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_COPY_UNUSED);
			analyzerDbInfo.addObjEntityOption(entityObjectOption);
			 
			// Relazione pgm_copy_unused
            this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
											        			EnumObject.OBJECT_PGM_COBOL
															  , this.pgmNameUnderParsing
															  , EnumObject.OBJECT_COPY_COBOL_DATA
														  	  , copyName
															  , EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS
															  , EnumRelation.PGM_COPY_UNUSED
															  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
															  , this.pgmNameUnderParsing
															  , entryCopy.getInstruction().getNumInstr()
															  , entryCopy.getInstruction().getRowStartSource()
															  , entryCopy.getInstruction().getRowEndSource()
															  , ""
															  , 0
															  , 0
															  , entryCopy.getInstruction().getTypeInstrCategory()
															  , entryCopy.getProgramDivision()
															  , false
															  , false
															  , false
															  , this.di.userExitInfoPgm
															   );
		}
	}



	
	/* ------------------------------------------------------------
     * Update descrittore programma con righe inizio/fine divisioni
     * ------------------------------------------------------------
     * 
     * Necessario per le violazioni rilevate in fase di normalizzazione sorgente
     * prima di effettuare l'analisi con i numeri di istruzione.
     * 
     */
	private void finalPgmSetDivisionsRowsStartEnd() {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entry = null;
		ProgramCobolEntry<? extends Instruction> entry = null;
		
		// Identification
		ar_entry = this.programCobol.entriesIdentification();
		if (ar_entry.length > 0) {
			entry = ar_entry[0];
			this.programCobol.setNumRowStartIdentification(entry.getInstruction().getRowStartSource());
			entry = ar_entry[ar_entry.length - 1];
			this.programCobol.setNumRowEndIdentification(entry.getInstruction().getRowEndSource());
		}
		
		// Environment
		ar_entry = this.programCobol.entriesEnvironment();
		if (ar_entry.length > 0) {
			entry = ar_entry[0];
			this.programCobol.setNumRowStartEnvironment(entry.getInstruction().getRowStartSource());
			entry = ar_entry[ar_entry.length - 1];
			this.programCobol.setNumRowEndEnvironment(entry.getInstruction().getRowEndSource());
		}
		
		// Data
		ar_entry = this.programCobol.entriesData();
		if (ar_entry.length > 0) {
			entry = ar_entry[0];
			this.programCobol.setNumRowStartData(entry.getInstruction().getRowStartSource());
			entry = ar_entry[ar_entry.length - 1];
			this.programCobol.setNumRowEndData(entry.getInstruction().getRowEndSource());
		}
		
		// Procedure
		ar_entry = this.programCobol.entriesProcedure();
		if (ar_entry.length > 0) {
			entry = ar_entry[0];
			this.programCobol.setNumRowStartProc(entry.getInstruction().getRowStartSource());
			entry = ar_entry[ar_entry.length - 1];
			this.programCobol.setNumRowEndProc(entry.getInstruction().getRowEndSource());
		}
		
	}
		

    /* ------------------------------------------------------------
     * Aggiornamento lunghezza in bytes definizione di ogni gruppo.
     * ------------------------------------------------------------
     * 
     * Vengono inoltre aggiornate le lunghezza dei campi con occurs
     * a 1 o più dimensioni.
     * Per ogni campo viene aggiornata anche la posizione (0-based)
     * nel livello 01 di appartenenza. La posizione è memorizzata
     * nell'entry di programma che contiene l0istruzione di definizione.
     * 
     */
	private void finalPgmDataComputeGroupsLengthAndPos() {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		InstructionCobolDataItem dataItemCobol = null;
		int i;
		int lngBytesLevel01 = 0;
		
		InnerGroupSize igs = new InnerGroupSize();
		ar_entryDataDivision = this.programCobol.entriesData();
		
		// Ciclo generale di analisi data division ed estrazione insiemi di livelli 01
		for (i = 0; i < ar_entryDataDivision.length; i++) {
              
			// Ricerca livello 01 di gruppo
			for (; i < ar_entryDataDivision.length; i++) {
				entryDataDivision = ar_entryDataDivision[i];
				if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
				dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
				if (dataItemCobol.getLevelNumber()!= 1) {continue;}
				if (dataItemCobol.isGroupField()) {break;}
			}
		    // Fine processo
			if (i >= ar_entryDataDivision.length) {
				break;
			}
			
			igs.iStartLvl01 = i;
			
			// Ricerca successivo livello 01 di gruppo o fine gruppo o nuova Section/Division
			for (i = igs.iStartLvl01 + 1; i < ar_entryDataDivision.length; i++) {
				entryDataDivision = ar_entryDataDivision[i];
				if (entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
				||	entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_WS_SECTION
				||	entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DATA_DIV_REPORT_SECTION
				||	entryDataDivision.getTypeInstr() == EnumCobolReservedWords.PROC_DIVISION) {
					break;
				}
				if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
				dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
				if (dataItemCobol.getLevelNumber()!= 1) {continue;}
				break;
			}
			
			igs.iEndLvl01 = i - 1;
			
		    // Fine definizioni: prendo l'ultima
			if (i >= ar_entryDataDivision.length) {
				igs.iEndLvl01 = ar_entryDataDivision.length - 1;
			}
			
			// Attivazione ricorsiva
			lngBytesLevel01 = updateGroupsLengthRecursive(igs, igs.iStartLvl01 + 1, false, 0);		
			
			// Update con dimensioni in byrtes
			dataItemCobol = (InstructionCobolDataItem) ar_entryDataDivision[igs.iStartLvl01].getInstruction();
			dataItemCobol.setSizeBytes(lngBytesLevel01);
			
			// Aggiornamento posizione per ogni campo definito nel gruppo a livello 01
			igs.iPosStart = igs.iStartLvl01;
			igs.iPosEnd = igs.iEndLvl01;
			igs.curPosField = 0;
			updateDataItemPosRecursive(igs);	
			
			i = igs.iEndLvl01;
			
		} // end-for

	}
    
	
	/**
	 * Impostazione misure metriche di base a livello di programma<br>
	 * <p>
	 * Questo metodo viene richiamato a fine analisi programma o a fronte<br>
	 * di PROCESS_PGM_LEVEL.<br>
	 * <p>
	 * Le metriche dimensionali sui commenti e linee di codice<br>
	 * logiche, sono gà state caricate al momento della lettura <br>
	 * del sorgente.<br>
	 * <p>
	 * 
	 * Questo metodo EFFETTUA il conteggio delle misure dimensionali<br>
	 * dei sorgenti per quanto riguarda:<br>
	 * <p>
	 * 
	 * 1) Righe commento<br>
	 * 1) Righe a blank<br>
	 * 1) Campi definiti<br>
	 * 2) Campi definiti in moduli copy<br>
	 * 2) Literal <br>
	 * <p>
	 * 
	 * Inoltre vengono conteggiate le seguenti informazioni<br>
	 * di codice morto:<br>
	 * <p>
	 * 
	 * 1) Campi definiti e non referenziati<br>
	 * 2) Istruzioni non eseguibili o non referenziate<br>
	 * 3) Copy definito senza campi referenziati<br>
	 * <p>
	 * 
	 */
	public void metricsMeasurePgmDimensionalDataBasic() {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision = null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		Instruction instruction = null;
		Set<Entry<String, Object[]>> set_symbols = null;
	    EnumSymbolType symbolType = null;	
	    Object[] ar_object = null;
	    
	    // Contatori misure
	    long cntLinesBlank = 0;
	    long cntLinesBlankData = 0;
	    long cntLinesComment = 0;
	    long cntLinesCommentData = 0;
	    long cntLinesCodeLogical = 0;
	    long cntDefFields = 0;
	    long cntDefFieldsInCopy = 0;
	    long cntDefLiterals = 0;
	    long cntDeadFields = 0;
	    long cntDeadCopyData = 0;
	    
	    // Metriche disabilitate
	    if (!this.di.optMetricsAll && !this.di.optMetricsBasic) {
			return;
		}
	    

		// Metriche definizione campi e dead code
		ar_entryDataDivision = this.programCobol.entriesData();
		
		// Copy dead code già memorizzati in descrittore programma
		cntDeadCopyData = this.programCobol.deadCodeCopyData().size();
		
		
		// Scan campi definiti
		for (int i = 0; i < ar_entryDataDivision.length; i++) {
			
			entryDataDivision = ar_entryDataDivision[i];
			instruction = entryDataDivision.getInstruction();
			
			// Scan righe commento o a blank prima dell'istruzione
			for (String rowBefore : instruction.getCommentsBefore()) {
				
				// Riga vuota: conteggio misura
				if (rowBefore.trim().equals("")) {
					cntLinesBlank++;
					cntLinesBlankData++;
					continue;
				}
				
				// E' un commento: conteggio misura
				cntLinesComment++;
				cntLinesCommentData++;
				
			}

			
			// Interessano solo le definizioni dati
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
			
			cntDefFields++;
			
			// Dentro copy
			if (entryDataDivision.isUnderCopy()) {
				cntDefFieldsInCopy++;
			}
			
			// Dead code: campo non referenziato
			if (entryDataDivision.isDeadCode()) {
				cntDeadFields++;
				continue;
			}
		}

		
		// Literals
		
		set_symbols = this.programCobol.getMapSymbols().entrySet();
		
		// Scan simboli
		for (Entry<String, Object[]> entry_symbol : set_symbols) {
			ar_object = entry_symbol.getValue();
			symbolType = (EnumSymbolType) ar_object[0];
			// Conteggio literal
			if (symbolType == EnumSymbolType.COBOL_SYMBOL_LITERAL_ALPHA
			||  symbolType == EnumSymbolType.COBOL_SYMBOL_LITERAL_NUM) {
				cntDefLiterals++;
			}
		}
	
		// Update misure dimensionali
		this.metricsProgram.setSizeLinesBlank(cntLinesBlank);
		this.metricsProgram.setSizeLinesBlankData(cntLinesBlankData);
		this.metricsProgram.setSizeLinesComment(cntLinesComment);
		this.metricsProgram.setSizeLinesCommentData(cntLinesCommentData);
		this.metricsProgram.setSizeLinesCodeLogical(cntLinesCodeLogical);	 				// # Righe logiche LLOC
		this.metricsProgram.setSizeLinesCodePhisical(this.programCobol.getSizeSource());	// # Righe fisiche SLOC
		
		// Update misure metriche dead code
		this.metricsProgram.setDefFields(cntDefFields);  									// Campi definiti
		this.metricsProgram.setDefFieldsInCopy(cntDefFieldsInCopy);							// Campi definiti dentro copy
		this.metricsProgram.setDefLiterals(cntDefLiterals);  		    					// Literals 
		this.metricsProgram.setDeadFields(cntDeadFields);  									// Dead code Campi non referenziati
		this.metricsProgram.setDeadCopyData(cntDeadCopyData);  		    					// Dead code Copy con tutti campi non referenziati

		// Calcolo indici di documentazione
        this.metricsProgram.computeIdxDoc();                								// Calcolo indici di documentazione

 	}

	
	/**
	 * Impostazione misure dimensionali di base a livello di programma/sezione di programma<br>
	 * <p>
	 * Questo metodo viene chiamato a fine analisi programma<br>
	 * e a fronte di PROCESS_PGM_LEVEL<br>
	 * <p>
	 * Viene fornito il numero di istruzione di inizio e di fine.<br>
	 * Si può trattare di tutto il programma o di un paragrafo/section.<br>
	 * Le metriche sono memorizzate nell'oggetto metrics fornito.<br>
	 * <p>
	 * Le metriche dimensionali sui commenti e linee di codice<br>
	 * logiche, sono gà state caricate al momento della lettura <br>
	 * del sorgente.<br>
	 * <p>
	 * Questo metodo EFFETTUA il conteggio delle misure dimensionali<br>
	 * dei sorgenti per quanto riguarda:<br>
	 * <p>
	 * 1) Righe commento<br>
	 * 1) Righe a blank<br>
	 * 1) Campi definiti<br>
	 * 2) Campi definiti in moduli copy<br>
	 * <p>
	 * Inoltre vengono conteggiate le seguenti informazioni<br>
	 * di codice morto:<br>
	 * <p>
	 * 2) Istruzioni non eseguibili o non referenziate<br>
	 * 3) Copy definito non referenziati<br>
	 * <p>
	 */
	public void metricsMeasurePgmDimensionalProcBasic(Metrics metricsObject, int iProcStart, int iProcEnd) {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryProcDivision = null;
		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
		Instruction instruction = null;
	    
	    // Contatori misure
	    long cntLinesBlank = 0;
	    long cntLinesBlankProc = 0;
	    long cntLinesComment = 0;
	    long cntLinesCommentProc = 0;
	    long cntLinesCodeLogical = 0;
	    long cntLinesCodePhisical = 0;
	    long cntInstrProc = 0;
	    long cntDeadInstr = 0;
	    long cntDeadLabel = 0;
	    long cntDeadCopyProc = 0;
	    long cntDynamicInstr = 0;
	    long cntDynamicInstrLight = 0;
	    
	    // Di servizio
	    int iStartRow = 0;
	    int iEndRow = 0;

	    
	    // Metriche disabilitate
	    if (!this.di.optMetricsAll && !this.di.optMetricsBasic) {
			return;
		}
	    

	    ar_entryProcDivision = this.programCobol.entriesProcedure();
	    
	    // Calcolo linee di codice fisiche a livello di programma
	    if (iProcStart == 0 && iProcEnd == ar_entryProcDivision.length - 1) {
	    	cntLinesCodePhisical = this.programCobol.getSizeSource();
	    	cntInstrProc = this.programCobol.entriesProcedure().length;
	    	
	    // Calcolo linee di codice fisiche a livello di sezione del programma	
		} else {
			entryProcDivision = ar_entryProcDivision[iProcStart];
			instruction = entryProcDivision.getInstruction();
			iStartRow = instruction.getRowStartSource() - instruction.getCommentsBefore().length;
			entryProcDivision = ar_entryProcDivision[iProcEnd];
			instruction = entryProcDivision.getInstruction();
			iEndRow = instruction.getRowEndSource();
			cntLinesCodePhisical = iEndRow - iStartRow + 1;
			cntInstrProc = iProcEnd - iProcStart + 1;
		}
		
		// Scan istruzioni definite
		for (int i = iProcStart; i <= iProcEnd; i++) {
			
			entryProcDivision = ar_entryProcDivision[i];
			instruction = entryProcDivision.getInstruction();
			
			// Numero righe logiche istruzione
			cntLinesCodeLogical = cntLinesCodeLogical + instruction.getRowsSource().length;
			
			// Scan righe commento o a blank prima dell'istruzione
			for (String rowBefore : instruction.getCommentsBefore()) {
				
				// Riga vuota: conteggio misura
				if (isRowCobolEmpty(rowBefore)) {
					cntLinesBlank++;
					cntLinesBlankProc++;
					continue;
				}
				 
				// E' un commento: conteggio misura
				if (isCobolRowComm(rowBefore)) {
					cntLinesComment++;
					cntLinesCommentProc++;
				}
			}	
			
			// Dead code: istruzione non referenziata o non raggiungibile
			if (entryProcDivision.isDeadCode()) {
				cntDeadInstr++;
				// Label non referenziata
				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
					cntDeadLabel++;
				}
				continue;
			}
			
			// Codice dinamico
			if (instruction.isDynamic()) {
				cntDynamicInstr++;
				if (instruction.isDynamicLight()) {
					cntDynamicInstrLight++;
				}
			}
			
		}

		// Update misure dimensionali procedure
		metricsObject.setSizeLinesBlank(cntLinesBlank);
		metricsObject.setSizeLinesBlankProc(cntLinesBlankProc);
		metricsObject.setSizeLinesComment(cntLinesComment);
		metricsObject.setSizeLinesCommentProc(cntLinesCommentProc);
		metricsObject.setSizeLinesCodeLogical(cntLinesCodeLogical);	 					// # Righe logiche LLOC
		metricsObject.setSizeLinesCodePhisical(cntLinesCodePhisical);	 				// # Righe fisiche SLOC
		metricsObject.setSizeInstr(cntInstrProc);   									// # Istruzioni
		
		// Se attivazione per il programma complessivo utilizzo le misure dimensionali già calcolate
		if (metricsObject == this.metricsProgram) {
			metricsObject.setSizeLinesBlank(this.programCobol.getSizeSourceBlank());
			metricsObject.setSizeLinesBlankProc(this.programCobol.getSizeSourceProcBlank());
			metricsObject.setSizeLinesComment(this.programCobol.getSizeComm());
			metricsObject.setSizeLinesCommentProc(this.programCobol.getSizeCommProc());
			metricsObject.setSizeLinesCodeLogical(cntLinesCodeLogical);	 					// # Righe logiche LLOC
			metricsObject.setSizeLinesCodePhisical(this.programCobol.getSizeSource());		// # Righe fisiche SLOC
			metricsObject.setSizeInstr(this.programCobol.getSizeInstrProc());   			// # Istruzioni
		}
		
		// Update misure metriche dead code di proc division
		metricsObject.setDeadInstr(cntDeadInstr);  		    							// Dead code Istruzioni non referenziati
		metricsObject.setDeadCopyProc(cntDeadCopyProc);  		    					// Dead code Copy con tutte le istruzioni dead code
		metricsObject.setDeadLabels(cntDeadLabel);  		    						// Dead code label non referenziate

		// Update misure metriche codice dinamico
		metricsObject.setDynamicInstr(cntDynamicInstr);									// Istruzioni dinamiche totali
		metricsObject.setDynamicInstrLight(cntDynamicInstrLight);						// Istruzioni dinamiche leggere

		// Calcolo indici di documentazione
        metricsObject.computeIdxDoc();                									// Calcolo indici di documentazione

 	}


	
	/*
	 * ----------------------------------------------------------------------------------
	 * Scan definizioni di data division e marcatura campi non utilizzati come dead code.
	 * ----------------------------------------------------------------------------------
	 *  
	 * La marcatura come dead code NON è automatica. 
	 * Si trattano solo i campi che NON sono definiti sotto un modulo copy.
	 * Si scartano i filler e i campi senza nome
	 * Il modulo copy stesso viene tratto come dead code se nessun campo viene referenziato.
	 * Si verificano tutti i gruppi sotto il quale il campo è definito.
	 * Se il campo non è referenziato e nemmeno i suoi gruppi allora è dead code.
	 * Viene fatta una eccezione per i campi definiti sotto Ioaree di Fd o utilizzate
	 * da istruzioni di accesso ai dati.
	 * In questo caso è normale che non tutti i campi sotto un tracciato vengano 
	 * utilizzati e pertanto il campo NON può condiderarsi dead code.
	 */
	private void finalPgmDataDeadCodeDataItems() {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		InstructionCobolDataItem dataItemCobol = null;
		ArrayList<String> al_fieldNameIndirect = null;
		String fieldName = "";
		String ar_fieldName[] = null;
	    int dataItemPointer = 0;
		int ar_fieldNumDef[] = null;
        int i = 0;
		boolean isAnyFieldIndirectUsed = false;					 
		
		// Solo se opzionedead code abilitata
		if (!di.optDetectDeadCode) {
			return;
		}
		// Questo metodo può essere richiamato post analisi dai processi a livello di programma
		this.programCobol.deadCodeDataItemNumbers().clear();
		
        ar_entryDataDivision = this.programCobol.entriesData();
        
		// Ciclo generale di analisi data division
		for (i = 0; i < ar_entryDataDivision.length; i++) {
			
			entryDataDivision = ar_entryDataDivision[i];

			// Interessano solo le definizioni di campi
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
			
			// Interessano solo i campi definiti direttamente, non dentro un modulo copy
			if (entryDataDivision.isUnderCopy()) {
				continue;
			}			
			
			// Definizione campo
			dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
			dataItemPointer = dataItemCobol.getNumInstr();
			fieldName = dataItemCobol.getDataName();
			
			// Il filler o un campo senza nome non interessa
			if (fieldName.equals("FILLER") || fieldName.equals("")) {
				continue;
			}
			
			// Campo referenziato: NON è dead code, continue
			// Potrebbe essere anche un campo di una ioarea di una istruzione di accesso dati Cics Vsam/Ts/Td/Commarea
			// L'analisi delle istruzioni di accesso dati inserisce gli XRef per tutti i campi della ioarea
			if (this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_INPUT) != null
			||	this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_OUTPUT) != null) {
				continue;
			}

			
			/////////////////////////////////////////////////////////////////////////////////
			// Il data item NON è direttamente referenziato: analisi condizioni di dead code
			/////////////////////////////////////////////////////////////////////////////////
						
			// Campo 77 o 88: sicuramente dead code
			if (dataItemCobol.getLevelNumber() == 77
			||  dataItemCobol.getLevelNumber() == 88) {
				entryDataDivision.setDeadCode(true);
				continue;
			}
            
			// Conterrà i campi indiretti di cui verificare se sono utilizzati
			al_fieldNameIndirect = new ArrayList<String>();

			// Campo di gruppo: estraggo tutti i sottocampi
			if (dataItemCobol.isGroupField()) {
				ar_fieldName = this.programCobol.dataItemsUnderGroupNames(dataItemCobol.getNumInstr(), DATA_ITEMS_ALL );
				al_fieldNameIndirect.addAll(Arrays.asList(ar_fieldName));
			}  
			// Campo di gruppo o elementare: estraggo i gruppi owner, i redefines e i rename
			ar_fieldName = this.programCobol.groupOwnerNames(dataItemCobol.getNumInstr());		// Gruppi sotto il quale il campo è definito
			al_fieldNameIndirect.addAll(Arrays.asList(ar_fieldName));                           //
			ar_fieldNumDef = this.programCobol.xrefToDataItemInDataDivision(fieldName);         // Campi che ridefiniscono o rinominano
			if (ar_fieldNumDef != null) {
				for (int numDef : ar_fieldNumDef) {
					al_fieldNameIndirect.add(this.programCobol.dataItemName(numDef)); 
				}
			}
			
			// Controllo se qualche campo indiretto individuato è referenziato
			isAnyFieldIndirectUsed = false;
			
			// Scan campi il cui reference è un reference indiretto per il campo sotto esame
			for (String fieldNameIndirect : al_fieldNameIndirect) {
				// Non interessa il filler o campi senza nome
				if (fieldNameIndirect.equals("FILLER") || fieldNameIndirect.equals("")) {
					continue;
				}
				// Campo in input o in output a qualche istruzione
				if (this.programCobol.xrefToSymbolInProcedure(fieldNameIndirect, INSTR_USE_DATA_ITEM_INPUT) != null
				||  this.programCobol.xrefToSymbolInProcedure(fieldNameIndirect, INSTR_USE_DATA_ITEM_OUTPUT) != null) {
					isAnyFieldIndirectUsed = true;
					break;
				}
			}

			// Il campo è referenziato indirettamente: NON è dead code
			if (isAnyFieldIndirectUsed) {
				continue;
			}
			
			// Campo NON referenziato nemmeno indirettamente: è dead code 
			entryDataDivision.setDeadCode(true);
			this.programCobol.deadCodeDataItemNumbers().add(i);
			
		} // end-for data items
	}

	

	/* ----------------------------------------------------------------------------
	 * Individuazione dead code per label, section, paragrafi e istruzioni unreach
	 * ----------------------------------------------------------------------------
	 * 
	 * Si analizzano le istruzioni di procedure division.
	 * Si marcano le istruzioni non raggiungibili come dead code unreach
	 * Si marcano section, paragrafi e label non referenziate come dead code
	 * Si aggiorna il descrittore del programma con nomi section, paragrafi e istruzioni dead code
	 * Non si considerano entries declarative
	 * Non si considerano istruzioni di mainline diverse da label
	 * 
	 */
	private void finalPgmProcDeadCodeInstructions()  {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryProcDivision= null;
		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
		InstructionCobolProcedure instrCobolProc = null;
		InstructionCics instructionPrecompilerCics = null;
		String labelSectionName = "";
		String labelParagraphName = "";
		boolean isDeadCodeFound = false;
		int i;
		int j;
		
		
		// Solo se opzione dead code abilitata
		if (!di.optDetectDeadCode) {
			return;
		}
		
		// Questo metodo può essere richiamato post analisi dai processi a livello di programma
		this.programCobol.deadCodeInstrNumbers().clear();
		
		ar_entryProcDivision = this.programCobol.entriesProcedure();
		
		// Ciclo generale di analisi procedure division  
		for (i = 0; i < ar_entryProcDivision.length; i++) {
			
			entryProcDivision = ar_entryProcDivision[i];

			// Istruzione di/dentro Declaratives: bypass
			if (entryProcDivision.isDeclarative()) {
				continue;
			}
			
			// Istruzione di mainline
			if (entryProcDivision.isMainline()) {
				// Label
				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
					instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
					if (!this.programCobol.isLabelReferenced(instrCobolProc.labelGetName())) {
						entryProcDivision.setDeadCode(true);
						this.programCobol.deadCodeLabels().add(instrCobolProc.labelGetName());
						this.programCobol.deadCodeInstrNumbers().add(i);
						continue;
					}
				}
				// Section
				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
					instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
					if (!this.programCobol.isSectionReferenced(instrCobolProc.sectionGetName())) {
						entryProcDivision.setDeadCode(true);
						isDeadCodeFound = true;
						this.programCobol.deadCodeSections().add(instrCobolProc.sectionGetName());
						this.programCobol.deadCodeInstrNumbers().add(i);
						continue;
					}
				}
				// Istruzione semplice da NON considerae dead code
				continue;
			}
			
			// Istruzione NON di mainline
			
		    // Section dead code: dead code esplicito o indiretto
		    if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
		    	instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
		    	labelSectionName = instrCobolProc.sectionGetName();
		    	// Sicuramente non referenziata
		        if  (programCobol.isSectionDeadCode(labelSectionName)) {
		        	entryProcDivision.setDeadCode(true);
		        	isDeadCodeFound = true;
		        	this.programCobol.deadCodeSections().add(labelSectionName);
		        	this.programCobol.deadCodeInstrNumbers().add(i);
			    	// Dead code fino a nuova Section o fine programma
					for (j = i + 1; j < ar_entryProcDivision.length; j++) {
						entryProcDivision = ar_entryProcDivision[j];
						if (instrCobolProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {break;}
						entryProcDivision.setDeadCode(true);
						this.programCobol.deadCodeInstrNumbers().add(j);
					} // end-for
                    i = j - 1;
                    continue;
		        } // end-if
		    } // end-if

		    // Paragrafo dead code: delimitato da label+exit non referenziato
		    if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		    &&  entryProcDivision.getUnderProcInternalPointer()	== 0 ) {
		    	instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
		    	labelParagraphName = instrCobolProc.labelGetName();
		    	if (instrCobolProc.labelIsParagraph() && !this.programCobol.isParagraphReferenced(labelParagraphName)) {
					this.programCobol.deadCodeParagraphs().add(labelParagraphName);
					this.programCobol.deadCodeInstrNumbers().add(i);
			    	// Dead code fino a nuova label o section o fine programma
					for (j = i + 1; j < ar_entryProcDivision.length; j++) {
						entryProcDivision = ar_entryProcDivision[j];
						if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION
					    ||  entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
							break;
						}
						entryProcDivision.setDeadCode(true);
						isDeadCodeFound = true;
						this.programCobol.deadCodeInstrNumbers().add(j);
					} // end-for
                    i = j - 1;
                    continue;
				}
		    }
		    
			// Label dentro section: eventualmente marcata dead code anche da analisi section
		    if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		    &&  entryProcDivision.getUnderProcInternalPointer()	> 0) {
		    	instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
		    	labelSectionName = instrCobolProc.labelGetName();
		    	if (programCobol.isSymbolUnXref(labelSectionName)) {
		    	    entryProcDivision.setDeadCode(true);
		    	    isDeadCodeFound = true;
		    	    this.programCobol.deadCodeLabels().add(labelSectionName);
		    	    this.programCobol.deadCodeInstrNumbers().add(i);
		    	}
		    	continue;
		    } // end-if
			
			// Label fuori da section: verifica se paragrafo richiamabile con perform, perform thru o GoTo
		    if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		    &&  entryProcDivision.getUnderProcInternalPointer()	== 0) {
		    	instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
		    	labelSectionName = instrCobolProc.labelGetName();
		    	// Label NON referenziata, NON paragrafo: marco come dead code    	 
		    	if (!instrCobolProc.labelIsParagraph() && programCobol.isSymbolUnXref(labelSectionName)) {
		    		entryProcDivision.setDeadCode(true);
		    		this.programCobol.deadCodeLabels().add(labelSectionName);
		    		this.programCobol.deadCodeInstrNumbers().add(i);
		 	    	// Dead code fino a nuova Section o label o Stop o Goback o goTo o fine programma
		 			for (j = i + 1; j < ar_entryProcDivision.length; j++) {
		 				entryProcDivision = ar_entryProcDivision[j];
		 				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION
		 			    ||  entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		 			    ||  entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_STOP
		 			    ||  entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_GOBACK
		 			    ||  entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
		 					break;
		 				}
		 				entryProcDivision.setDeadCode(true);
		 				this.programCobol.deadCodeInstrNumbers().add(j);
		 			} // end-for
		            i = j - 1;
                    continue;
		    	} // end-if
		    } // end-if

			// Istruzione Sql NON può alterare il flusso: skip
			if (entryProcDivision.getInstruction() instanceof InstructionSql) {
				continue;
			}
		    
			// Istruzione Cics: verifica se Xctl/Abend/Return
			if (entryProcDivision.getInstruction() instanceof InstructionCics
			&& 	entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PRECOMPILER_CICS) {
				instructionPrecompilerCics = (InstructionCics) entryProcDivision.getInstruction();
				// Non sono istruzioni dopo le quali il codice presente non è raggiungibile
				if (instructionPrecompilerCics.getTypeInstrPrecompiler() != EnumPrecompilerReservedWords.CICS_INSTR_RETURN
				&&  instructionPrecompilerCics.getTypeInstrPrecompiler() != EnumPrecompilerReservedWords.CICS_INSTR_START		
				&&  instructionPrecompilerCics.getTypeInstrPrecompiler() != EnumPrecompilerReservedWords.CICS_INSTR_XCTL		
				&&  instructionPrecompilerCics.getTypeInstrPrecompiler() != EnumPrecompilerReservedWords.CICS_INSTR_ABEND) {
					continue;
				}
			}
			
			// Istruzione cobol diversa da Stop run o Goback o GoTo: skip
			if (entryProcDivision.getInstruction() instanceof InstructionCobolProcedure) {
				instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
				if (instrCobolProc.getTypeInstr() != EnumCobolReservedWords.PROC_STOP
				&&  instrCobolProc.getTypeInstr() != EnumCobolReservedWords.PROC_GOBACK		
				&&  instrCobolProc.getTypeInstr() != EnumCobolReservedWords.PROC_GOTO) {
					continue;
				}
			}
			
			// Istruzione imperativa Cobol o Cics
			
			// Solo se istruzione imperativa incondizionata istruzioni successive non raggiungibili
			if (entryProcDivision.isUnderCondition()) {
				continue;
			}
			
            // Si tratta di Stop Run, goback, GoTo, Exec Cics Return, Start, Xctl o Abend
		    // Ogni istruzione successiva fino a una label o section referenziata è da 
			// da considerarsi dead code è in più NON raggiungibile.
		    
	    	// Dead code fino a nuova Section o label referenziata o fine programma
			for (j = i + 1; j < ar_entryProcDivision.length; j++) {
				entryProcDivision = ar_entryProcDivision[j];
				// Section 
				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
					break;
				}
				// Label 
				if (entryProcDivision.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
					instrCobolProc = (InstructionCobolProcedure) entryProcDivision.getInstruction();
					// Label Referenziata: fine codice morto non raggiungibile
					if (this.programCobol.isLabelReferenced(instrCobolProc.labelGetName())) {
						break;
					}
				}
				entryProcDivision.setDeadCode(true);
				entryProcDivision.setDeadCodeUnreachable(true);
				this.programCobol.deadCodeInstrNumbers().add(j);
				this.programCobol.deadCodeUnreachable().add(j);
				
			} // end-for
			
            i = j - 1;
 			
		} // end-for 
			
		if (!isDeadCodeFound) {return;}
		
		// Opzione dead code presente
		EntityObjectOption entityObjectOption = new EntityObjectOption();
		entityObjectOption.setSystem(this.di.systemInput);
		entityObjectOption.setSubSystem(this.di.subSystemInput);
		entityObjectOption.setIdObject(this.programName);
		entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
		entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DEAD_CODE);
		analyzerDbInfo.addObjEntityOption(entityObjectOption);
		
	}

	
	/*
	 * -------------------------------------------------------
	 * Individuazione copy dead code
	 * -------------------------------------------------------
	 * 
	 * Scan istruzioni e individuazione istruzioni appartenenti allo stesso copy.
	 * Se tutte le istruzioni risultano dead code, marcatura istruzione copy come
	 * dead code direttamente nell'istruzione.
	 * L'elenco dei copy dead code, non utilizzati nel programma viene memorizzato
	 * nell'oggetto ProgramCobol e quindi serializzato.
	 * In caso di copy nested viene considerato e marcato solo il copy scatenante,
	 * anche se i copy nested richiamati, non hanno anch'essi avuto movimentazione.
	 * I copy dead  code di data division non utilizzati, sono già stati marcati
	 * al momento dell'individuazione dei where used dei campi contenuti.
	 * Si inserisce l'opzione cop
     * Si inserisce la relazione PGM_COPY_UNUSED 
     * Si inserisce l'opzione PGM_WITH_COPY_UNUSED
	*/
	@SuppressWarnings("unchecked")
	private void finalPgmProcDeadCodeCopy() throws ExceptionAmrita, SQLException {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryProcDivision= null;
		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
		ProgramCobolEntry<? extends Instruction> entryCopy = null;
		InstructionCobol instrCopy = null;
		InstructionCobol instrGeneric = null;
		ArrayList<Integer> al_numInstr = null;
		String copyName = "";
		boolean isCopyDeadCode = true;
		int i;
		int j;
		
		// Solo se opzionedead code abilitata
		if (!di.optDetectDeadCode) {
			return;
		}

		// Questo metodo può essere richiamato post analisi dai processi a livello di programma
		this.programCobol.deadCodeCopyProc().clear();
		
		// Ciclo generale di analisi procedure division 
		ar_entryProcDivision = this.programCobol.entriesProcedure();
		for (i = 0; i < ar_entryProcDivision.length; i++) {
			
			entryProcDivision = ar_entryProcDivision[i];
			
			// Non è uno statement COPY: skip
			if (entryProcDivision.getEntryType() != EnumInstrDataCategory.COBOL_COPY_INSTRUCTION) {
				continue;
			}

			entryCopy = entryProcDivision;
			instrCopy = (InstructionCobol) entryCopy.getInstruction();
			copyName = instrCopy.copyGetName();
			isCopyDeadCode = true;
			
			// Scan istruzioni a partire da quella successiva al modulo copy
			for (j = i + 1; j < ar_entryProcDivision.length; j++) {
				
				entryProcDivision = ar_entryProcDivision[j];
				instrGeneric = (InstructionCobol) entryProcDivision.getInstruction();
				
                // Istruzione NON marcata deadCode da precedenti analisi
				if (!entryProcDivision.isDeadCode()) {
					isCopyDeadCode = false;
					// Bypass istruzioni copy rimanenti
					for (j = j + 1; j < ar_entryProcDivision.length; j++) {
						entryProcDivision = ar_entryProcDivision[i];
						// Istruzione fuori dal copy che si stava trattando
						// Incontrato probabilmente altro Copy o istruzione fuori copy
						if (entryProcDivision.getLevelNestingCopy() == 0) {
							break;
						}
					} // end-for bypass istruzioni copy	
					i = j - 1;
					break;
				}
			} // end-for istruzioni copy
			
			// Inserico nome copy in struttura programma
			this.programCobol.getCopyNamesProc().add(copyName);
			
			// Tutte le istruzioni del copy sono deadcode
			if (isCopyDeadCode) {
				this.programCobol.deadCodeCopyProc().add(copyName);
				entryCopy.setDeadCode(true);
				
				// Inserimento opzione programma
				EntityObjectOption entityObjectOption = new EntityObjectOption();
				entityObjectOption.setSystem(this.di.systemInput);
				entityObjectOption.setSubSystem(this.di.subSystemInput);
				entityObjectOption.setIdObject(this.programName);
				entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
				entityObjectOption.setOption(EnumObjectOption.PGM_WITH_COPY_UNUSED);
				analyzerDbInfo.addObjEntityOption(entityObjectOption);
				
				// Relazione pgm_copy_unused
	            this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
												        			EnumObject.OBJECT_PGM_COBOL
																  , this.pgmNameUnderParsing
																  , EnumObject.OBJECT_COPY_COBOL_PROC
															  	  , copyName
																  , EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS
																  , EnumRelation.PGM_COPY_UNUSED
																  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
																  , this.pgmNameUnderParsing
																  , entryCopy.getInstruction().getNumInstr()
																  , 0
																  , 0
																  , ""
																  , 0
																  , 0
																  , entryCopy.getInstruction().getTypeInstrCategory()
																  , entryCopy.getProgramDivision()
																  , false
																  , false
																  , false
																  , this.di.userExitInfoPgm
																   );
				
			}
			
		} // end-for istruzioni di procedure

	}

	
	/* ------------------------------------------------------------------------------------------
	 * Scan istruzioni identification division e caricamento nome copy in struttura di programma.
	 * ------------------------------------------------------------------------------------------
	 * 
	 */
	private void finalPgmIdDivSetCopy() {

		ProgramCobolEntry<? extends Instruction>[] ar_entryIdDivision= null;
		ProgramCobolEntry<? extends Instruction> entryIdDivision = null;
		InstructionCobol instrCopy = null;
		String copyName = "";
		int i;
		
		ar_entryIdDivision = this.programCobol.entriesIdentification();
		
		// Ciclo generale di analisi identification division 
		for (i = 0; i < ar_entryIdDivision.length; i++) {
			
			entryIdDivision = ar_entryIdDivision[i];
			
			// Non è uno statement cobol copy: skip
			if (entryIdDivision.getEntryType() != EnumInstrDataCategory.COBOL_COPY_INSTRUCTION) {
				continue;
			}

			instrCopy = (InstructionCobol) entryIdDivision.getInstruction();
			copyName = instrCopy.copyGetName();
			
			// Inserisco in struttura programma
			this.programCobol.getCopyNamesId().add(copyName);
				
		}  

	}
		
	/* ---------------------------------------------------------------------------------------
	 * Scan istruzioni environment division e caricamento nome copy in struttura di programma.
	 * ---------------------------------------------------------------------------------------
	 * 
	 */
	private void finalPgmEnvDivSetCopy() {

		ProgramCobolEntry<? extends Instruction>[] ar_entryEnvDivision= null;
		ProgramCobolEntry<? extends Instruction> entryEnvDivision = null;
		InstructionCobol instrCopy = null;
		String copyName = "";
		int i;
		
		ar_entryEnvDivision = this.programCobol.entriesEnvironment();
		
		// Ciclo generale di analisi environment division 
		for (i = 0; i < ar_entryEnvDivision.length; i++) {
			
			entryEnvDivision = ar_entryEnvDivision[i];
			
			// Non è uno statement cobol copy: skip
			if (entryEnvDivision.getEntryType() != EnumInstrDataCategory.COBOL_COPY_INSTRUCTION) {
				continue;
			}

			instrCopy = (InstructionCobol) entryEnvDivision.getInstruction();
			copyName = instrCopy.copyGetName();
			
			// Inserisco in struttura programma
			this.programCobol.getCopyNamesEnv().add(copyName);
				
		}  
	}
		
	/*
	 * ------------------------------------
	 * Computo misure dimensionali di base
	 * ------------------------------------
	 * 
	 * Il numero di righe con commenti, vuote o space, è già stato
	 * conteggiato a inizio elaborazione, in fase di normalizzazione
	 * del sorgente.
	 * Lo scopo è quello di avere in ogni caso le informazioni dimensionali
	 * anche a fronte di exception.
	 * Tuttavia in questa fase alcune misure vengono ricalcolate in quanto
	 * si può avere maggiore precisione.
	 * Queste misurazioni sono utilizzate per popolare le metriche di programma.
	 * 
	 */
	private void finalPgmDimensionalMeasures() {
		
		ProgramCobolEntry<? extends Instruction> entryProcDiv = null;
		ProgramCobolEntry<? extends Instruction> entryDataDiv = null;
		Instruction instrGeneric = null;
	    
		// Misure effettuate su tutto il programma
		int sizeInstrProc = 0;                                          // Numero istruzioni di procedure division
	    int sizeInstrData = 0;                                          // Numero istruzioni di definizione dati in data division
	    int sizeInstrDataFile = 0;                                      // Numero istruzioni di definizione dati in data division file section
	    int sizeInstrDataWorking = 0;                                   // Numero istruzioni di definizione dati in data division file working
	    int sizeInstrDataLinkage = 0;                                   // Numero istruzioni di definizione dati in data division file linkage
	    int sizeInstrDataProgram = 0;                                   // Numero istruzioni di definizione dati definite nel source del programma
	    int sizeInstrDataCopy = 0;                                      // Numero istruzioni di definizione dati definite in copy richiamati
	    int sizeSource = 0;                                             // Numero righe sorgente complessive
	    int sizeSourceProc = 0;                                         // Numero righe sorgente di procedure division
	    int sizeSourceData = 0;                                         // Numero righe sorgente di definiziuone dati, NON di procedure division
	    int sizeSourceBlank = 0;                                        // Numero righe sorgente complessive vuote (da colonna 7 a 72)
	    int sizeSourceProcBlank = 0;                                    // Numero righe sorgente di procedure division vuote (da colonna 7 a 72)
	    int sizeSourceDataBlank = 0;                                    // Numero righe sorgente di definizione dati, NON di procedure division, vuote (da colonna 7 a 72)
	    int sizeComm = 0;                                      			// Numero righe commento del programma 
	    int sizeCommProc = 0;                                      		// Numero righe commento di procedure division 
	    int sizeCommData = 0;                                      		// Numero righe commento di definizione dati
	    
	    // Di servizio
	    String row = "";
	    int numRowProcDiv = 0;
	    int numRowDataDiv = 0;
        int i = 0;  
	    

        entryProcDiv = this.programCobol.entriesProcedure()[0];
	    instrGeneric = entryProcDiv.getInstruction();
	    numRowProcDiv = instrGeneric.getRowStartSource();
	    entryDataDiv = this.programCobol.entriesData()[0];
	    instrGeneric = entryDataDiv.getInstruction();
	    numRowDataDiv = instrGeneric.getRowStartSource();

	    sizeInstrProc = this.programCobol.entriesProcedure().length;
	    sizeSource = this.si.getArrayRowSource().length;
	    sizeSourceProc = sizeSource - numRowProcDiv + 1;
	    sizeSourceData = sizeSource - numRowProcDiv;
	    
	    // Scan data division
	    for (ProgramCobolEntry<? extends Instruction> entryData : this.programCobol.entriesData()) {
	    	
	    	// Conteggio definizione dati
	    	if (entryData.getInstruction() instanceof InstructionCobolDataItem	) {
	    		sizeInstrData++;
				if (entryData.isUnderCopy()) {
					sizeInstrDataCopy++;
				} else {
					sizeInstrDataProgram++;
				}
			}
	    	
			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_FILE_SECTION
			&&  entryData.getInstruction() instanceof InstructionCobolDataItem	) {
				sizeInstrDataFile++;
				continue;
			}
			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_WS_SECTION
			&&  entryData.getInstruction() instanceof InstructionCobolDataItem	) {
				sizeInstrDataWorking++;
				continue;
			}
			if (entryData.getProgramSection() == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
			&&  entryData.getInstruction() instanceof InstructionCobolDataItem	) {
				sizeInstrDataLinkage++;
				continue;
			}
		}
	    
	    // Individuazione righe vuote/commento di procedure division
	    for (i = numRowProcDiv; i < this.si.getArrayRowSource().length; i++) {
	    	row = this.si.getArrayRowSource()[i];
	    	if (isRowCobolEmpty(row)) {
	    		sizeSourceBlank++;
	    		sizeSourceProcBlank++;
	    		continue;
			}
	    	if (isCobolRowComm(row)) {
	    		sizeComm++;
	    		sizeCommProc++;
	    		continue;
			}
		}
	    
	    // Individuazione righe vuote/commento di data division
	    for (i = numRowDataDiv + 1; i < numRowProcDiv; i++) {
	    	row = this.si.getArrayRowSource()[i];
	    	if (isRowCobolEmpty(row)) {
	    		sizeSourceBlank++;
	    		sizeSourceDataBlank++;
	    		continue;
			}
	    	if (isCobolRowComm(row)) {
	    		sizeComm++;
	    		sizeCommData++;
			}
		}
	    
	    // Individuazione righe vuote/commento fino a statement data division escluso
	    for (i = 0; i < numRowDataDiv; i++) {
	    	row = this.si.getArrayRowSource()[i];
	    	if (row.trim().equals("")) {
	    		sizeSourceBlank++;
			}
	    	if (isCobolRowComm(row)) {
	    		sizeComm++;
			}
		}
	    
	    // Update descrittore programma
	    this.programCobol.setSizeInstrProc(sizeInstrProc);
	    this.programCobol.setSizeInstrData(sizeInstrData);
	    this.programCobol.setSizeInstrDataFile(sizeInstrDataFile);
	    this.programCobol.setSizeInstrDataWorking(sizeInstrDataWorking);
	    this.programCobol.setSizeInstrDataLinkage(sizeInstrDataLinkage);
	    this.programCobol.setSizeSource(sizeSource);
	    this.programCobol.setSizeSourceProc(sizeSourceProc);
	    this.programCobol.setSizeSourceData(sizeSourceData);
	    this.programCobol.setSizeSourceBlank(sizeSourceBlank);
	    this.programCobol.setSizeSourceProcBlank(sizeSourceProcBlank);
	    this.programCobol.setSizeSourceDataBlank(sizeSourceDataBlank);
	    this.programCobol.setSizeComm(sizeComm);
	    this.programCobol.setSizeCommProc(sizeCommProc);
	    this.programCobol.setSizeCommData(sizeCommData);
	    
        // Update oggetto con info di analisi per completare le misure dimensionali 
        this.analyzerDbInfo.getObjAnalysisInfo().setNumDefData(sizeInstrData);
        this.analyzerDbInfo.getObjAnalysisInfo().setNumDefDataProgram(sizeInstrDataProgram);
        this.analyzerDbInfo.getObjAnalysisInfo().setNumDefDataCopy(sizeInstrDataCopy);
        this.analyzerDbInfo.getObjAnalysisInfo().setNumStmtProc(sizeInstrProc);

	}


	/*
	 * ----------------------------------------------------------------------------
	 * Inserimento opzione su db dimensioni programma
	 * ----------------------------------------------------------------------------
	 * 
	 */
	private void finalPgmOptionDimension() {
		
		EntityObjectOption entityObjectOption = null;
		EnumObjectOption pgmDimension = EnumObjectOption.NOT_ASSIGNED;
		ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
		
		ar_entryProc = this.programCobol.entriesProcedure();
		
		// Small
		if (ar_entryProc.length >= EnumThresholds.COB_PGM_SMALL.getThresholdLow() 
		&&  ar_entryProc.length <= EnumThresholds.COB_PGM_SMALL.getThresholdHigh()) {
			pgmDimension = EnumObjectOption.PGM_SMALL;
		} 
		
		// Medium
		if (ar_entryProc.length >= EnumThresholds.COB_PGM_MEDIUM.getThresholdLow() 
		&&  ar_entryProc.length <= EnumThresholds.COB_PGM_MEDIUM.getThresholdHigh()) {
			pgmDimension = EnumObjectOption.PGM_MEDIUM;
		} 
		
		// Large
		if (ar_entryProc.length >= EnumThresholds.COB_PGM_LARGE.getThresholdLow() 
		&&  ar_entryProc.length <= EnumThresholds.COB_PGM_LARGE.getThresholdHigh()) {
			pgmDimension = EnumObjectOption.PGM_LARGE;
		} 
		
		// Huge
		if (ar_entryProc.length >= EnumThresholds.COB_PGM_HUGE.getThresholdLow() 
		&&  ar_entryProc.length <= EnumThresholds.COB_PGM_HUGE.getThresholdHigh()) {
			pgmDimension = EnumObjectOption.PGM_HUGE;
		} 
		
		entityObjectOption = new EntityObjectOption();
		entityObjectOption.setSystem(this.di.systemInput);
		entityObjectOption.setSubSystem(this.di.subSystemInput);
		entityObjectOption.setIdObject(this.programName);
		entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
		entityObjectOption.setOption(pgmDimension);
		this.analyzerDbInfo.addObjEntityOption(entityObjectOption);
	}

	/* ------------------------------------------
	 * Restituisce true se la riga è un commento
	 * ------------------------------------------
	 * 
	 * Deve avere un * a colonna 7
	 * 
	 */
	private boolean isCobolRowComm(String row) {
		if (row.length() < 7) {return false;}
		if (row.charAt(6) == '*') {return true;}
		if (row.charAt(6) == '/') {return true;}
		
		// Solo se MF
		if (row.charAt(0) == '*')  {return true;}
		return false;
	}


	/* --------------------------------------------
	 * Restituisce true se la riga cobol è vuota
	 * --------------------------------------------
	 * 
	 * Si tratta di righe di lunghezza zero o con space da col 7 a 72
	 * Oppure di eighe commento con space da col 8 a 72
	 */
	private boolean isRowCobolEmpty(String row) {
		
		if (row.trim().length() == 0) {return true;}
		if (row.length() >= 7 && row.charAt(6) == '*') {
			if (row.substring(7).trim().equals("")) {
				return true;
			}
			if (row.length() >= 72 && row.substring(7, 72).trim().equals("")) {
				return true;
			}
			return false;
		}
		
		if (row.length() < 72) {
			if (row.length() < 7) {
				return true;
			}
			if (row.length() >= 7 && row.substring(7).trim().equals("")) {
				return true;
			} else {
				return false;
			}
		}
        // >= 72
		if (row.substring(7, 72).trim().equals("")) {
			return true;
		}
		return false;
	}

	/* --------------------------------------------
	 * Restituisce true se la riga è vuota
	 * --------------------------------------------
	 * 
	 * Si tratta di righe di lunghezza zero o con soli space
	 * 
	 */
	private boolean isRowEmpty(String row) {
		
		if (row.trim().length() == 0) {return true;}
		return false;
	}


	/*
	 * 

	 */
	/*
	 * ------------------------------------------------------------
	 * Completamento informazioni su istruzioni di programma.
	 * ------------------------------------------------------------
	 * 
	 * Vengono esaminati tutti gli entry di istruzioni di procedure division.
	 * Si utilizza un pointer nell'entry dell'istruzione all'istruzione correlata.
	 * In caso di istruzioni che generano un nuovo livello di stack (If, Evaluate, Search,
	 * Inner Perform), il pointer punta all'istruzione di fine blocco END-.., oppure 
	 * all'istruzione ordinaria chiusa con punto.
	 * In caso di istruzioni significative che Non generano un nuovo livello di stack
	 * come (ELSE, NEXT SENTENCE, WHEN, CONTINUE,..), il pointer punta all'istruzione
	 * di inizio blocco.
	 *   
	 * Si inizia dalla prima istruzione di procedure division.
	 * - Per ogni istruzione che individua un blocco (IF, SEARCH, EVALUATE, ..) viene aggiornato 
	 *   il pointer alla istruzione di fine blocco.
	 * - Per Ogni istruzione di fine blocco viene aggiornato il pointer all'istruzione
	 *   che individua l'inizio blocco.
	 * - Per ogni istruzione di exception, viene aggiornato il pointer all'istruzione
	 *   corretta di inizio blocco di appartenenza.
	 *   
	 * In definitiva il pointer di istruzione correlata punta a una istruzione precedente
	 * o successivas, a seconda del tipo
	 * 
	 * Nel caso di label, se questa è un paragrafo, si aggiorna il flag nell'istruzione
	 * oltre al numero dell'ultima istruzione del paragrafo.
	 * 
	 * Nel caso di section si aggiorna nell'istruzione il numero dell'ultima istruzione 
	 * della section.
	 * 
	 * Contestualmente, per ogni perfor/perform thru si popola la map map_InternalProcedure
	 * utilizzata successivamente per calcolo metriche e violazioni.
	 * 
	 * A fine elaborazione si marcano le istruzioni di Mainline
	 * 
	 * 1) Si scorre sequenzialmente il programma
	 * 2) Si marca l'istruzione come "Mainline"
	 * 3) Se istruzione Goback/Stop Run/Exit NON sotto if fine elaborazione
	 * 4) Se istruzione Section/label performata in map_InternalProcedure fine elaborazione
	 * 5) Si aggiorna in Program il pointer all'ultima istruzione di mainline 
	 * 
	 */
 	private void finalPgmProcSetInstructionInfo() {
		
 		ExceptionAmrita excp = null;
 		
    	// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
    	ProgramCobolEntry<? extends Instruction> procEntry = null;
       	InstructionCobolProcedure instrProc = null;
       	InstructionCobolProcedure instrProcLastStak = null;
    	InstructionCobolProcedure instrProcRelated = null;				// Per esempio READ a fronte di AT END
    	
    	// Entry di procedure, e istruzione Cobol da Stack
      	ProgramCobolEntry<? extends Instruction> procEntryLastStack = null;
     	ProgramCobolEntry<? extends Instruction> procEntryBeginBlock = null;
    	ProgramCobolEntry<? extends Instruction> procEntryEndBlock = null;
    	ProgramCobolEntry<? extends Instruction> procEntryWork = null;
  		EnumCobolReservedWords typeInstrLastStack = null;

     	// Tipo istruzione corrente e mappata
     	EnumCobolReservedWords typeInstr = null;
     	EnumCobolReservedWords typeInstrMapped = null;
     	ArrayList<EnumCobolReservedWords> al_typeInstrMapped = null;
     	
       	// Stack con istruzioni da collegare a istruzione inizio blocco, definite prima
     	ArrayList<Integer> al_Stack = null;
     	
     	// Map tipi istruzioni collegabili a istruzioni owner.
    	// Coppia di tipo istruzione/ArrayList possibili istruzioni owner collegate
    	// La Else viene mappata su un ArrayList contenente solo la If
    	// La OnSizeError viene mappata su un ArrayList con Add, Multiply, Divide etc
    	Map<EnumCobolReservedWords, ArrayList<EnumCobolReservedWords>> map_InstrRelated = null;
     	
    	// Varie
    	String idSectionLabel = "";
        int iLastStack = 0;
       	int numInstrSectionParagraph = 0;
     	int levelDeepEntry = 0;
     	int numEntryOwnerConditional = 0;
        boolean isUnderDeclaratives = false;
    	boolean isSectionInProgress = false;
    	boolean isParagraphInProgress = false;    	
        
    	// Allocazione strutture e initial
     	al_Stack = new ArrayList<Integer> ();
     	map_InstrRelated = new HashMap<EnumCobolReservedWords, ArrayList<EnumCobolReservedWords>> ();
   
     	//////////////////////////////////////////////////////////////////////////////////////////////
    	// (1) Caricamento map istruzioni / istruzioni di chiusura e/o da correlare
     	//     Key = istruzione Dati=ArrayList istruzione di chiusura / istruzioni possibili di inizio blocco
     	//////////////////////////////////////////////////////////////////////////////////////////////
     	
     	populateMapInstrRelated(map_InstrRelated);
    	
    	ar_procEntry = this.programCobol.entriesProcedure();
    	

    	// Scan Entries di programma 
    	for (int i = 0; i < ar_procEntry.length; i++) {
  
    		if (i > 1743) {
    			idSectionLabel = "";
			}
    		
    		
     		// Estraggo istruzione e tipo istruzione
    		procEntry = ar_procEntry[i];
            procEntry.setLevelDeepEntry(levelDeepEntry);
            procEntry.setNumEntryOwnerConditional(numEntryOwnerConditional);
            
     		// Impostazione flag di entry sotto condizione
    		// Stack non vuoto implica IF/EVALUATE/SEARCH/PERFORM inner precedenti non chiuse
    		if (al_Stack.size() > 0) {
    			procEntry.setUnderCondition(true);
			}
    		
     		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
    		if (!(procEntry.getInstruction() instanceof InstructionCobolProcedure )) {
				continue;
			}
    		instrProc = (InstructionCobolProcedure) procEntry.getInstruction();
    		typeInstr = instrProc.getTypeInstr();

    		// Declaratives
    		if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_DECLARATIVES) {
    			isUnderDeclaratives = true;
			}
    		
    		procEntry.setDeclarative(isUnderDeclaratives);
    		
    		// End Declaratives 
    		if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_END_DECLARATIVES) {
    			isUnderDeclaratives = false;
			}
 
    		// Istruzione Section.
    		// Individiduazione ultimo numero istruzione.
       		if (typeInstr == EnumCobolReservedWords.PROC_SECTION) {
       			isSectionInProgress = true;
       			isParagraphInProgress = false;
       			numInstrSectionParagraph = i;
				finalPgmProcSectionSetLastNumInstr(procEntry);
			}
  		    
    		// Istruzione Label.
    		// Verifica se paragrafo e, se tale, individiduazione ultimo numero istruzione paragrafo.
       		if (typeInstr == EnumCobolReservedWords.PROC_LABEL) {
 				finalLabelParagraphSetLastNumInstr(procEntry, isSectionInProgress, isParagraphInProgress);
 				// La label è un paragrafo dichiarato/performato/dead code
 				if (instrProc.labelIsParagraph()) {
 					isSectionInProgress = false;
 					isParagraphInProgress = true;
 					numInstrSectionParagraph = i;
				}
 			}
    		
       		// Update istruzione corrente con section/paragraph owner
      		if (isSectionInProgress && typeInstr != EnumCobolReservedWords.PROC_SECTION) {
   				procEntry.setUnderProcInternal(true);
   				procEntry.setUnderProcInternalPointer(numInstrSectionParagraph);
       		}
      		if (isParagraphInProgress) {
      			if (typeInstr != EnumCobolReservedWords.PROC_LABEL
      			|| (typeInstr == EnumCobolReservedWords.PROC_LABEL && i == numInstrSectionParagraph + 1)) {
       				procEntry.setUnderProcInternal(true);
       				procEntry.setUnderProcInternalPointer(numInstrSectionParagraph);
				}
       		}
       		       		
       		// Termine formale section o paragrafo
       		if (typeInstr == EnumCobolReservedWords.PROC_EXIT) {
      			isSectionInProgress = false;
       			isParagraphInProgress = false;
       			numInstrSectionParagraph = 0;
			}
       		
    		// Istruzione label o section o istr terminata da punto non END-..: forzatura update istruzioni in stack pendenti e clear stack
     		if (al_Stack.size() > 0) {
           		if (typeInstr == EnumCobolReservedWords.PROC_LABEL		
   	    		||  typeInstr == EnumCobolReservedWords.PROC_SECTION
   	    		||(!typeInstr.getValueText1().startsWith("END") && instrProc.isTerminatedWithPoint())) {
   	  				// Pop stack precedenti se diverso da IF/EVALUATE/SEARCH/PERFORM/DECLARATIVES      				
   	   				// Si eliminano READ WRITE .. precedenti sicuramente NON chiuse da END- 
   	     			// Si aggiornano i pointer alle istruzioni di inizio/fine blocco related
   	     			// Si azzera lo stack
   	     			finalProcSetClearStack(al_Stack, ar_procEntry, procEntry, typeInstr, i);
   	     			numEntryOwnerConditional = 0;
   	     			levelDeepEntry = 0;
   	      			continue;
   	 			}
			}
    		
    		// Non è sicuramente una istruzione di inizio blocco
    		if (typeInstr == EnumCobolReservedWords.PROC_PERFORM && !instrProc.performIsInnerPerform()) {
				continue;
			}
    		
      		// Eventuali istruzioni correlabili all'istruzione corrente
       		al_typeInstrMapped = map_InstrRelated.get(typeInstr);

       		// Istruzione di inizio blocco se non terminata con .: caricamento in stack
       		// Tuttavia le istruzioni possono NON essere chiuse da una istruzione di fine blocco
       		// Per esempio WRITE potrebbe non essere chiusa da END-WRITE
       		if (al_typeInstrMapped != null) {
       			typeInstrMapped = al_typeInstrMapped.get(0);
       			if ((typeInstrMapped.toString().startsWith("END-") 
       			&& !instrProc.isTerminatedWithPoint())
       			|| instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_DECLARATIVES) {
       				// IF/EVALUATE/SEARCH/PERFORM inner: pop da stack entry inutili
     				if (typeInstr == EnumCobolReservedWords.PROC_IF
       				||  typeInstr == EnumCobolReservedWords.PROC_EVALUATE		
     				||  typeInstr == EnumCobolReservedWords.PROC_SEARCH
       				|| (typeInstr == EnumCobolReservedWords.PROC_PERFORM && instrProc.performIsInnerPerform())) {
     					levelDeepEntry++;
           				// Pop stack precedenti se diverso da IF/EVALUATE/SEARCH/PERFORM       				
           				// Si evita di caricare in stack cose come READ WRITE .. precedenti sicuramente NON chiuse da END- 
     					finalProcPopStackUnclosedStatements(al_Stack, ar_procEntry);
 					}
   					al_Stack.add(i);		// Push in stack IF/EVALUATE/SEARCH/PERFORM inner/READ/CALL/ADD/...
 					if (typeInstr == EnumCobolReservedWords.PROC_IF) {
						numEntryOwnerConditional = i;
					}
 					continue;
				}
 			}
 
    		// Istruzione di fine blocco END-..: deve essere relativa all'ultima istruzione di inizio blocco in stack
       		// Lo stack è già stato ripulito da istruzioni con END-.. potenziali NON chiuse
       		if (typeInstr.toString().startsWith("END-") && al_Stack.size() > 0 ) {
       			
       			iLastStack = al_Stack.size() - 1;
       			procEntryEndBlock = procEntry;
       			
       			// Inizio blocco non trovato: errore
          		if (iLastStack < 0) {
    				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_RELATING_COBOL_PROC_DIVISION);
    				instrProc.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0024", "", excp, this.pgmNameUnderParsing, typeInstr.toString(), procEntryEndBlock.getTypeInstr().toString() );
    				instrProc.setSemanticError(true);
    				this.ictx.isAnyInstructionErrorDetected = true;
          			continue;
				}
           		
          		// Impostazione correlazioni
         		procEntryLastStack = ar_procEntry[al_Stack.get(iLastStack)];
           		typeInstrLastStack = procEntryLastStack.getTypeInstr();
    			procEntryBeginBlock = procEntryLastStack;
    			procEntryBeginBlock.setNumInstrRelated(i);
      			procEntryEndBlock.setNumInstrRelated(procEntryBeginBlock.getInstruction().getNumInstr());
      			
      			// Pop stack 
 				al_Stack.remove(al_Stack.size() - 1);
 				levelDeepEntry--;
				if (typeInstr == EnumCobolReservedWords.PROC_END_IF) {
					numEntryOwnerConditional = 0;
					if (al_Stack.size() > 0 ) {
						numEntryOwnerConditional = al_Stack.get(al_Stack.size() - 1);
					}
				}

				
 				// Pop stack precedenti alla END-... corrente, chiusa correttamente  				
   				if (instrProc.isTerminatedWithPoint()) {
 	    			finalProcSetClearStack(al_Stack, ar_procEntry, procEntry, typeInstr, i);
				}
       			continue;
			}
       		
        	// Istruzione da correlare all'istruzione di inizio blocco
       		// Si tratta di ELSE, WHEN, ON SIZE ERROR, AT END etc.
       		// Nel caso di istruzioni di exception, l'istruzione owner viene marcata "withHandleException"
    		if (!typeInstr.toString().startsWith("END-") 
    		&&   al_Stack.size() > 0 
    		&&  (typeInstr == EnumCobolReservedWords.PROC_ELSE 					||
	   			 typeInstr == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH 	||
   	   			 typeInstr == EnumCobolReservedWords.PROC_AT_END 				||
  	   			 typeInstr == EnumCobolReservedWords.PROC_ON_SIZE_ERROR 		||
	   			 typeInstr == EnumCobolReservedWords.PROC_ON_OVERFLOW 			||
	   			 typeInstr == EnumCobolReservedWords.PROC_ON_EXCEPTION
    		    )) {
    			// Pop da stack entries inutili
    			if (typeInstr == EnumCobolReservedWords.PROC_ELSE 
    			||	typeInstr == EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH) {
    				// Se ELSE collegamento a IF che DEVE essere l'ultimo eleìmento dello stack
    				// Decremento livello annidamento IF
    				if (typeInstr == EnumCobolReservedWords.PROC_ELSE) {
						if (al_Stack.size() > 0) {
							procEntryWork = ar_procEntry[al_Stack.get(al_Stack.size() - 1)];
							if (procEntryWork.getTypeInstr() == EnumCobolReservedWords.PROC_IF) {
								procEntryWork.setNumInstrRelatedElse(i);
							}
						}
						levelDeepEntry--;
					}
    	   			finalProcPopStackUnclosedStatements(al_Stack, ar_procEntry);
				}
     			// L'struzione di inizio blocco è la prima di cui fare pop dallo stack
           		iLastStack = al_Stack.size() - 1;
				procEntryLastStack = ar_procEntry[al_Stack.get(iLastStack)];
           		typeInstrLastStack = procEntryLastStack.getTypeInstr();
				// Correlazione istruzione corrente a quella in Stack
				procEntry.setNumInstrRelated(procEntryLastStack.getInstruction().getNumInstr());
				typeInstr = procEntry.getTypeInstr();
				// Istruzione da correlare di exception: marcatura istruzione in stack (es. READ a fronte di At End)
				if (typeInstr.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_PROC_INSTRUCTION_EXCEPTION) {
					instrProcRelated = (InstructionCobolProcedure) procEntryLastStack.getInstruction();
					instrProcRelated.setWithHandledException(true);
				}
				continue;
 			} // end-if
          	
		} // end-for
    	
    	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
    	// 2) Aggiornamento per ogni perform dei numeri istruzione inizio/fine paragrafo/section
    	//    Il numero istruzione di fine paragrafo è già stato aggiornato nello statement label nel ciclo presedente
    	//    Inserimento entry in map_InternalProcedure per ogni procedura performata
    	/////////////////////////////////////////////////////////////////////////////////////////////////////////////
    	
    	// Scan Entries di programma 
    	for (int i = 0; i < ar_procEntry.length; i++) {
 
    		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
    		procEntry = ar_procEntry[i];
       		if (!(procEntry.getInstruction() instanceof InstructionCobolProcedure )) {
				continue;
			}
    		instrProc = (InstructionCobolProcedure) procEntry.getInstruction();
    		typeInstr = instrProc.getTypeInstr();
    		
    		// Interessano solo le perform NON inner
   		    if (typeInstr == EnumCobolReservedWords.PROC_PERFORM && !instrProc.performIsInnerPerform()) {
   		   	   	finalPerformSetFromThruNumInstr(procEntry);
			}
 
    	} // end-for

    	
    	// Lo stack deve essere vuoto o contenere come ultimo entry 
    	// una istruzione diversa da IF/EVALUATE/SEARCH/PERFORM
    	// Impostazione numeri di inizio/fine istruzione in Perform/Perform thru
    	if (al_Stack.size() > 0) {
    		iLastStack = al_Stack.size() - 1;
			procEntryLastStack = ar_procEntry[al_Stack.get(iLastStack)];
			instrProcLastStak = (InstructionCobolProcedure) procEntryLastStack.getInstruction();
       		typeInstrLastStack = procEntryLastStack.getTypeInstr();
       		if (typeInstrLastStack == EnumCobolReservedWords.PROC_IF
       		||  typeInstrLastStack == EnumCobolReservedWords.PROC_EVALUATE		
       		||  typeInstrLastStack == EnumCobolReservedWords.PROC_SEARCH		
       		||  typeInstrLastStack == EnumCobolReservedWords.PROC_PERFORM) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_RELATING_COBOL_PROC_DIVISION);
				instrProcLastStak.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0023", "", excp, this.pgmNameUnderParsing, typeInstrLastStack.toString());
				instrProcLastStak.setSemanticError(true);
				this.ictx.isAnyInstructionErrorDetected = true;
 			}
		}
    
    	//////////////////////////////////////////////////////////////////////
    	// 3) Mark istruzioni di mainline
    	//////////////////////////////////////////////////////////////////////
    	
    	for (ProgramCobolEntry<? extends Instruction> procEntryMainline : this.programCobol.entriesProcedure()) {
    		
    		procEntryMainline.setMainline(true);
    		 
    		// Interessano solo le istruzioni di procedure division, non Copy, non precompiler ...
        	if (!(procEntryMainline.getInstruction() instanceof InstructionCobolProcedure )) {
				continue;
			}
    		instrProc = (InstructionCobolProcedure) procEntryMainline.getInstruction();
    		typeInstr = instrProc.getTypeInstr();
 
	        // Statement sotto Declaratives, che possono contenere Sectio: skip
    		if (procEntryMainline.isDeclarative()) {
				continue;
			}  		
    		
     		// Section/label: scarto se non performata, significa che il programma inizia con una section o una label
    		// oppure che nella mainline c'è una label non referenziata.
    		if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION  ||
    			instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
    			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
    				idSectionLabel = instrProc.sectionGetName();
				} else {
					idSectionLabel = instrProc.labelGetName();
				}      			
    			if (map_InternalProcedure.get(idSectionLabel) == null) {
					continue;
				}
    			// Si è in presenza di una section o di un paragrafo richiamato
    			// Sicuramente è la fine della mainline, resetto flag
    			procEntryMainline.setMainline(false);
    			this.programCobol.setNumLastInstrMainline(instrProc.getNumInstr());
    			return;
  			}
    		
    		// NON è sicuramente fine mainline
    		if (typeInstr != EnumCobolReservedWords.PROC_STOP
    		||	typeInstr != EnumCobolReservedWords.PROC_GOBACK) {
				continue;
    			
			}
    		
     		// NON è fine mainline, istruzione di fine sotto condizione		
    		if (procEntryMainline.isUnderCondition()) {
				continue;
			}
    		
    		// Fine mainline, istruzione di fine esplicita non sotto if
    		this.programCobol.setNumLastInstrMainline(instrProc.getNumInstr());
    		break;
  		
 		}
    	
 	}
    
 	/* -----------------------------------------------------
 	 * Pop da stack fino a entries sicuramente da chiudere
 	 * -----------------------------------------------------
 	 * 
 	 * Vengono eliminati entry di stack non necessariamente chiusi da una END esplicita o da un punto.
 	 * Si tratta di WRITE, READ, CALL etc.
 	 * In generale sono istruzioni diverse da quelle di cui si gestisce completamente lo stacking
 	 */
 	private void finalProcPopStackUnclosedStatements(ArrayList<Integer> al_Stack, ProgramCobolEntry<? extends Instruction>[] ar_procEntry) {
 		int numInstrLastStack = 0;
 		
		while (al_Stack.size() > 0) {
			numInstrLastStack = al_Stack.get(al_Stack.size() - 1);
			if (ar_procEntry[numInstrLastStack].getTypeInstr() != EnumCobolReservedWords.PROC_IF
			&&  ar_procEntry[numInstrLastStack].getTypeInstr() != EnumCobolReservedWords.PROC_EVALUATE		
			&&  ar_procEntry[numInstrLastStack].getTypeInstr() != EnumCobolReservedWords.PROC_SEARCH
			&&  ar_procEntry[numInstrLastStack].getTypeInstr() != EnumCobolReservedWords.PROC_PERFORM) {
				al_Stack.remove(al_Stack.size() - 1);
				continue;
			}
			return;
		}
	}


	/* ------------------------------------------------------------
 	 * Pop stack a fronte label/section/istruzione terminata da .
 	 * ------------------------------------------------------------
 	 * 
 	 * Pop stack precedenti se diverso da IF/EVALUATE/SEARCH/PERFORM       				
   	 * Si eliminano READ WRITE .. precedenti sicuramente NON chiuse da END- 
     * Si aggiornano i pointer alle istruzioni di inizio/fine blocco related
     * Si azzera lo stack
 	 * 
 	 */
    private void finalProcSetClearStack(ArrayList<Integer> al_Stack									// Stack
    								  , ProgramCobolEntry<? extends Instruction>[] ar_procEntry		// Istruzioni del programma
    								  , ProgramCobolEntry<? extends Instruction> procEntry			// Entry istruzione di chiusura
    								  , EnumCobolReservedWords typeInstr						    // Tipo istruzione di chiusura
    								  , int numInstr                                                // Numero istruzione di chiusura
    								   ) {
    	
     	ProgramCobolEntry<? extends Instruction> procEntryStack = null;
       	ArrayList<Integer> al_StackEpured = null;
       	int numInstrFirstStack = 0;
       	
       	al_StackEpured = new ArrayList<Integer> ();
    	
    	// Creazione stack con le sole istruzioni effettivamente da chiudere
    	// Se sono presenti READ/WRITE/.. significa che non erano state chiuse da END-..
    	// e quindi vanno trattate come istruzioni normali
    	for (Integer numInstrInStak : al_Stack) {
    		
			if (ar_procEntry[numInstrInStak].getTypeInstr() != EnumCobolReservedWords.PROC_IF
			&&  ar_procEntry[numInstrInStak].getTypeInstr() != EnumCobolReservedWords.PROC_EVALUATE		
			&&  ar_procEntry[numInstrInStak].getTypeInstr() != EnumCobolReservedWords.PROC_SEARCH
			&&  ar_procEntry[numInstrInStak].getTypeInstr() != EnumCobolReservedWords.PROC_PERFORM
			&&  ar_procEntry[numInstrInStak].getTypeInstr() != EnumCobolReservedWords.PROC_DECLARATIVES) {
				continue;
			}
    		
			al_StackEpured.add(numInstrInStak);
 		}
    	
 		// Scan stack con le sole istruzioni da correlare
		for (Integer numInstrStacked : al_StackEpured) {
			// Update istruzione di inizio blocco e di chiusura 
			procEntryStack = ar_procEntry[numInstrStacked];
			procEntryStack.setNumInstrRelated(numInstr);
			if (typeInstr == EnumCobolReservedWords.PROC_LABEL		
    	    ||  typeInstr == EnumCobolReservedWords.PROC_SECTION) {
    			procEntryStack.setNumInstrRelated(numInstr - 1);
    		}
		    
			procEntry.setNumInstrRelated(procEntryStack.getInstruction().getNumInstr());
		}
		
		// Si sta ancora trattando le DECLARATIVES: lo stack non deve esser completamente azzerato
		if (al_Stack.size() > 0) {
			numInstrFirstStack = al_Stack.get(0);
			procEntryStack = ar_procEntry[numInstrFirstStack];
			if (procEntryStack.getTypeInstr() == EnumCobolReservedWords.PROC_DECLARATIVES 
			&&  typeInstr != EnumCobolReservedWords.PROC_END_DECLARATIVES) {
				al_Stack.clear();
				al_Stack.add(numInstrFirstStack);
				return;
			}
		}
		
		// Clear stack
		al_Stack.clear();
	}


	/* ----------------------------------------
 	 * Individuazione ultima istruzione section
 	 * ----------------------------------------
 	 * 
 	 * Si individua l'ultima istruzione
 	 * Si aggiorna il numero di istruzione related nell'entry
 	 *   Il numero di istruzione di fine può essere quello dell'ultima istruzione
 	 *   prima della fine del programma o della section successiva.
 	 *   Oppure quello della label di chiusura prima della successiva Exit.
 	 *   Lo statement Exit NON viene quindi preso in considerazione.
 	 * Si aggiorna l'istruzione Section
 	 */
 	private void finalPgmProcSectionSetLastNumInstr(ProgramCobolEntry<? extends Instruction> entryProc) {
 		
		ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
		ProgramCobolEntry<? extends Instruction> entry = null;
		InstructionCobolProcedure instrSection = null;
		int numInstrLast = 0;
		int i = 0;
		
		ar_entryProc = this.programCobol.entriesProcedure();
		instrSection = (InstructionCobolProcedure) entryProc.getInstruction();
		
		// Individuo ultima istruzione section
		for (i = instrSection.getNumInstr() + 1; i < ar_entryProc.length; i++) {
			entry = ar_entryProc[i];
			// Nuova section o Exit o fine declaratives
			if (entry.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION 
		    ||  entry.getTypeInstr() == EnumCobolReservedWords.PROC_EXIT
			||  entry.getTypeInstr() == EnumCobolReservedWords.PROC_END_DECLARATIVES) {
				break;
			}
		}
		if (i >= ar_entryProc.length) {
			numInstrLast = ar_entryProc.length - 1;
		} else {
			numInstrLast = i - 1;
			if (this.programCobol.entryProcedure(numInstrLast).getTypeInstr() == EnumCobolReservedWords.PROC_EXIT) {
				numInstrLast--;
			}
		}
		
		// Update entry section 
		entryProc.setNumInstrRelated(numInstrLast);
			
	    // Update istruzione Section
		instrSection.sectionSetLastNumInstr(numInstrLast);
		
	}

	/* --------------------------------------------
 	 * Individuazione ultima istruzione paragrafo
 	 * --------------------------------------------
 	 * 
 	 * Si verifica se la label è un paragrafo performato o dichiarato in declaratives o dead code delimitato da EXIT
 	 * Si individua l'ultima istruzione
 	 * Si aggiorna il numero di istruzione related nell'entry
 	 *   Il numero di istruzione di fine può essere quello dell'ultima istruzione
 	 *   prima della fine del programma o della section successiva.
 	 *   Oppure quello della label di chiusura prima della successiva Exit.
 	 *   Lo statement Exit NON viene quindi preso in considerazione.
 	 * Si aggiorna l'istruzione Label con indicazione di paragrafo e di ultima istruzione paragrafo
 	 */
 	private void finalLabelParagraphSetLastNumInstr(ProgramCobolEntry<? extends Instruction> entryLabel, boolean isSectionInProgress, boolean isParagraphInProgress) {

		ProgramCobolEntry<? extends Instruction>[] ar_entryProc = null;
		ProgramCobolEntry<? extends Instruction> entry = null;
 		ProgramCobolEntry<? extends Instruction> entryProc = null;
		InstructionCobolProcedure instrLabel = null;
		InstructionCobolProcedure instrProc = null;
		String procedureNameThru = "";
		boolean isLabelDeclared = false;
		boolean isLabelPerformed = false;
		boolean isLabelPerformedOrDeclaredThru = false;
		int[] ar_xrefToLabel = null;
		int numInstrLast = 0;
		int numInstrThru = 0;
		int i = 0;
 
		
		ar_entryProc = this.programCobol.entriesProcedure();
		instrLabel = (InstructionCobolProcedure) entryLabel.getInstruction();
		
		// Individuo se la label è stata performata come paragrafo con thru option
		// Individuo se la label è stata dichiarata come paragrafo con thru option in una istruzione Sort/Merge
		ar_xrefToLabel = this.programCobol.xrefToProcedureInternal(instrLabel.labelGetName());
		for (int iXref : ar_xrefToLabel) {
			entry = this.programCobol.entryProcedure(iXref);
			if (!(entry.getInstruction() instanceof InstructionCobolProcedure)) {continue;}
			instrProc = (InstructionCobolProcedure) entry.getInstruction();
			
			// Perform
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM) {
				if (instrProc.performGetFrom().equals(instrLabel.labelGetName())) {
					instrLabel.labelSetParagraph(true);
					isLabelPerformed = true;
					if (instrProc.performIsWithThru()) {
						isLabelPerformedOrDeclaredThru = true;
						procedureNameThru = instrProc.performGetThru();
						numInstrThru = this.programCobol.labelPointer(procedureNameThru);
						numInstrLast = numInstrThru;
					}
					break;
				}
			}
			
			// Sort/Merge
			if (instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_SORT
			||  instrProc.getTypeInstr() == EnumCobolReservedWords.PROC_MERGE) {
				isLabelDeclared = true;
				if (instrProc.sortMergeIsWithThruInputProcedure() && instrProc.sortMergeGetFromInputProcedure().equals(instrLabel.labelGetName())) {
					isLabelDeclared = true;
					isLabelPerformedOrDeclaredThru = true;
					instrLabel.labelSetParagraph(true);
					procedureNameThru = instrProc.sortMergeGetThruInputProcedure();
					numInstrThru = this.programCobol.labelPointer(procedureNameThru);
					instrProc.sortMergeSetThruInputProcedureNumInstr(numInstrThru);
					numInstrLast = numInstrThru;
					break;
				}
				if (instrProc.sortMergeIsWithThruOutputProcedure() && instrProc.sortMergeGetFromOutputProcedure().equals(instrLabel.labelGetName())) {
					isLabelDeclared = true;
					isLabelPerformedOrDeclaredThru = true;
					instrLabel.labelSetParagraph(true);
					procedureNameThru = instrProc.sortMergeGetThruOutputProcedure();
					numInstrThru = this.programCobol.labelPointer(procedureNameThru);
					instrProc.sortMergeSetThruInputProcedureNumInstr(numInstrThru);
					numInstrLast = numInstrThru;
					break;
				}
			}
		}
		
		// E' un paragrafo dichiarato nelle declaratives o performato
		if (isLabelDeclared || isLabelPerformed) {
			
			// Eseguito o dichiarato con perform thru 
			if (isLabelPerformedOrDeclaredThru) {
				// Update entry label con numero istruzione label di chiusura
				entryLabel.setNumInstrRelated(numInstrLast);
				instrLabel.labelSetLastNumInstrParagraph(numInstrLast);
				return;
			}
			
			// Eseguito con perform NON thru: individuo ultima istruzione paragrafo
			for (i = instrLabel.getNumInstr() + 1; i < ar_entryProc.length; i++) {
				entry = ar_entryProc[i];
				// Section dopo paragrafo o Fine declaratives
				if (entry.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION
				||  entry.getTypeInstr() == EnumCobolReservedWords.PROC_END_DECLARATIVES) {
					numInstrLast = i - 1;
					break;
				}
				// Label ultima istruzione del programma
				if (entry.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
				&&  i == ar_entryProc.length - 1) {
					numInstrLast = i;
					break;
				}
				// Label di chiusura, seguita da Exit
				if (entry.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
				&& this.programCobol.entryProcedure(i + 1).getTypeInstr() == EnumCobolReservedWords.PROC_EXIT) {
					numInstrLast = i;
					break;
				}
				// Label di chiusura, NON seguita da Exit
				if (entry.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
				&& this.programCobol.entryProcedure(i + 1).getTypeInstr() != EnumCobolReservedWords.PROC_EXIT) {
					numInstrLast = i - 1;
					break;
				}
			}
			if (i >= ar_entryProc.length) {
				numInstrLast = ar_entryProc.length - 1;
			}
			
			// Update entry label con numero ultima istruzione paragrafo
			entryLabel.setNumInstrRelated(numInstrLast);
			instrLabel.labelSetLastNumInstrParagraph(numInstrLast);
			return;
		} 
		
		// Sono dentro una section: no operation
		if (isSectionInProgress) {
			return;
		}
		
		// E' una label NON referenziata NON dentro una section 
		// Se è delimitata da una successiva label seguita da EXIT, 
		// allora è un paragrafo, dead code, da marcare regolarmente 
		// come paragrafo nell'istruzione label.
		
		// Scan fino a successiva section o label o Exit o fine programma
  		for (i = instrLabel.getNumInstr() + 1; i < ar_entryProc.length; i++) {
  			entryProc = ar_entryProc[i];
  			if (entryProc.getTypeInstr() != EnumCobolReservedWords.PROC_SECTION
   	  		&&  entryProc.getTypeInstr() != EnumCobolReservedWords.PROC_LABEL) {
				continue;
			}
  			break;
		}
  		
  		// Fine programma: era solo l'ultima label prima della fine del programma
  		if (i >= ar_entryProc.length) {
			return;
		} 
 
		// Section dopo label in esame: si trattava di una label fra section  
        if (entryProc.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
        	return;
 		}	  		
	    
  		// Label dopo label in esame, ultima istruzione del programma
  		if (i >= ar_entryProc.length - 1) {
			return;
		} 
 
  		// Label di chiusura non seguita da exit: non lo considero un paragrafo
  		entryProc = ar_entryProc[i + 1];
  		if (entryProc.getTypeInstr() != EnumCobolReservedWords.PROC_EXIT) {
			return;
		}

		// Exit.
        // Chiusura formale paragrafo, considero la label in esame un paragrafo
        numInstrLast = 	i;									// label di chiusura prima di Exit
 		entryLabel.setNumInstrRelated(numInstrLast);
		instrLabel.labelSetLastNumInstrParagraph(numInstrLast);
		instrLabel.labelSetParagraph(true);
	}

 	
	/* ----------------------------------------------------------------
 	 * Aggiornamento istruzione perform con i numeri di istruzione
 	 * ----------------------------------------------------------------
 	 * 
 	 * Si tratta dei numeri di inizio fine section/paragrafo richiamato.
     *
   	 */
    private void finalPerformSetFromThruNumInstr(ProgramCobolEntry<? extends Instruction> entryPerform) {
    	
    	ExceptionAmrita excp = null;
     	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	InstructionCobolProcedure instrPerform = null;
    	InstructionCobolProcedure instrLabel = null;
    	InnerInternalProcedure innerInternalProcedure = null;
      	int[] ar_pointerDef = null;
       	int numInstrFrom = 0;
       	int numInstrThru = 0;
    	String idProcFrom = "";
		String idProcThru = "";

		instrPerform = (InstructionCobolProcedure) entryPerform.getInstruction();
		idProcFrom = instrPerform.performGetFrom();
		ar_pointerDef = this.programCobol.getXrefSymbolDefProc(idProcFrom);
		
		// Paragrafo non codificato o errore di programma
		if (ar_pointerDef == null) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_COMPLETING_COBOL_PERFORM);
			instrPerform.setInfoError(EnumMessageType.ERROR_INPUT, "ET0044", "", excp, this.pgmNameUnderParsing);
			instrPerform.setSemanticError(true);
			ictx.isAnyInstructionErrorDetected = true;
            return;
		}
		
		numInstrFrom = ar_pointerDef[0];
		procEntry = this.programCobol.entryProcedure(numInstrFrom);
		instrLabel = (InstructionCobolProcedure) procEntry.getInstruction();
		instrPerform.performSetFromNumInstr(numInstrFrom);
		
		// Era perform thru
		if (instrPerform.performIsWithThru()) {
			idProcThru = instrPerform.performGetThru();
			ar_pointerDef = this.programCobol.getXrefSymbolDefProc(idProcThru);
			// Fine paragrafo non codificato o errore di programma
			if (ar_pointerDef == null) {
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_COMPLETING_COBOL_PERFORM);
				instrPerform.setInfoError(EnumMessageType.ERROR_INPUT, "ET0044", "", excp, this.pgmNameUnderParsing);
				instrPerform.setSemanticError(true);
				ictx.isAnyInstructionErrorDetected = true;
                return;
			}
			numInstrThru = ar_pointerDef[0];
			instrPerform.performSetThruNumInstr(numInstrThru);
		// Era solo perform, il numero di istruzione di fine paragrafo è memorizzato nella label
		} else {
			numInstrThru = instrLabel.labelGetLastNumInstrParagraph();
			instrPerform.performSetThruNumInstr(numInstrThru);			
		}
        
		innerInternalProcedure = this.map_InternalProcedure.get(idProcFrom);
		
		// Perform a paragrafo già incontrata in precedenza
		if (innerInternalProcedure != null) {
			return;
		}
		
		innerInternalProcedure = new InnerInternalProcedure();
		innerInternalProcedure.idProcedurePerformed = idProcFrom;
		innerInternalProcedure.idProcedurePerformedComplete = idProcFrom;
//		if (!idProcThru.isBlank()) {
		if (idProcThru.trim().length() != 0) {
			innerInternalProcedure.idProcedurePerformedComplete = idProcFrom + ":" + idProcThru;
		}
		innerInternalProcedure.instrFrom = numInstrFrom;
		innerInternalProcedure.instrTo = numInstrThru;
		innerInternalProcedure.isPerformToLabel = false;
		innerInternalProcedure.isPerformToLabelThruLabel = false;
		innerInternalProcedure.isPerformToSection = false;
		innerInternalProcedure.isPerformToSectionThruLabel = false;
		if (instrLabel.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
			innerInternalProcedure.isPerformToLabel = true;
			if (numInstrThru > 0) {
				innerInternalProcedure.isPerformToLabelThruLabel = true;
			}
		}
		if (instrLabel.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION) {
			innerInternalProcedure.isPerformToSection = true;
			if (numInstrThru > 0) {
				innerInternalProcedure.isPerformToSectionThruLabel = true;
			}
		}
		
		this.map_InternalProcedure.put(idProcFrom, innerInternalProcedure);
		
	}





    /* ---------------------------------------------------------
     * Inserimento opzioni programma relative al codice dinamico
     * ---------------------------------------------------------
     * 
     * Si analizzano tutte le istruzioni dinamiche.
     * Si inseriscono le opzioni in base ai flag nell'istruzione.
     * 
     */
	private void finalInsertOptionsDynamicCode() {
		
    	EntityObjectOption entityObjectOption = null;
  		
    	// Entries correnti di procedure, entry e istruzione Cobol
    	ProgramCobolEntry<? extends Instruction> ar_procEntry[] = null;
    	ProgramCobolEntry<? extends Instruction> procEntry = null;
    	Instruction instrGeneric = null;
    	
        boolean isWithDynamicCode=false;	
        boolean isWithDynamicCodeToSolve=false;	
        boolean isWithDynamicCodeSolved=false;	
        boolean isWithDynamicCodeSolvedFull=false;	
        boolean isWithDynamicCodeSpreaded=false;	
        boolean isDynamicWaitingForData=false;
       	
    	ar_procEntry = this.programCobol.entriesProcedure();
    	
    	// Scan Entries di programma 
    	for (int i = 0; i < ar_procEntry.length; i++) {
    		
    		procEntry = ar_procEntry[i];
       		instrGeneric = (Instruction) procEntry.getInstruction();

      		// Interessano solo le istruzioni dinamiche
    		if (!instrGeneric.isDynamic()) {
				continue;
			}
  
            // Dynamic
    		isWithDynamicCode=true;
    		
            // DynamicCodeToSolve
    		if (!instrGeneric.isDynamicSolvedFull()) {
    			isWithDynamicCodeToSolve=true;
 			}    		
            // DynamicCodeSolved
    		if (instrGeneric.isDynamicSolved()) {
    			isWithDynamicCodeSolved=true;
			}    		
            // DynamicCodeSolvedFull
    		if (instrGeneric.isDynamicSolvedFull()) {
    			isWithDynamicCodeSolvedFull=true;
			}    		
            // DynamicCodeSpreaded
    		if (instrGeneric.isDynamicSpreaded()) {
    			isWithDynamicCodeSpreaded=true;
			}    		
            // DynamicCodeWaitingForData
    		if (instrGeneric.isDynamicWaitingForData()) {
    			isDynamicWaitingForData=true;
 			}
    		
		} // end-for  
    	
        // DynamicCode
    	if (isWithDynamicCode) {
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);
			this.ictx.isWithDynamicCode = true;
		}
    	// DynamicCodeTosolve
    	if (isWithDynamicCodeToSolve) {
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE_TO_SOLVE);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);
			this.ictx.isWithDynamicCodeSpreadedToSolve = true;
		}
    	// DynamicCodeSolved
    	if (isWithDynamicCodeSolved) {
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE_SOLVED);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);
			this.ictx.isWithDynamicCodeSolved = true;			
		}
    	// DynamicCodeSolvedFull
    	if (isWithDynamicCodeSolvedFull) {
		    entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE_SOLVED_FULL);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);			
		}
    	// DynamicCodeSpreaded
    	if (isWithDynamicCodeSpreaded) {
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE_SPREAD);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);	
			this.ictx.isWithDynamicCodeSpreadedToSolve = true;
		}
    	// DynamicWaitingForData
    	if (isDynamicWaitingForData) {
			entityObjectOption = new EntityObjectOption();
			entityObjectOption.setSystem(this.di.systemInput);
			entityObjectOption.setSubSystem(this.di.subSystemInput);
			entityObjectOption.setIdObject(this.programName);
			entityObjectOption.setTypeObject(EnumObject.OBJECT_PGM_COBOL);
			entityObjectOption.setOption(EnumObjectOption.PGM_WITH_DYNAMIC_CODE_WAITING_FOR_DATA);
			this.analyzerDbInfo.addObjEntityOption(entityObjectOption);
			this.ictx.isWithDynamicCodeWaitingForData = true;
		}
 
	}

	/* ---------------------------------------------------------------
     * Inserimento where used delle colonne usate di istruzioni SQL.
     * ---------------------------------------------------------------
     * 
     * Si scandiscono le istruzioni e per ogni istruzione SQL
     * e di ogni tabella nell'istruzione si inseriscono i WhereUsed
     * delle colonne SQL in INPUT o in OUTPUT, se a fronte di SELECT/INSERT/UPDATE/DECLARE_CURSOR
     * I where used delle variabili Host vengono impostati a livello generale di istruzione
     * 
     */
 	@SuppressWarnings("unchecked")
	private void finalPgmWhereUsedSqlColumns() {
 		ProgramCobolEntry<? extends Instruction>[] ar_entryProcDivision = null;
 		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
		InstructionSql instrSql = null;
		EntityWhereUsedItem entityWhereUsed = null;  
		SqlSelectStatement sqlSelect = null;
		SqlInsertStatement sqlInsert = null;
		SqlDeleteStatement sqlDelete = null;
		SqlUpdateStatement sqlUpdate = null;
		SqlDeclareCursorStatement sqlDeclareCursor = null;
		ArrayList<SqlTableDeclared> al_entity = null;
		ArrayList<SqlTableColumnDeclaredComplete> al_tableColumns = null;
		SqlTableColumnDeclaredComplete tableColumns = null;
		EnumWhereUsedType whereUsedIO = null;
		String entityName = "";
		int numInstr = 0;
		int j = 0;
		
		// Inserimento where used db columns NON abilitato
		if (!di.optWhereUsedCopyItemsOnDbToInsert) {
			return;
		}
		
 		// Scan istruzioni programma
 		ar_entryProcDivision = this.programCobol.entriesProcedure();
		for (int i = 0; i < ar_entryProcDivision.length; i++) {
			entryProcDivision = ar_entryProcDivision[i];
			// Non è una istruzione Sql
			if (!entryProcDivision.isInsideInstructionPrecompilerSql()) {
				continue;
			}
			
			// Istruzione Sql, estrazione nomi tabelle coinvolte
			instrSql = (InstructionSql) entryProcDivision.getInstruction();
			numInstr = instrSql.getNumInstr();
			
			if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_SELECT) {
				sqlSelect = instrSql.sqlSelectGetDescriptor();		
				al_entity = sqlSelect.getEntitiesDeclared();
				al_tableColumns = sqlSelect.getEntitiesColumnsDeclared();
				whereUsedIO = EnumWhereUsedType.WHERE_USED_INPUT;
			} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DELETE) {
				sqlDelete = instrSql.sqlDeleteGetDescriptor();		
				al_entity = sqlDelete.getEntitiesDeclared();
				al_tableColumns = sqlDelete.getEntitiesColumnsDeclared();
				whereUsedIO = EnumWhereUsedType.WHERE_USED_INPUT;
				continue;
			} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_UPDATE) {
				sqlUpdate = instrSql.sqlUpdateGetDescriptor();		
				al_entity = sqlUpdate.getEntitiesDeclared();
				al_tableColumns = sqlUpdate.getEntitiesColumnsDeclared();
				whereUsedIO = EnumWhereUsedType.WHERE_USED_OUTPUT;
			} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INSERT) {
				sqlInsert = instrSql.sqlInsertGetDescriptor();		
				al_entity = sqlInsert.getEntitiesDeclared();
				al_tableColumns = sqlInsert.getEntitiesColumnsDeclared();
				whereUsedIO = EnumWhereUsedType.WHERE_USED_OUTPUT;
			} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DECLARE_CURSOR) {
				sqlDeclareCursor = instrSql.sqlDeclareCursorGetDescriptor();
				sqlSelect = sqlDeclareCursor.getSelectStatement();
				al_entity = sqlSelect.getEntitiesDeclared();	
				al_tableColumns = sqlSelect.getEntitiesColumnsDeclared();
				whereUsedIO = EnumWhereUsedType.WHERE_USED_INPUT;
			} else {
				// Eventuale altra istruzione Sql non gestita
				continue;				
			}			
			
			// Scan entities
			j = 0;
			for (SqlTableDeclared table : al_entity) {
				entityName = table.getTableName();
				
				// Incaso di Insert/select, colonne non dichiarate a causa di Create Table non analizzata
				// o colonne non dichiarate nello statement
				if (al_tableColumns.size() == 0) {
					break;
				}
				
				// Scan columns
				tableColumns = al_tableColumns.get(j);
				for (SqlTableColumnDeclared column : tableColumns.getColumnsDeclared()) {					
					entityWhereUsed = new EntityWhereUsedItem();
					
					// Key
					entityWhereUsed.setSystem(this.di.systemInput);
					entityWhereUsed.setSubSystem(this.di.subSystemInput);
					entityWhereUsed.setIdObject(this.programName);
					entityWhereUsed.setTypeObject(EnumObject.OBJECT_ENTITY_SQL);
					entityWhereUsed.setIdField(column.getColumnName());
					entityWhereUsed.setNumSeq(0);
					entityWhereUsed.setIdObjectRefer(this.programCobol.getProgramName());
					entityWhereUsed.setTypeObjectRefer(EnumObject.OBJECT_PGM_COBOL);
					entityWhereUsed.setNumInstrRefer(numInstr);

					// Data
					entityWhereUsed.setRowStart(instrSql.getRowStartSource());
					entityWhereUsed.setRowEnd(instrSql.getRowEndSource());
					entityWhereUsed.setIdObjectCopy(entryProcDivision.getUnderCopyName());
					entityWhereUsed.setRowStartInCopy(0);
					entityWhereUsed.setRowEndInCopy(0);
					entityWhereUsed.setIdAliasLocal("");
					entityWhereUsed.setIdIoarea("");
					entityWhereUsed.setIdAliasLocal("");
					entityWhereUsed.setIdObjectCopy("");
					entityWhereUsed.setTypeWhereUsed(whereUsedIO);
					entityWhereUsed.setTypeAlias(EnumWhereUsedTypeAlias.ALIAS_FULL_MATCH);
					entityWhereUsed.setPosInIoarea(0);
					entityWhereUsed.setUsedBytes(0);
					entityWhereUsed.setNumInt(0);
					entityWhereUsed.setNumDec(0);
					entityWhereUsed.setSigned(false);
					entityWhereUsed.setInstrLang(EnumLanguageItemInstr.ITEM_SQL);
					entityWhereUsed.setInstrType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
					this.analyzerDbInfo.addObjEntityWhereUsed(entityWhereUsed);	
					
					j++;
				}
			}
		}
			
 	}



	/* --------------------------------------------------------------------
     * Inserimento where used dei campi dei copy/include di data division.
     * --------------------------------------------------------------------
     * 
     * Si usa una map di servizio del tipo:
     * 
     * Key  = nome copy
     * Data = ArrayList<Object[4]>
     * 
     * Dove:
     * 
     * Object[0] = InstructionCobol copyStmt
     * Object[1] = ArrayList<InstructionDataItem>
     * Object[2] = CopyCobol originale not replaced
     * Object[3] = Boolean anyItemUsed
     * 
     */
 	@SuppressWarnings("unchecked")
	private void finalPgmWhereUsedCopyItems() {
		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
    	ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision = null;
       	ProgramCobolEntry<? extends Instruction> dataItemEntry = null;
       	ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
	    Instruction copyStmt = null;                               // Istruzione copy
	    InstructionCobolDataItem dataItem = null;
	    InstructionSql instrSqlPrecompiler = null;
        Set<Integer> set_sqlNumInstr = null;
	    @SuppressWarnings("unused")
		CopyCobol copyObject = null;
    	ArrayList<Object[]> al_ar_object = null;
	    Map<String,  ArrayList<Object[]>> map_copy = null;
    	Object ar_Object[] = null;                                      // Mappato da map copyDetected
 	    ArrayList<InstructionCobolDataItem> al_dataItemCopy = null;     // Data item copy inclusi nel programma
        int i = 0;	
	    boolean isCopyUsed = false;
	    
	    String copyName = "";											 
	    
	    map_copy = new HashMap<String,  ArrayList<Object[]>>();
        
	    //////////////////////////////////////////////////////////////////////////
	    // Popolamento map copy richiamati con info formattate
	    //////////////////////////////////////////////////////////////////////////
	    		
		// Array con istruzioni di definizione del programma
		ar_entryDataDivision = this.programCobol.entriesData();
		for (i = 0; i < ar_entryDataDivision.length; i++) {
			
			// Next copy/include
		    i = finalPgmWhereUsedGetNextCopyInclude(i);
		    if (i >= ar_entryDataDivision.length) {break;}
		    
		    // Crea struttura in map
			copyName = finalPgmWhereUsedGetGetCopyInclude(i);
			entryDataDivision = this.programCobol.entryDataDivision(i);
			al_dataItemCopy = finalPgmWhereUsedAddCopyToMap(entryDataDivision.getInstruction(), map_copy, copyName);
			
			// Popola map con campi copy 
			for (i = i+1; i < ar_entryDataDivision.length; i++) {
				entryDataDivision = this.programCobol.entryDataDivision(i);
				
				// InstructionCobolDataItem da accodare
				if (entryDataDivision.getInstruction() instanceof InstructionCobolDataItem) {
					dataItem = (InstructionCobolDataItem) entryDataDivision.getInstruction();
					al_dataItemCopy.add(dataItem);
					continue;
				}
				// Copy o include
				if (finalPgmWhereUsedIsCopyInclude(entryDataDivision)) { 
					break;
				}
			}
			
			if (i < ar_entryDataDivision.length) {
				i = i - 1;
			}
			
		} // end-for
	    
		
	    //////////////////////////////////////////////////////////////////////////
	    // Operazioni per ogni copy/include individuato
	    /////////////////////////////////////////////////////////////////////////
	    
		// Scan copy/include
        for (Entry<String, ArrayList<Object[]>> mapCopyEntrySet : map_copy.entrySet()) {
			
        	copyName = mapCopyEntrySet.getKey();
        	al_ar_object = mapCopyEntrySet.getValue();
        	set_sqlNumInstr = new HashSet<Integer>();
        	
        	// Scan copy statement copy name, ovvero tutti gli utilizzi del modulo copy
        	for (Object[] ar_object : al_ar_object) {
				copyStmt = (Instruction) ar_object[0];
				al_dataItemCopy = (ArrayList<InstructionCobolDataItem>) ar_object[1];
				copyObject = (CopyCobol) ar_object[2];
	        	isCopyUsed = isAnyDataItemUsed(al_dataItemCopy);
                if (isCopyUsed) {
     			    // Where used per i data item non modificati da replacing by
    			    for (InstructionCobolDataItem dataItemCopy : al_dataItemCopy) {
    			    	dataItemEntry = this.programCobol.entryDataDivision(dataItemCopy.getNumInstr());
    					
    			    	// Non interessano i data item modificati da replacing by
    			    	if (dataItemEntry.isReplacedBy()) {
    						continue;
    					}
    			    	
    			    	// Gestione inserimento where used data item
     	   			    prepareWhereUsedCopyItemsForDbUpdate(copyName, dataItemCopy, set_sqlNumInstr);
     				}
    		    	// Campi (hostVar) referenziati in input/output in istruzione SQL Select/Insert/delete/update
    		     	// Inseramento relazione ENTITY_COPY per istruzioni referenziate da almeno un campo 
    		    	for (int numInstr : set_sqlNumInstr) {
    		    		entryProcDivision = this.programCobol.entryProcedure(numInstr);
    		    		gestEntityCopyRelation(copyStmt, copyName, numInstr, entryProcDivision);
    				}
 				}
 			}
        }		
    }
    
 	/*
 	 * Inserimento nome copy o include in map
 	 * con strutture per store items
 	 */
	private ArrayList<InstructionCobolDataItem> finalPgmWhereUsedAddCopyToMap(Instruction copyStmt, Map<String,  ArrayList<Object[]>> map_copy, String copyName) {
	   	Object ar_Object[] = null;                                      // Mappato da map copyDetected
 	    ArrayList<InstructionCobolDataItem> al_dataItemCopy = null;     // Data item copy inclusi nel programma
 	  	ArrayList<Object[]> al_ar_object = null;
		
		// Copy o Include statement				
		al_dataItemCopy = new ArrayList<InstructionCobolDataItem>();
		ar_Object = new Object[4];
		ar_Object[0] = copyStmt;
		ar_Object[1] = al_dataItemCopy;
		ar_Object[2] = null;				// CopyCobol
		ar_Object[3] = Boolean.FALSE;
		
		// Creazione map entry se inesistente vuoto
		if (map_copy.get(copyName) == null) {
			al_ar_object = new ArrayList<Object[]>();
			map_copy.put(copyName, al_ar_object);
		}
		
		// Recupero entry map inizializzato o con valori
		al_ar_object =  map_copy.get(copyName);
		al_ar_object.add(ar_Object);
		
		return al_dataItemCopy;
	}


	/*
     * -------------------------------------------------------------------------
     * Recupero successivo copy o include
     * Se space fine
     * -------------------------------------------------------------------------
     */
	private int finalPgmWhereUsedGetNextCopyInclude(int i) {
	   	ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision = null;
       	ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
	    InstructionSql instrSqlPrecompiler = null;
  
        ar_entryDataDivision = this.programCobol.entriesData();
        
        // Scan fino a Copy stmt o Include
		for (; i < ar_entryDataDivision.length; i++) {
			entryDataDivision = this.programCobol.entryDataDivision(i);
			
			// Copy stmt 
			if (entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
				break;
			}
			
			// Sql precompiler
			if (entryDataDivision.getEntryType() == EnumInstrDataCategory.SQL_PRECOMPILER ) {
				instrSqlPrecompiler = (InstructionSql) entryDataDivision.getInstruction();
  				if (instrSqlPrecompiler.getTypeInstrPrecompiler() != EnumPrecompilerReservedWords.SQL_INCLUDE) {
  					continue;
				}
				break;					
			}				
		}
		return i;
	}

	/*
     * -------------------------------------------------------------------------
     * Restituisce il nome del copy o include
      * -------------------------------------------------------------------------
     */
	private String finalPgmWhereUsedGetGetCopyInclude(int i) {
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
	    InstructionCobol copyStmt = null;                               // Istruzione copy
	    InstructionSql instrSqlPrecompiler = null;
	    
		entryDataDivision = this.programCobol.entryDataDivision(i);
	    String copyName = "";	
	    
		// copy stmt 
		if (entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
			copyStmt = (InstructionCobol) entryDataDivision.getInstruction();
			copyName = copyStmt.copyGetName();
		} else {
			instrSqlPrecompiler = (InstructionSql) entryDataDivision.getInstruction();
			copyName = instrSqlPrecompiler.sqlIncludeGetName();		
		}
				
		return copyName;
	 }

	/*
     * -------------------------------------------------------------------------
     * Verifica se entry copy o include
      * -------------------------------------------------------------------------
     */
	private boolean finalPgmWhereUsedIsCopyInclude(ProgramCobolEntry<? extends Instruction> entryDataDivision) {
	    InstructionCobol copyStmt = null;                               // Istruzione copy
	    InstructionSql instrSqlPrecompiler = null;

	    // Copy stmt 
		if (entryDataDivision.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
			return true;
		}

		// Sql precompiler
		if (entryDataDivision.getEntryType() == EnumInstrDataCategory.SQL_PRECOMPILER ) {
			instrSqlPrecompiler = (InstructionSql) entryDataDivision.getInstruction();
			if (instrSqlPrecompiler.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INCLUDE) {
				return true;
			}				
		}				
		return false;
	 }

	/* ----------------------------------------------------------------------------
     * Gestione inserimento Where used nelle strutture di aggiornamento db finali.
     * -----------------------------------------------------------------------------
     * 
     * Se un item del copy referenzia un'istruzione SQL si recupera il nome dell'Entity
     * La relazione ENTITY_COPY viene inserita dopo questa procedure.
     * 
     * Vengono estratti i data item del copy e di ognuno vengono estratti gli utilizzi I/O
     * Per ogni utilizzo del data item fornito viene inserito un oggetto WhereUseItem nel db
     * 
     */
	private void prepareWhereUsedCopyItemsForDbUpdate(String copyName, InstructionCobolDataItem dataItemCopy, Set<Integer> set_sqlNumInstr) {
		ProgramCobolEntry<? extends Instruction> entryProcDivision = null;
		Instruction instr = null;
        EntityWhereUsedItem entityWhereUsed = null;  
        int dataItemPointer = 0;
        int ar_xrefPointer[]; 
        int numInstrProcDiv = 0;
        
        dataItemPointer = dataItemCopy.getNumInstr();
        
    	// Estraggo gli utilizzi in input nel programma
    	ar_xrefPointer = this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_INPUT);
    	  
		// Scan references in input
    	if (ar_xrefPointer != null) {
			for (int xrefInput = 0; xrefInput < ar_xrefPointer.length; xrefInput++) {
                
				// Get instruction with input reference
				numInstrProcDiv = ar_xrefPointer[xrefInput];
				entryProcDivision = this.programCobol.entryProcedure(numInstrProcDiv);
				instr = entryProcDivision.getInstruction();
				
				// Istruzione Sql: relazione ENTITY_COPY da inserire con istruzione origine
				if (entryProcDivision.isInsideInstructionPrecompilerSql()) {
					set_sqlNumInstr.add(numInstrProcDiv);
				}
				
				// Inserimento where used su db abilitato
				if (di.optWhereUsedCopyItemsOnDbToInsert) {
					entityWhereUsed = new EntityWhereUsedItem();
					
					// Key
					entityWhereUsed.setSystem(this.di.systemInput);
					entityWhereUsed.setSubSystem(this.di.subSystemInput);
					entityWhereUsed.setIdObject(copyName);
					entityWhereUsed.setTypeObject(EnumObject.OBJECT_COPY_COBOL_DATA);
					entityWhereUsed.setIdField(dataItemCopy.getDataName());
					entityWhereUsed.setNumSeq(0);
					entityWhereUsed.setIdObjectRefer(this.programCobol.getProgramName());
					entityWhereUsed.setTypeObjectRefer(EnumObject.OBJECT_PGM_COBOL);
					entityWhereUsed.setNumInstrRefer(ar_xrefPointer[xrefInput]);

					// Data
					entityWhereUsed.setRowStart(instr.getRowStartSource());
					entityWhereUsed.setRowEnd(instr.getRowEndSource());
					entityWhereUsed.setIdObjectCopy(entryProcDivision.getUnderCopyName());
					entityWhereUsed.setRowStartInCopy(0);
					entityWhereUsed.setRowEndInCopy(0);
					entityWhereUsed.setIdAliasLocal("");
					entityWhereUsed.setIdIoarea("");
					entityWhereUsed.setIdAliasLocal("");
					entityWhereUsed.setIdObjectCopy("");
					entityWhereUsed.setTypeWhereUsed(EnumWhereUsedType.WHERE_USED_INPUT);
					entityWhereUsed.setTypeAlias(EnumWhereUsedTypeAlias.ALIAS_FULL_MATCH);
					entityWhereUsed.setPosInIoarea(0);
					entityWhereUsed.setUsedBytes(0);
					entityWhereUsed.setNumInt(0);
					entityWhereUsed.setNumDec(0);
					entityWhereUsed.setSigned(false);
					entityWhereUsed.setInstrLang(EnumLanguageItemInstr.ITEM_COBOL);
					entityWhereUsed.setInstrType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
					this.analyzerDbInfo.addObjEntityWhereUsed(entityWhereUsed);				
				}
			} // end-for
		}
    	
		// Estraggo gli utilizzi in output nel programma
    	ar_xrefPointer = this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_OUTPUT);
    	
		// Scan references in output
    	if (ar_xrefPointer != null) {
			for (int xrefOutput = 0; xrefOutput < ar_xrefPointer.length; xrefOutput++) {

				// Get instruction with input reference
				numInstrProcDiv = ar_xrefPointer[xrefOutput];
				entryProcDivision = this.programCobol.entryProcedure(numInstrProcDiv);
				instr = entryProcDivision.getInstruction();

				// Istruzione Sql: relazione ENTITY_COPY da inserire 
				if (entryProcDivision.isInsideInstructionPrecompilerSql()) {
					set_sqlNumInstr.add(numInstrProcDiv);
				}
				
				// Inserimento where used su db abilitato
				if (di.optWhereUsedCopyItemsOnDbToInsert) {
					entityWhereUsed = new EntityWhereUsedItem();
					
					// Key
					entityWhereUsed.setSystem(this.di.systemInput);
					entityWhereUsed.setSubSystem(this.di.subSystemInput);
					entityWhereUsed.setIdObject(copyName);
					entityWhereUsed.setTypeObject(EnumObject.OBJECT_COPY_COBOL_DATA);
					entityWhereUsed.setIdField(dataItemCopy.getDataName());
					entityWhereUsed.setNumSeq(0);
					entityWhereUsed.setIdObjectRefer(this.pgmNameUnderParsing);
					entityWhereUsed.setTypeObjectRefer(EnumObject.OBJECT_PGM_COBOL);
					entityWhereUsed.setNumInstrRefer(ar_xrefPointer[xrefOutput]);

					// Data
					entityWhereUsed.setRowStart(instr.getRowStartSource());
					entityWhereUsed.setRowEnd(instr.getRowEndSource());
					entityWhereUsed.setIdObjectCopy(entryProcDivision.getUnderCopyName());
					entityWhereUsed.setRowStartInCopy(0);
					entityWhereUsed.setRowEndInCopy(0);
					entityWhereUsed.setIdAliasLocal("");
					entityWhereUsed.setIdIoarea("");
					entityWhereUsed.setIdObjectCopy("");
					entityWhereUsed.setTypeWhereUsed(EnumWhereUsedType.WHERE_USED_OUTPUT);
					entityWhereUsed.setTypeAlias(EnumWhereUsedTypeAlias.ALIAS_FULL_MATCH);
					entityWhereUsed.setPosInIoarea(0);
					entityWhereUsed.setUsedBytes(0);
					entityWhereUsed.setNumInt(0);
					entityWhereUsed.setNumDec(0);
					entityWhereUsed.setSigned(false);
					entityWhereUsed.setInstrLang(EnumLanguageItemInstr.ITEM_COBOL);
					entityWhereUsed.setInstrType(EnumPrecompilerReservedWords.NOT_ASSIGNED);
					this.analyzerDbInfo.addObjEntityWhereUsed(entityWhereUsed);						
				}
	
			} // end-for
   		
    	}
  		
        return;
	}

  
    /*
     * Gestione inserimento relazioni ENTITY_COPY se istruzione SQL
     */
	private void gestEntityCopyRelation(Instruction copyStmt, String copyName, int numInstrProcDiv, ProgramCobolEntry<? extends Instruction> entryProcDivision) {
		
		InstructionSql instrSql = null;
		SqlSelectStatement sqlSelect = null;
		SqlInsertStatement sqlInsert = null;
		SqlDeleteStatement sqlDelete = null;
		SqlUpdateStatement sqlUpdate = null;
		SqlDeclareCursorStatement sqlDeclareCursor = null;
		ArrayList<SqlTableDeclared> al_entity = null;
		ArrayList<ArrayList<String>> al_column = null;
		String entityName = "";
		
		// Non è una istruzione Sql
		if (!entryProcDivision.isInsideInstructionPrecompilerSql()) {
			return;
		}
		
		// Istruzione Sql, estrazione nomi tabelle coinvolte
		instrSql = (InstructionSql) entryProcDivision.getInstruction();
		if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_SELECT) {
			sqlSelect = instrSql.sqlSelectGetDescriptor();		
			al_entity = sqlSelect.getEntitiesDeclared();
		} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DELETE) {
			sqlDelete = instrSql.sqlDeleteGetDescriptor();		
			al_entity = sqlDelete.getEntitiesDeclared();
		} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_UPDATE) {
			sqlUpdate = instrSql.sqlUpdateGetDescriptor();		
			al_entity = sqlUpdate.getEntitiesDeclared();
		} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_INSERT) {
			sqlInsert = instrSql.sqlInsertGetDescriptor();		
			al_entity = sqlInsert.getEntitiesDeclared();
		} else if (instrSql.getTypeInstrPrecompiler() == EnumPrecompilerReservedWords.SQL_DECLARE_CURSOR) {
			sqlDeclareCursor = instrSql.sqlDeclareCursorGetDescriptor();
			sqlSelect = sqlDeclareCursor.getSelectStatement();
			al_entity = sqlSelect.getEntitiesDeclared();	
		} else {
			// Eventuale altra istruzione Sql non gestita
			return;			
		}			
	 	
		// Scan entities
		for (SqlTableDeclared table : al_entity) {
			entityName = table.getTableName();
			
			sqlInsDeleteRelationAndOriginAndOption(entityName, EnumObject.OBJECT_ENTITY_SQL, false);
			
			this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
			     			EnumObject.OBJECT_ENTITY_SQL
						  , entityName
						  , EnumObject.OBJECT_COPY_COBOL_DATA
					  	  , copyName
						  , EnumObjectStatus.OBJECT_TO_BE_ANALYZED
						  , EnumRelation.ENTITY_COPY              
						  , EnumRelationSourceProcess.SOURCE_STATIC_LOCAL
						  , this.programName
						  , copyStmt.getNumInstr()
						  , copyStmt.getRowStartSource()
						  , copyStmt.getRowEndSource()
						  , ""
						  , 0
						  , 0
						  , EnumInstrDataCategory.SQL_PRECOMPILER
						  , EnumCobolReservedWords.DATA_DIVISION
						  , false
						  , false
						  , false
						  , this.di.userExitInfoPgm
				   );			
		}
			
		return;
	}


	/*
	 * 
	 * Impostazione divisioni, sezioni e aree di programma attive
	 * 
	 */
	private void setActiveDivisionSectionAreas(InnerContextAnalysis ictx) {
		
		// Divisione attiva
		if (ictx.activeTypeInstr == EnumCobolReservedWords.ID_DIVISION
	    || 	ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIVISION	
	    || 	ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIVISION	
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.PROC_DIVISION) {
  	        this.activeDivisionArea = ictx.activeTypeInstr;
  	        this.analyzerCics.setActiveDivisionArea(this.activeDivisionArea);
  	        this.di.curCobolDivision = this.activeDivisionArea;			// Disponibile in caso di exception
  	        return;
		}
		
		// Sezione attiva
		    
		if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_WS_SECTION
		||  ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_FILE_SECTION
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
	    || 	ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_COMM_SECTION
	    || 	ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_REPORT_SECTION
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_SCREEN_SECTION
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_CONF_SECTION
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_I_O_SECTION) {
  	        this.activeSectionArea = ictx.activeTypeInstr;
  	        // Cobol MF accetta sezioni senza dichiarazione di division precedente
  	        if (ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_CONF_SECTION
  	        ||  ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_I_O_SECTION) {
  	        	ictx.isEnvDivisionMissing = true;
  	        	this.activeDivisionArea = EnumCobolReservedWords.ENV_DIVISION;
			}
  	        if ( this.activeDivisionArea != EnumCobolReservedWords.DATA_DIVISION) {
  	  	        if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION
  	  	  	    	||  ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_WS_SECTION
  	  	  	    	||  ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_FILE_SECTION) {
  	  	        	    ictx.isDataDivisionMissing = true;
 	  	  	    	    this.activeDivisionArea = EnumCobolReservedWords.DATA_DIVISION;
  	  	  	  	    }
			}
  	        // Info di controllo
  	        if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_WS_SECTION) {
				this.programCobol.setNumInstrWsStorageSection(this.curNumDefDataDiv);
				this.programCobol.setWsStorageSection(true);
			}
  	        if (ictx.activeTypeInstr == EnumCobolReservedWords.DATA_DIV_LINKAGE_SECTION) {
				this.programCobol.setNumInstrWsStorageSection(this.curNumDefDataDiv);
				this.programCobol.setLinkageSection(true);
			}
   	        // Info disponibili in caso di exceptio
  	        this.di.curCobolDivision = this.activeDivisionArea;			// Disponibile in caso di exception
 	        this.di.curCobolSection = this.activeSectionArea;			// Disponibile in caso di exception
   	        return;
		} 
		
		// Area controllo attiva
		if (ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_FILE_CONTROL
		|| 	ictx.activeTypeInstr == EnumCobolReservedWords.ENV_DIV_I_O_CONTROL) {
  	        this.activeControlArea = ictx.activeTypeInstr;
  	        return;
		}
	}




	
	/*
     * ---------------------------------------
     * Gestione soluzione Call/Cancel dinamica 
     * ---------------------------------------
     * 
     * NON si considerano operandi statici (literal) ma solo dinamici.
     * Questo metodo viene attivato a fronte dell'analisi preliminare del programma
     * oppure a fronte del processo di attivazione della logica  "spreaded" fra programmi diversi.
     * Nel primo caso il tentativo di soluzione dell'istruzione è circoscritta al programma
     * corrente, nel secondo caso la soluzione è estessa alle catene dei programmi chiamanti/chiamati.
     * 
     * @param InstructionCobolProcedure instrDynamic
     * @param int typeLogicDynamic     LOGIC_DYNAMIC_SAME_PGM, LOGIC_DYNAMIC_SPREADED_PGM
     * 
     */
	private void solveInstructionsDynamicCallCancel(InstructionCobolProcedure instruction  	    // Istruzione da risolvere
		                        	              , int typeLogicDynamic	    			    // LOGIC_DYNAMIC_SAME_PGM, LOGIC_DYNAMIC_SPREADED_PGM
			                                      , EnumRelation relationType                   // PGM_CALLED_PGM , PGM_CANCEL_PGM
		                                         	) throws ExceptionAmrita, SQLException {

		LogicDynamicInstruction logicDynamicInstr = null;                       // Codifica istruzione dinamica per risoluzione valori
		EntityObject eo = null;      
		EntityDynamicFieldSubValue edfsv = null;
 		ArrayList<String> al_Program = null;  									// Valori estratti per Program
		ArrayList<DataItemCobolIdentifier> al_identifierProgramName = null;   	// Identificatori programi, da analisi preliminare
		EnumRelationSourceProcess relationSourceProcess = null;					// Processo sorgente
		String pgmName = "";                                    				// Nome programma 
		String idField = "";
		boolean isPgmFieldReferencedOutput = false;             				// True indica assegnazione del campo dinamico con il nome del programma
		int numInstr = 0;                                       				// Numero istruzione


		// Recupero descrittori completi campi nome programma, impostato in analisi preliminare sorgente
		al_identifierProgramName = instruction.callCancelGetPgmFieldIdentifiers();

		// In fase di analisi programma si risolvono solo istruzioni dinamiche nello stesso programma
		// Le logiche di tipo spreaded vengono risolte da apposita funzione
		
		// Individuazione generalizzata valori dinamici assunti dai campi programName
		for (DataItemCobolIdentifier identifierProgramName : al_identifierProgramName) {

			relationSourceProcess = EnumRelationSourceProcess.SOURCE_DYNAMIC_LOCAL;
			isPgmFieldReferencedOutput=this.programCobol.isSymboltXrefOutProc(identifierProgramName.getNameIdentifier());
			
			// Campo LITERAL: no operation in quanto già risolto dopo il parsing istruzione
			if (identifierProgramName.getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_ALPHA) {
				continue;
			}
			
			// Dynamic spreaded
			if (typeLogicDynamic == LOGIC_DYNAMIC_SPREADED_PGM) {
				relationSourceProcess = EnumRelationSourceProcess.SOURCE_DYNAMIC_SPREADED;
			}

			instruction.setDynamic(true);

			
			// (1)  Nome programma espresso da campo dinamico NON movimentato con VALUE 
			// Si attiva comunque la soluzione dinamica per memorizzare le strutture su database
			if (this.di.optSolveDynamicLocal
			&&  typeLogicDynamic == LOGIC_DYNAMIC_SAME_PGM
		    && !isPgmFieldReferencedOutput 
		    && identifierProgramName.getDataItem().isValueClause()) {
				
				instruction.setDynamicLight(true);
				instruction.setDynamicSolved(true);
				instruction.setDynamicSolvedFull(true);		
				// Tentativo di estrazione valori dinamici nello stesso programma
				al_Program = this.logicSamePgm.dynamicValues(this.programCobol, instruction, identifierProgramName);
				// Impostazioni per LogicInfoDynamic 
	            logicDynamicInstr = this.logicInfoDynamic.getDynamicInstr(instruction.getNumInstr());
				if (logicDynamicInstr == null) {
					logicDynamicInstr = new LogicDynamicInstruction();
					logicDynamicInstr.programName = this.programCobol.getProgramName();
					logicDynamicInstr.setDynamicInstr(instruction);
				}
				logicDynamicInstr.al_dynamicField.add(this.logicSamePgm.getDynamicFieldToSolve());
				
				instruction.setDynamicSolved(true);
				instruction.setDynamicSolvedFull(true);
				
			// (2) Nome programma espresso da campo dinamico da risolvere localmente nel programma 		    				
			} else if ((this.di.optSolveDynamicLocal)
					&&  typeLogicDynamic == LOGIC_DYNAMIC_SAME_PGM) {	
				
				// Tentativo di estrazione valori dinamici nello stesso programma
				al_Program = this.logicSamePgm.dynamicValues(this.programCobol, instruction, identifierProgramName);                
				
				// Impostazioni per LogicInfoDynamic 
	            logicDynamicInstr = this.logicInfoDynamic.getDynamicInstr(instruction.getNumInstr());
				if (logicDynamicInstr == null) {
					logicDynamicInstr = new LogicDynamicInstruction();
					logicDynamicInstr.programName = this.programCobol.getProgramName();
					logicDynamicInstr.setDynamicInstr(instruction);
				}
				logicDynamicInstr.al_dynamicField.add(this.logicSamePgm.getDynamicFieldToSolve());				
				// Accodamento istruzione dinamica in struttura associata al programma
				this.logicInfoDynamic.addDynamicInstr(instruction, logicDynamicInstr);	
				
				// Istruzione con codice dinamico risolta o meno
				if (al_Program.size() > 0) {
					// Individuati dei valori, default e/o assegnazioni
					instruction.setDynamicSolved(true);
					// Si aspettano dati esterni o impostati da pgm chiamanti
					if (instruction.isDynamicSpreaded() || instruction.isDynamicWaitingForData()) {
						instruction.setDynamicSolvedFull(false);
					}					
				}				

			// (3) Nome programma espresso da campo dinamico da NON risolvere in questa elaborazione 		    
			} else if ((this.di.optSolveDynamicLocal == false
					&&  typeLogicDynamic == LOGIC_DYNAMIC_SAME_PGM
					&&  isPgmFieldReferencedOutput)) {
				al_Program = new ArrayList<String>();

			// (4) Nome programma espresso da campo dinamico da risolvere esternamente nel programma 
			// L'istruzione è stata marcata dynamic spreaded in una precedente elaborazione
			// ed è già presente nel descrittore istruzioni dinamiche in LogicInfoDynamic
			} else if (this.di.optSolveDynamicSpreaded
				   &&  typeLogicDynamic == LOGIC_DYNAMIC_SPREADED_PGM
				   &&  (instruction.isDynamicSpreaded() || instruction.isDynamicWaitingForData())) {
				
				// Tentativo di estrazione valori dinamici nei programmi chiamanti
				// Con impostazione stato soluzione istruzione
				al_Program = this.logicSpreadedPgm.dynamicValues(this.programCobol, instruction, identifierProgramName);
				logicDynamicInstr = this.logicInfoDynamic.getDynamicInstr(instruction.getNumInstr());
				
				// Istruzione con codice dinamico risolta o meno
				if (al_Program.size() > 0) {
					// Individuati dei valori, default e/o assegnazioni
					instruction.setDynamicSolved(true);
					instruction.setDynamicSolvedFull(true);
				} else {
					instruction.setDynamicSolvedFull(false);
				}			

				// Campo dinamico senza valori
			} else {
				al_Program = new ArrayList<String>(); 
			}
							
			// Inserimento in map descriptor istruzione valori trovati per ogni l'operando dinamico in Call/Cancel
			instruction.setDynamicOperandValues(identifierProgramName.getNameIdentifier(), al_Program);
			numInstr = instruction.getNumInstr();

			// Scan nomi programma individuati in stesso programma o programmi chiamanti/chiamati 
			for (String programNameCalled : al_Program) {
                
				// Recupera inserisce in struttura da sysSubSys corr/Owner/New
				eo=this.analyzerDbInfo.getAddObjectEntitled(programNameCalled, EnumObject.OBJECT_PGM_COBOL);
				
				// Inserimento Oggetto programma chiamato, relazione, option PGM_WITH_DYNAMIC_CODE
				this.analyzerDbInfo.prepareForDbObjectRelatedToAny(
						EnumObject.OBJECT_PGM_COBOL
						, this.programName
						, EnumObject.OBJECT_PGM_COBOL
						, programNameCalled
						, EnumObjectStatus.OBJECT_TO_BE_ANALYZED
						, relationType                          // PGM_CALLED_PGM , PGM_CANCEL_PGM
						, relationSourceProcess
						, this.programName
						, numInstr
					    , instruction.getRowStartSource()
						, instruction.getRowEndSource()
						, ""
						, 0
						, 0
						, instruction.getTypeInstrCategory()
						, this.activeDivisionArea
						, false
						, false
						, identifierProgramName.getIdentifierType() != EnumCobolReservedWords.OPERAND_LITERAL_ALPHA        // true = dynamic  
						, this.di.userExitInfoPgm
						);
				 
			} // end-for pgms

		} // end-for identifier
				
		
		// Aggiornamento strutture dinamiche per update db finale, inclusi flag in istruzione
	    this.logicInfoDynamic.putDatabaseInfoAll(this.analyzerDbInfo, logicDynamicInstr, al_identifierProgramName.get(0).getDataItem().getDataName());		 
        
	    // Solo se attivazione a fronte di logiche dinamiche spreaded con 
	    if (typeLogicDynamic == LOGIC_DYNAMIC_SPREADED_PGM) {
	    	// Scan options
			for (int i = 0; i < this.analyzerDbInfo.al_DbObjectOption.size(); i++) {
				// Remove option
				if (this.analyzerDbInfo.al_DbObjectOption.get(i).getOption() == EnumObjectOption.PGM_WITH_DYNAMIC_CODE) {
					if (this.analyzerDbInfo.isThereObjectOption(programCobol.sysOwner, programCobol.subSysOwner, EnumObject.OBJECT_PGM_COBOL, programCobol.programName, EnumObjectOption.PGM_WITH_DYNAMIC_CODE)) {
						this.analyzerDbInfo.al_DbObjectOption.remove(i);
						break;
					}					
				}
			}
		}
		return;
	}

	/*
	 * 
	 * Estrazione dei qualificatori di utilizzo.
	 * Viene aggiornando l'oggetto DataItemQualifier qualifier.
	 * 
	 * Sono presenti due ArrayList vuoti o con i token interni
	 * ai qualificatori di indici e ref mod.
	 * 
	 * 1) (index1 espr, index2 expr,...)
	 * 2) (index1 expr, index2 expr,...)(pos:lng)
	 * 3) (index1 expr, index2 expr,...)(pos:)
	 * 4) (pos:lng)
	 * 5) (special register: special register)
	 * 
	 */
	private void extractQualifiers(Instruction instruction
								 , ArrayList<String > al_tokenQualifierIdx
								 , ArrayList<String > al_tokenQualifierRefMod
								 , DataItemQualifier qualifier
								   ) {
        
		ExceptionAmrita excp = null;
		ArrayList<ExpressionCobol> al_index = null;
		ExpressionCobol ar_index[] = null;
		ExpressionCobol index = null;
		ExpressionCobol posRefMod = null;
		ExpressionCobol lengthRefMod = null;
        String token = "";
        String joinedTokens = "";
        int iDuePunti = 0;;
        
        
        al_index = new  ArrayList<ExpressionCobol> ();
         
        // Scan indici (i1, i2+6, ...) separati da virgola
        for (int i = 0; i < al_tokenQualifierIdx.size(); i++) {
         	        	
         	// Scan token indice corrente
        	joinedTokens = "";
        	while (i < al_tokenQualifierIdx.size() && !al_tokenQualifierIdx.get(i).equals(",")) {
        		token = al_tokenQualifierIdx.get(i);
        		joinedTokens = joinedTokens + token + " ";
        		i++;
			}
 			
        	// Composizione generalizzata espressione indice
        	index = extractExpression(instruction, joinedTokens);
        	if (instruction.isParsingError()) {
				return;
			}
			al_index.add(index);
        	
		} // end-for
        
        // Inserimento indici codificati nel qualificatore
        ar_index = new ExpressionCobol[al_index.size()];
        ar_index = al_index.toArray(ar_index);
        qualifier.setIndexes(ar_index);
        
        
        // No reference modification: exit
        if (al_tokenQualifierRefMod.size() == 0) {
			return;
		}
 
        qualifier.setRefModification(true);
        
        
        // Pos espresso come qualsiasi espressione valida
        
        // Find :
        for (iDuePunti = 0; iDuePunti < al_tokenQualifierRefMod.size(); iDuePunti++) {
			if (al_tokenQualifierRefMod.get(iDuePunti).equals(":")) {
				break;
			}
		} // end-for
        
        // : non trovati in ref mod: parsing error
        if (iDuePunti >= al_tokenQualifierRefMod.size()) {
        	excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0043", token, excp, this.programName);
			instruction.setParsingError(true);
        	return;
		}
        
        // Espressione posizione di reference modification (pos:lng) solo se c'è
        if (iDuePunti > 0) {
 
        	// Scan Token dalla posizione dopo fino ai due punti esclusi
        	joinedTokens = "";
        	for (int i = 0; i < iDuePunti; i++) {
        		token = al_tokenQualifierRefMod.get(i);
        		joinedTokens = joinedTokens + token + " ";
			}
        	// Composizione generalizzata espressione reference modification pos
            posRefMod = extractExpression(instruction, joinedTokens);
            if (instruction.isParsingError()) {
    			return;
    		}
		} else {
			posRefMod = new ExpressionCobol();
		}
        
        // Espressione lunghezza di reference modification (pos:lng) solo se c'è
        if (iDuePunti < al_tokenQualifierRefMod.size() - 1 ) {
        	
        	// Scan Token dalla posizione dopo i due punti
        	joinedTokens = "";
        	for (int i = iDuePunti + 1; i < al_tokenQualifierRefMod.size(); i++) {
        		token = al_tokenQualifierRefMod.get(i);
        		joinedTokens = joinedTokens + token + " ";
			}
        	// Composizione generalizzata espressione reference modification length
            lengthRefMod = extractExpression(instruction, joinedTokens);
           	if (instruction.isParsingError()) {
    			return;
    		}
		} else {
			lengthRefMod = new ExpressionCobol();
		}
        
        // Caricamento espresioni posizione e lunghezza in qualifier
        qualifier.setPos(posRefMod);
        qualifier.setLength(lengthRefMod);
  	}
	/*
	 * ------------------------------------------------------------
	 * Restituisce un oggetto ExpressionCobol da una stringa.<br>
	 * ------------------------------------------------------------
	 * <p>
	 * Il metodo viene richiamato a fronte di If, Compute, Evaluate, When, Perform
	 * per restituire l'espressione di condizione o di assegnazione.<br>
	 * Il metodo viene anche richiamato per estrarre le espressioni di reference modification
	 * degli identificatori (extractIdentifiers()-> extractQualifiers()-> extractExpression())
	 * <p>
	 * L'oggetto ExpressionCobol modella un insieme di oggetti ExpressionCobolElement che possono
	 * essere operatori (aritmetici/logici o operandi data item/Costanti figurative/registri speciali
	 * 
	 * 
	 */
	private ExpressionCobol extractExpression(Instruction instruction, String strInput)  {
		
		ExceptionAmrita excp = null;
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;  // Mapping parola riservata Cobol
		ArrayList<DataItemCobolIdentifier> al_identifier = null;  		    // ArrayList con identificatore estratto
		DataItemCobolIdentifier identifier = null;  		    			// Identificatore
		ExpressionCobol expression = null;
		ExpressionCobolElement expressionElement = null;
		LiteralCobol literalCobol = null;
		String str = "";
		String strIdentifier = "";
		StringBuffer token = null;
		EnumCobolReservedWords reserverWord = null;
		int i = 0;
		int j = 0;
		int iStartToken = 0;  
		int iEndIdentifier = 0;												// Fine identificatore
		int cntParOpen = 0;													// 
		
		expression = new ExpressionCobol();
		     
		// Per corretto trattamento literal come token atomico
		str = replaceSpaceInLiteralWithUnderscore(instruction, strInput);
 		if (instruction.isParsingError()) {  // Literal non chiuse dentro l'espressione
			return expression;
		} 
      
        // Inserisce space fra operatori e divide eventualmente parole con -, quando è un operatore matematico
		str = normalizeIdentifiers(instruction, str);
        if (instruction.isParsingError()) {   // Parsing error identificatore/i
			return expression;    
		}
  
        literalCobol = new LiteralCobol();
        
        // Scan stringa in input
		for (i = 0; i < str.length(); i++) {
			
			iStartToken = i;
			token = new StringBuffer();
			
			// Scan fino al primo space o a fine stringa
			for (i = iStartToken; i < str.length(); i++) {
				if (str.charAt(i) == ' ') {
					break;
				}  
				token.append(str.charAt(i));
			}  
				   
			// Operatori ridondanti sicuramente da scartare (Es. in IF campo IS EQUAL TO o campo GREATER THAN)
		    if (token.toString().equals("IS")
		    ||  token.toString().equals("TO")
		    ||  token.toString().equals("THAN")) {
		    	i = extractExpressionBypassSpaces(str, i);
			    continue;
		    }
			
			// Verifica se token parola riservata Cobol
			al_reservedWordEntry = map_ReservedWords.get(token.toString());
			  
			// Data item: estraggo qualificatore completo, campo, special register, literal o figurative
			if (al_reservedWordEntry == null) {
				
				// Literal numerica o alfanumerica
				iEndIdentifier = literalCobol.parseLiteral(token + " ", 0);  
				if (iEndIdentifier > 0) {
					strIdentifier = token + " ";
				// Identificatore cobol qualificato o meno
				} else {
					iEndIdentifier = extractExpressionGetEndQualifier(str, i);
					strIdentifier = token + " " + str.substring(i, iEndIdentifier + 1);
					i = iEndIdentifier + 1;
				}  
				// Estrazione e validazione standard identificatore
				al_identifier = extractIdentifiers(instruction, strIdentifier.trim());
				if (instruction.isParsingError() || instruction.isSemanticError()) {
					return expression;
				}  
				// Store come elemento dell'espressione
				identifier = al_identifier.get(0);
				reserverWord = identifier.getIdentifierType();
				expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
				expression.addElement(expressionElement);
				i = extractExpressionBypassSpaces(str, i);
				continue;
			}

			// Il token è una parola riservata cobol   
			
			reserverWord = al_reservedWordEntry.get(0).en_WordReservedOwner;
			
			// Funzione intrinseca.
			if (reserverWord.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
		    	j = str.indexOf("(", i);   
		    	cntParOpen = 1;
				// Ricerca ultima parentesi chiusa, fine specification function
				for (j = j + 1; j < str.length(); j++) {
					if (str.charAt(j) == ')') {cntParOpen--;}
					if (str.charAt(j) == '(') {cntParOpen++;}
					if (cntParOpen == 0){break;}
				}
                // Function malformata   
				if (cntParOpen != 0) {
	   				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
    				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0032", token.toString(), excp, this.programName, "");
    	 			instruction.setParsingError(true);
					return expression;
				}   
				i = extractExpressionBypassSpaces(str, i);
                if (j >= str.length()) {j = str.length() - 1;}
	     		// Individuazione fine qualificatore ref mod, se presente
				iEndIdentifier = extractExpressionGetEndQualifier(str, j);
				// Estrazione identificatore completo Function + eventuale ref mod in coda
				strIdentifier = str.substring(iStartToken, iEndIdentifier + 1);
				al_identifier = extractIdentifiers(instruction, strIdentifier);
				if (instruction.isParsingError()) {
					return expression;
				} 
				identifier = al_identifier.get(0);
		    	expressionElement = new ExpressionCobolElement(reserverWord, identifier.getNameIdentifier(), identifier);
		    	expression.addElement(expressionElement);
		    	i = iEndIdentifier + 1;
				i = extractExpressionBypassSpaces(str, i);
				continue;
		    	
			}
		
			// Non è una funzione intrinseca.
            // Se ci sono più combinazioni che iniziano con il token, cerco quella di una sola parola (come NOT)
			if (reserverWord.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
				if (al_reservedWordEntry.size() > 1) {
					for (InnerInstructionWordsEntry reservedWordEntry : al_reservedWordEntry) {
						if (reservedWordEntry.al_wordKey.size() == 1) {
							reserverWord = reservedWordEntry.en_WordReservedOwner;
							break;
						}
					}
				}
			}
			
			// Operatore Or, And, Not, +, -,. ...
			// Costante figurativa 
		    if (reserverWord.getCobolSymbolType()  == EnumSymbolType.COBOL_SYMBOL_OPERATOR
		    ||  reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_FIGURATIVE) {
		    	identifier = new DataItemCobolIdentifier();
		    	identifier.setIdentifierType(reserverWord);
		    	identifier.setNameIdentifier(token.toString());
		    	expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
		    	expression.addElement(expressionElement);
				i = extractExpressionBypassSpaces(str, i);
		    	continue;
		    }
			
		    // Special register length of e address of
		    if (reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER
		    && (reserverWord == EnumCobolReservedWords.REGISTER_LENGTH_OF 	|| 
		    	reserverWord == EnumCobolReservedWords.REGISTER_ADDRESS_OF )
		       ) {
		    	j = str.indexOf("OF", i);
				// Cerco primo carattere diverso da space
				for (j = j + 2 ; j < str.length(); j++) {
					if (str.charAt(j) != ' ') {
						break;
					}
				}
				// Cerco primo carattere = space dopo nome campo
				for (; j < str.length(); j++) {
					if (str.charAt(j) == ' ') {
						break;
					}
				}
				iEndIdentifier = extractExpressionGetEndQualifier(str, j);
				strIdentifier = str.substring(iStartToken, j ) + " " + str.substring(j, iEndIdentifier + 1);
				al_identifier = extractIdentifiers(instruction, strIdentifier);
				if (instruction.isParsingError()) {
					return expression;
				}
				identifier = al_identifier.get(0);
		    	expressionElement = new ExpressionCobolElement(reserverWord, identifier.getNameIdentifier(), identifier);
		    	expression.addElement(expressionElement);
		    	i = iEndIdentifier + 1;
				i = extractExpressionBypassSpaces(str, i);
				continue;
			}
		    
			// Special register atomico
		    if (reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER) {
		    	identifier = new DataItemCobolIdentifier();
		    	identifier.setIdentifierType(reserverWord);
		    	identifier.setNameIdentifier(token.toString());
		    	expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
		    	expression.addElement(expressionElement);
				i = extractExpressionBypassSpaces(str, i);
		    	continue;
			}
		    
		}
		
		return expression;
	}


    /*
     * Bypass spaces
     * 
     */
	private int extractExpressionBypassSpaces(String str, int iStart) {
		int i;
		i = iStart;
		
		// Bypass spaces
		for (; i < str.length(); i++) {   
			if (str.charAt(i) != ' ') {
				i--;
				break;
			}
		}
		return i;
	}


	/*
	 * ------------------------------------------------------------
	 * Restituisce un oggetto ExpressionCobol da una stringa.<br>
	 * 
	 * N.B. In rifacimento di extractExpression
	 * ------------------------------------------------------------
	 * <p>
	 * Il metodo viene richiamato a fronte di If, Compute, Evaluate, When, Perform
	 * per restituire l'espressione di condizione o di assegnazione.<br>
	 * Il metodo viene anche richiamato per estrarre le espressioni di reference modification
	 * degli identificatori (extractIdentifiers()-> extractQualifiers()-> extractExpression())
	 * <p>
	 * L'oggetto ExpressionCobol modella un insieme di oggetti ExpressionCobolElement che possono
	 * essere operatori (aritmetici/logici o operandi data item/Costanti figurative/registri speciali
	 * 
	 * 
	 */
	@SuppressWarnings("unused")
	private ExpressionCobol extractExpression2(Instruction instruction, String strInput)  {
		
		Scanner scn = null;
		ExceptionAmrita excp = null;
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;  // Mapping parola riservata Cobol
		ArrayList<DataItemCobolIdentifier> al_identifier = null;  		    // ArrayList con identificatore estratto
		DataItemCobolIdentifier identifier = null;  		    			// Identificatore
		ExpressionCobol expression = null;
		ExpressionCobolElement expressionElement = null;
		LiteralCobol literalCobol = null;
		String str = "";
		String strIdentifier = "";
		String token = null;
		EnumCobolReservedWords reserverWord = null;
		int i = 0;
		int j = 0;
		int iStartToken = 0;  
		int iEndIdentifier = 0;												// Fine identificatore
		int cntParOpen = 0;													// 
		
		expression = new ExpressionCobol();
		     
		// Per corretto trattamento literal come token atomico
		str = replaceSpaceInLiteralWithUnderscore(instruction, strInput);
 		if (instruction.isParsingError()) {  // Literal non chiuse dentro l'espressione
			return expression;
		} 
      
        // Inserisce space fra operatori e divide eventualmente parole con -, quando è un operatore matematico
		str = normalizeIdentifiers(instruction, str);
        if (instruction.isParsingError()) {   // Parsing error identificatore/i
			return expression;    
		}
  
        literalCobol = new LiteralCobol();
        scn = new Scanner(str);
        token = nextToken(scn);
        
        // Scan stringa in input
		while (!token.equals("")) {
			
			// Operatori ridondanti sicuramente da scartare (Es. in IF campo IS EQUAL TO o campo GREATER THAN)
		    if (token.equals("IS")
		    ||  token.equals("TO")
		    ||  token.equals("THAN")) {
		    	token = nextToken(scn);
			    continue;
		    }
			
			// Verifica se token parola riservata Cobol
			al_reservedWordEntry = map_ReservedWords.get(token);
			  
			// Data item: estraggo qualificatore completo, campo, special register, literal o figurative
			if (al_reservedWordEntry == null) {
				// Literal numerica o alfanumerica
				iEndIdentifier = literalCobol.parseLiteral(token + " ", 0);  
				if (iEndIdentifier > 0) {
					strIdentifier = token + " ";
					iEndIdentifier--;
				// Identificatore cobol qualificato o meno
				} else {
					iEndIdentifier = extractExpressionGetEndQualifier(str, i);
					strIdentifier = token + " " + str.substring(i, iEndIdentifier + 1);
				}  
				// Estrazione e validazione standard identificatore
				al_identifier = extractIdentifiers(instruction, strIdentifier.trim());
				if (instruction.isParsingError() || instruction.isSemanticError()) {
					return expression;
				}  
				// Store come elemento dell'espressione
				identifier = al_identifier.get(0);
				reserverWord = identifier.getIdentifierType();
				expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
				expression.addElement(expressionElement);
				// Bypass spaces
				for (; i < str.length(); i++) {   
					if (str.charAt(i) != ' ') {
						i--;
						break;
					}
				}
				continue;
			}

			// Il token è una parola riservata cobol   
			
			reserverWord = al_reservedWordEntry.get(0).en_WordReservedOwner;
			
			// Funzione intrinseca.
			if (reserverWord.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
		    	j = str.indexOf("(", i);   
		    	cntParOpen = 1;
				// Ricerca ultima parentesi chiusa, fine specification function
				for (j = j + 1; j < str.length(); j++) {
					if (str.charAt(j) == ')') {cntParOpen--;}
					if (str.charAt(j) == '(') {cntParOpen++;}
					if (cntParOpen == 0){break;}
				}
                // Function malformata   
				if (cntParOpen != 0) {
	   				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_PROC_DIVISION);
    				instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0032", token.toString(), excp, this.programName, "");
    	 			instruction.setParsingError(true);
					return expression;
				}   
				// Bypass spaces
				for (j++; j < str.length(); j++) {  
					if (str.charAt(j) != ' ') {
						j--;
						break;
					}
				}
                if (j >= str.length()) {j = str.length() - 1;}
	     		// Individuazione fine qualificatore ref mod, se presente
				iEndIdentifier = extractExpressionGetEndQualifier(str, j);
				// Estrazione identificatore completo Function + eventuale ref mod in coda
				strIdentifier = str.substring(iStartToken, iEndIdentifier + 1);
				al_identifier = extractIdentifiers(instruction, strIdentifier);
				if (instruction.isParsingError()) {
					return expression;
				} 
				identifier = al_identifier.get(0);
		    	expressionElement = new ExpressionCobolElement(reserverWord, identifier.getNameIdentifier(), identifier);
		    	expression.addElement(expressionElement);
		    	i = iEndIdentifier + 1;
				// Bypass spaces
				for (; i < str.length(); i++) {
					if (str.charAt(i) != ' ') {
						i--;
						break;
					}
				}
				continue;
		    	
			}
		
			// Non è una funzione intrinseca.
            // Se ci sono più combinazioni che iniziano con il token, cerco quella di una sola parola (come NOT)
			if (reserverWord.getCobolInstrCategory() != EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
				if (al_reservedWordEntry.size() > 1) {
					for (InnerInstructionWordsEntry reservedWordEntry : al_reservedWordEntry) {
						if (reservedWordEntry.al_wordKey.size() == 1) {
							reserverWord = reservedWordEntry.en_WordReservedOwner;
							break;
						}
					}
				}
			}
			
			// Operatore Or, And, Not, +, -,. ...
			// Costante figurativa 
		    if (reserverWord.getCobolSymbolType()  == EnumSymbolType.COBOL_SYMBOL_OPERATOR
		    ||  reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_FIGURATIVE) {
		    	identifier = new DataItemCobolIdentifier();
		    	identifier.setIdentifierType(reserverWord);
		    	identifier.setNameIdentifier(token.toString());
		    	expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
		    	expression.addElement(expressionElement);
				// Bypass spaces
				for (; i < str.length(); i++) {
					if (str.charAt(i) != ' ') {
						i--;
						break;
					}
				}
		    	continue;
		    }
			
		    // Special register length of e address of
		    if (reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER
		    && (reserverWord == EnumCobolReservedWords.REGISTER_LENGTH_OF 	|| 
		    	reserverWord == EnumCobolReservedWords.REGISTER_ADDRESS_OF )
		       ) {
		    	j = str.indexOf("OF", i);
				// Cerco primo carattere diverso da space
				for (j = j + 2 ; j < str.length(); j++) {
					if (str.charAt(j) != ' ') {
						break;
					}
				}
				// Cerco primo carattere = space dopo nome campo
				for (; j < str.length(); j++) {
					if (str.charAt(j) == ' ') {
						break;
					}
				}
				iEndIdentifier = extractExpressionGetEndQualifier(str, j);
				strIdentifier = str.substring(iStartToken, j ) + " " + str.substring(j, iEndIdentifier + 1);
				al_identifier = extractIdentifiers(instruction, strIdentifier);
				if (instruction.isParsingError()) {
					return expression;
				}
				identifier = al_identifier.get(0);
		    	expressionElement = new ExpressionCobolElement(reserverWord, identifier.getNameIdentifier(), identifier);
		    	expression.addElement(expressionElement);
		    	i = iEndIdentifier + 1;
				// Bypass spaces
				for (; i < str.length(); i++) {
					if (str.charAt(i) != ' ') {
						i--;
						break;
					}
				}
				continue;
			}
		    
			// Special register atomico
		    if (reserverWord.getCobolInstrCategory()  == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER) {
		    	identifier = new DataItemCobolIdentifier();
		    	identifier.setIdentifierType(reserverWord);
		    	identifier.setNameIdentifier(token.toString());
		    	expressionElement = new ExpressionCobolElement(reserverWord, token.toString(), identifier);
		    	expression.addElement(expressionElement);
				// Bypass spaces
				for (; i < str.length(); i++) {
					if (str.charAt(i) != ' ') {
						i--;
						break;
					}
				}
		    	continue;
			}
		    
		}
		
		return expression;
	}


	
	
	/* --------------------------------------------------------------------
	 * Restituisce l'indice di fine identificatore nella stringa.
	 * --------------------------------------------------------------------
	 * 
	 * Viene fornita la stringa da valutare e l'indice del primo carattere
	 * dopo il nome del campo (A nell'esempio)
	 * 
	 * Viene restituito l'indice dell'ultimo carattere dell'eventuale qualificatore
	 * ovvero gli indici e il reference modification.
	 * Per esempio A (1, 6, 7)(2:Length Of campo1)
	 * Nel caso di stringa alfanumerica viene restituito l'indice dell'apice di
	 * chiusura, singolo o doppio.
	 * 
	 * 
	 */
	private int extractExpressionGetEndQualifier(String str, int iStart) {
		
		int i = 0;
		int iEndIdentifier = 0;
		boolean isReferenceModification = false;
		

		
		// Cerco primo carattere diverso da space
		for (i = iStart + 1 ; i < str.length(); i++) {
			if (str.charAt(i) != ' ') {
				break;
			}
		}
  
		// Fine stringa
		if (i >= str.length()) {
			return iStart - 1;
		}
		
		
		// Nessuna qualificazione di indici e/o reference modification
		if (str.charAt(i) != '(') {
			return iStart;
		}
	      
		// Si tratta di un campo indexato e/o qualificato da reference modification
		
		isReferenceModification = false;
		
		// Cerco parentesi chiusa
		for (iEndIdentifier = i + 1 + 1; iEndIdentifier < str.length(); iEndIdentifier++) {
			if (str.charAt(iEndIdentifier) == ':') {
				isReferenceModification = true;
			}
			if (str.charAt(iEndIdentifier) == ')') {
				break;
			}
		}   
		
		// Era reference modification: fine identificatore
		if (isReferenceModification) {
			return iEndIdentifier; 
		}
		
		// Erano indici: verifica se c'è anche reference modification
		
		// Cerco primo carattere diverso da space
		for (i = iEndIdentifier + 1 ; i < str.length(); i++) {
			if (str.charAt(i) != ' ') {
				break;
			}
		}

		// Fine stringa
		if (i >= str.length()) {
			return iEndIdentifier;
		}
		
		// Non è reference modification
		if (str.charAt(i) != '(') {
			return iEndIdentifier;
		}
		
		// Reference modification: cerco parentesi chiusa
		for (iEndIdentifier = i + 1 + 1; iEndIdentifier < str.length(); iEndIdentifier++) {
			if (str.charAt(iEndIdentifier) == ')') {
				break;
			}
		}
		return iEndIdentifier;  
	}

 
	/*
	 * Viene gestito il reperimento del modulo Copy già analizzato e serializzato
	 * o l'attivazione ricorsiva dell'analisi del copy.
	 * 
	 * Se non esiste viene attivato il processo ricorsivo di analisi, al termine del quale
	 * il copy serializzato viene letto e i suoi elementi inseriti nella struttura del programma
	 * corrente, se si sta analizzando un programma
	 * 
	 * Richiamato sia a fronte di analisi copy sia a fronte di copy/include nel programma
	 * l'Oggetto copy è stato già inserito in struttura di aggiornamento db al momento dell'analisi dello stmt COPY
	 */
 	private void includeAnalyzeCopyEntries(
					                        InnerContextAnalysis ictxP				// Contesto corrente 
					                      , InstructionCobol instructionCopyStmt	// Istruzione copy da espandere
 										  , String copyNameCaller					// Nome copy chiamante (if any)
										  ) throws ExceptionAmrita, SQLException {
		    	
        
 		InnerContextAnalysis ictx = ictxP.clone();	
 		EntityObject eo = null;
		
 	    // Inizializzazione/recupero oggetto copy già analizzato
 		includeAnalyzeCopyEntriesInitializeIctx(ictx, instructionCopyStmt);      
 		// Oggetto copy da struttura db/sys subSys corrente/subSys Owner/new object
 		eo=this.analyzerDbInfo.getAddObjectEntitled(ictx.copyNameToInclude, ictx.typeCopyObject);
 
	    ////////////////////////////////////////////////////////////////
 		// Copy serializzato NON trovato, copy non ancora analizzato    
 		////////////////////////////////////////////////////////////////
 		
 		if (ictx.objectCopyCobol == null) {
 			// Analisi copy NON a fronte di analisi programma: source descriptor già disponibile e si puo attivare l'analisi ricorsiva
 			if (this.programCobol == null) {
				ictx.siCopy = ictx.si;
 				includeAnalyzeCopyEntriesSourceFound(ictx, instructionCopyStmt, copyNameCaller);
 				return; 
 			// Analisi copy a fronte di COPY in programma: devo recuperare il sorgente
 			// Recupero copy source da librerie in SEARCH/corrente/... o con path da OBJECT_SOURCE_MEMBER
			} else { 
	 			ictx.siCopy = getSourceCopy(ictx, ictx.copyNameToInclude);
	 			// Copy source TROVATO per analisi sotto sys/subsys corrente o in resources: Si puo attivare l'analisi ricorsiva
	 			if (ictx.siCopy != null) {
	 				includeAnalyzeCopyEntriesSourceFound(ictx, instructionCopyStmt, copyNameCaller);
	 				return;   
	 			} 
	 			// Copy source NON trovato nelle LIBRERIE in search e in path di analisi: marco istruzione copy come semantic error 	
	 			if (ictx.siCopy == null) {
	 				if (!(this.pgmNameUnderParsing.trim()).equals("")) {
						logMessage(EnumMessageType.ERROR_INTERNAL, "ET0013", this.pgmNameUnderParsing, ictx.copyNameToInclude, di.al_librarySourceSearchCode.toString());
					} else {
						logMessage(EnumMessageType.ERROR_INTERNAL, "ET0046", ictx.copyNameToInclude, di.al_librarySourceSearchCode.toString());
					}
					ictx.excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOURCE_GETTING);
	 				instructionCopyStmt.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0013", ictx.copyNameToInclude, ictx.excp, this.pgmNameUnderParsing, ictx.copyNameToInclude,ictx.typeCopyObject.toString(), di.al_librarySourceSearchCode.toString());
	 				instructionCopyStmt.setSemanticError(true);
	 				// Inserimento oggetto da aquisire per il sistema/sottosistema
	 				eo.setStatus(EnumObjectStatus.OBJECT_TO_BE_ACQUIRED);
	 				// Relazione Copy mancante a livello di pgm sys/subsys e generico sys/sub 
	 				sqlInsRelationCopyCobolMissing(ictx.copyNameToInclude, ictx.typeCopyObject);
	 				return;
	 			}
	 			// Source recuperato dal path originale di analisi:  Si puo attivare l'analisi ricorsiva
	 			logMessage(EnumMessageType.INFORMATION, "MI0302", this.pgmNameUnderParsing, ictx.copyNameToInclude,  ictx.objectCopyCobol.getPath());				
	 			includeAnalyzeCopyEntriesSourceFound(ictx, instructionCopyStmt, copyNameCaller);
	 			return;
			}
  		} 
  		
 		//////////////////////////////////////////////////////////
        // Copy serializzato TROVATO 
 	    //////////////////////////////////////////////////////////
 		
 		// Gestione inserimento relazioni PGM_CICS_MAP e PGM_CICS_MAPSET
 		gestAddRelPgmPgmCicsMapMapsetIfCopyMap(instructionCopyStmt);			
 		
		// Direttiva generale/specifica di RIANALISI attiva: si rianalizza ricorsivamente il sorgente se stesso sys/subSys
		if (di.optReAnalysisCopy == true
	 	||  di.al_copyToForceReAnalysis.contains(ictx.copyNameToInclude)) {
  	 	    
			// Recupero sorgente da librerie in SEARCH/corrente/... o con path da OBJECT_SOURCE_MEMBER    
  	 		ictx.siCopy = getSourceCopy(ictx, ictx.copyNameToInclude);
  	 		
  	 		// Source NON trovato dove dovrebbe essere
  	 		if (ictx.siCopy == null) {
  	  	 		if (!(this.pgmNameUnderParsing.trim()).equals("")) {
   					logMessage(EnumMessageType.ERROR_INTERNAL, "ET0013", this.pgmNameUnderParsing, ictx.copyNameToInclude, di.al_librarySourceSearchCode.toString());
  				} else {
  					logMessage(EnumMessageType.ERROR_INTERNAL, "ET0046", ictx.copyNameToInclude, di.al_librarySourceSearchCode.toString());
  				}
  				ictx.excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOURCE_GETTING);
  	  	  		instructionCopyStmt.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0013",ictx.copyNameToInclude, ictx.excp, this.pgmNameUnderParsing, ictx.copyNameToInclude, ictx.typeCopyObject.toString(), di.al_librarySourceSearchCode.toString());
  	  	  		instructionCopyStmt.setSemanticError(true);
  	  	  		eo.setStatus(EnumObjectStatus.OBJECT_TO_BE_ACQUIRED);
   	  	  		// Relazione Copy mancante a livello di pgm sys/subsys e generico sys/sub 
  	  	  		sqlInsRelationCopyCobolMissing(ictx.copyNameToInclude, ictx.typeCopyObject);			 
  	  	 	    return;
			} 
  	 		
			// Copy source trovato ha lo stesso sys/subSys di analisi corrente o copy proc: si puo attivare l'analisi ricorsiva
  	 		// Se copy proc l'analisi ricorsiva deve essere fatta in quanto il copy proc NON può essere analizzto da solo
  	 		if ((ictx.siCopy.getSystemOwner().equals(this.di.systemInput) && ictx.siCopy.getSubSystemOwner().equals(this.di.subSystemInput))
  	 		||  (ictx.typeCopySource == EnumSourceType.COBOL_COPY_PROC)	) {
 	  	 		includeAnalyzeCopyEntriesSourceFound(ictx, instructionCopyStmt, copyNameCaller);
 	  	 	    return;
 	  	 	// Copy non ri-analizzato in quanto appartenente a differente sys/subSys    
  	 		} else {
  	  	 		if (!(this.pgmNameUnderParsing.trim()).equals("")) {
  					logMessage(EnumMessageType.ERROR_INTERNAL, "MI0310", this.pgmNameUnderParsing, ictx.copyNameToInclude, ictx.siCopy.getSubSystemOwner());
  				} else {
  					logMessage(EnumMessageType.ERROR_INTERNAL, "MI0311", ictx.copyNameToInclude, ictx.siCopy.getSubSystemOwner());
  				}
			}
			// Il copy verrà incluso senza essere stato rianalizzato  			
		} // end-if 
		
		
 		// Vengono estratti tutti gli entry del copy dall'oggetto serializzato e inseriti nelle strutture di programma.
 		// Se il copy conteneva dei copy nesting, questi sono già inclusi nel copy serializzato.
 		// Eventuali statement copy nel copy nesting NON vengono più esplosi.
 		// Se l'eventuale clausola Replacing By dello statement copy modifica l'istruzione
 		// allora viene attivata la rianalisi dell'istruzione stessa.
 		// Il descrittore sorgente NON è necessario.  
		
		includeAnalyzeCopyEntriesScanReplace(ictx, instructionCopyStmt);      // Analisi copy
		includeAnalyzeCopyEntriesFinalDbAndRel(ictx, instructionCopyStmt);    // Update db copy status/structure/relations
		includeAnalyzeCopyEntriesLogFound(ictx);                              // Loggging copy trovato e analizzato
		
		// Update preliminare stmt oggetto  COPY con Stesso sistema/sottosistema del programma sotto analisi
		instructionCopyStmt.setSysOwner(this.di.systemInput);
		instructionCopyStmt.setSubSysOwner(this.di.subSystemInput);
 	    eo.setSystemOwner(this.di.systemInput);
		eo.setSubSystemOwner(this.di.subSystemInput);

		// Sys/Subsys owner in copy serializzato <> da corrente: nuovo oggetto copy con owner da copy serializzato		
		if (!ictx.objectCopyCobol.getSysOwner().equals(this.di.systemInput)
		||  !ictx.objectCopyCobol.getSubSysOwner().equals(this.di.subSystemInput)) {
			// Update stmt COPY con Stesso sistema/sottosistema del programma sotto analisi
			instructionCopyStmt.setSysOwner(ictx.objectCopyCobol.getSysOwner());
			instructionCopyStmt.setSubSysOwner(ictx.objectCopyCobol.getSubSysOwner());
			// Update Sys/SubSys owner oggetto copy in object copy in struttura db
			eo.setSystemOwner(ictx.objectCopyCobol.getSysOwner());
    		eo.setSubSystemOwner(ictx.objectCopyCobol.getSubSysOwner());
		}
 			
    } 
 	
 	
	/*
 	 * Copy presente come oggetto serializzato.
 	 * Log messaggio di inclusione.
 	 */
 	private void includeAnalyzeCopyEntriesLogFound(InnerContextAnalysis ictx) {
		// Analisi copy dentro i programmi
		if (!this.pgmNameUnderParsing.isEmpty()) {
			logMessage(EnumMessageType.INFORMATION, "MI0209", this.pgmNameUnderParsing, ictx.copyNameToInclude, ucfg.getDirCobolSrcCopy()+"/"+ictx.copyNameToInclude +"." + SUFFIX_SERIALIZED_COPY, ictx.objectCopyCobol.getClass().toString());				
		} else {
			// Analisi copy indipendentemente dai programmi	e forzatura rianalisi NON prevista		
			if (ictx.siCopy == null) {
				logMessage(EnumMessageType.INFORMATION, "MI0208", ictx.copyNameToInclude);
				return;
			}
		}
	}


	/*
 	 * Operazioni finali dopo analisi copy
 	 * Updated db status copy
 	 * Insert db copy items definitions su db
 	 * Insert db objects and relations
 	 */
 	private EntityObject includeAnalyzeCopyEntriesFinalDbAndRel(InnerContextAnalysis ictx
 			                                                   , InstructionCobol instructionCopyStmt) throws ExceptionAmrita, SQLException {
		
 		EntityObject eo = null;
 		
 		// Copy nested: update struttura programma
		if (ictx.objectCopyCobol.isCopyNested()) {
			// Si stanno analizzando i copy non a fronte di analisi di programma
			if (this.programCobol != null) {
				this.programCobol.getCopyNested().add(ictx.copyNameToInclude);
			}
		}

		// Update strutture di persistenza
		if (this.di.optUpdateDb) {
			
			// Stato analisi  
			eo = updateCopyStatusOnDbStructure(ictx.objectCopyCobol);
			
			ictx.ar_Object = map_CopyDetected.get(ictx.copyNameToInclude);
			
			// Creazione entry map se inesistente
			if (ictx.ar_Object == null) {
				ictx.ar_Object = new Object[3];
				ictx.ar_Object[0] = false;											// (0) True = copy già trattato (tracciato inserito)
				ictx.al_CopyStmt = new ArrayList<InstructionCobol> ();
				ictx.al_CopyStmt.add(instructionCopyStmt);
				ictx.ar_Object[1] = ictx.al_CopyStmt;										// (1) ArrayList entries copy
				ictx.al_CopyObject = new ArrayList<CopyCobol> ();
				ictx.al_CopyObject.add(ictx.objectCopyCobol);
				ictx.ar_Object[2] = ictx.al_CopyObject;									// (2) Oggetto copy
				map_CopyDetected.put(ictx.copyNameToInclude, ictx.ar_Object);
			}
			// Copy già trattato: return
			if ((Boolean) ictx.ar_Object[0] == true) {
				return eo;
			}
			
			// Aggiornamento strutture per inserimento su db a fine elaborazione
			// Vengono inseriti i campi del tracciato record
			if (!ictx.objectCopyCobol.isCopyWithAnyErrorDetected() && this.di.optCopyDefOnDbToInsert) {
				prepareCopyElementsForDbUpdate(ictx.objectCopyCobol, ictx.copyNameToInclude, ictx.typeCopyObject);
				ictx.ar_Object[0] = true;
			}
		}		
		return eo;
	}


	/*
 	 *  Scan copy entries e analisi
 	 * 
 	 */
 	private void includeAnalyzeCopyEntriesScanReplace(InnerContextAnalysis ictx
 			                                        , InstructionCobol instructionCopyStmt) throws ExceptionAmrita, SQLException {
		
 		ictx.ar_CopyEntry = ictx.objectCopyCobol.getEntries();
		ictx.copyStmt = instructionCopyStmt;
        if (ictx.copyNameAncestor.equals("")) {
			ictx.copyNameAncestor = ictx.copyNameToInclude;
			ictx.isCopyAncestorDeserialized = true;
		}
        		
 		ictx.isCopyIncludingInProgress = true;
		
		// Scan Definizioni/istruzioni componenti il copy
		for (ProgramCobolEntry<? extends Instruction> copyEntry : ictx.ar_CopyEntry) {

			ictx.instructionGeneric = (Instruction) copyEntry.getInstruction();
			if (copyEntry.getInstruction() instanceof InstructionCobol) {
				ictx.instructionCobol = (InstructionCobol) copyEntry.getInstruction();
				ictx.activeTypeInstr = ictx.instructionCobol.getTypeInstr();
			} else if (copyEntry.getInstruction() instanceof InstructionCics) {
				ictx.instructionCics = (InstructionCics) copyEntry.getInstruction();
				ictx.activeTypeInstr = ictx.instructionCics.getTypeInstr();
			} else if (copyEntry.getInstruction() instanceof InstructionSql) {
				ictx.instructionSql = (InstructionSql) copyEntry.getInstruction();
				ictx.activeTypeInstr = ictx.instructionSql.getTypeInstr();
			}
			
			// Creazione entry di programma con cast corretto e impostazioni varie correnti
			ictx.programEntry = createProgramEntry(ictx.instructionGeneric, ictx);
			ictx.programEntry.setUnderCopy(true);
			ictx.programEntry.setUnderCopyName(copyEntry.getUnderCopyName());
			  
			// Applicazione parametri di Replacing By all'istruzione nel copy (if any e se è un pgm in analisi)
			ictx.isStatementReplaced = applyReplacingBy(ictx, ictx.instructionGeneric);	
			ictx.programEntry.setReplacedBy(ictx.isStatementReplaced);
			ictx.instructionGeneric.clearXrefStruct();									// Il copy era stato memorizzato cono gli ultimi xref
			ictx.instructionGeneric.setParsingError(false);
			ictx.instructionGeneric.setSemanticError(false);
			
			// Il modulo copy può contenere istruzioni di impostazione di divisioni e sezioni di programma
			setActiveDivisionSectionAreas(ictx);
			
			// Analisi istruzione 
        	ictx.isInstructionToAnalyze = true;
         	dispatchInstructionAnalyzer(ictx, ictx.instructionGeneric, ictx.programEntry);

		    // Operazioni post analisi istruzione: update xref simboli di programma
			switch (this.activeDivisionArea) {
				case DATA_DIVISION:
 					// Nessuna operazione
					break;
				case PROC_DIVISION:
				// Solo se sto analizzando un programma
				if (!this.programName.isEmpty()) {
					updateMapLabelSectionGoToPerform(ictx, ictx.instructionGeneric);
				}
				break;
			}
			
			// Se parsing/semantic error impostazione flag generale di errore
			if (ictx.instructionGeneric.isParsingError()
		    ||  ictx.instructionGeneric.isSemanticError()) {
				ictx.isAnyInstructionErrorDetected = true;
				ictx.objectCopyCobol.setCopyWithAnyErrorDetected(true);
			}
			 
		} // end-for

	    ictx.isCopyIncludingInProgress = false;
	 }



	/* Inizializzazione aarea di controllo */
 	private void includeAnalyzeCopyEntriesInitializeIctx(InnerContextAnalysis ictx, InstructionCobol instructionCopyStmt) throws ExceptionAmrita {
 		
 		ictx.objectCopyCobol = null;
		ictx.programEntry = null;
 		ictx.ar_CopyEntry = null;
 		ictx.instructionGeneric = null;
		ictx.instructionCobol = null;
		ictx.instructionCics = null;
		ictx.instructionSql = null;
      	ictx.ar_Object = null;                                      // Mappato da map copyDetected
       	ictx.al_CopyStmt = null;                                    // Secondo elemento ar_Object
	    ictx.al_CopyObject = null;                                  // Terzo elemento ar_Object
		ictx.copyNameToInclude = "";
		ictx.typeCopySource = null;	
		ictx.typeCopyObject = null;	
		ictx.isStatementReplaced = false;
 		ictx.siCopy = null;
 		ictx.excp = null; 
 		ictx.isAnyInstructionErrorDetected = false;
 		ictx.isAnyInstructionWarningDetected = false;

		// Analisi a fronte di statement copy in analisi programma
		if (!this.programName.isEmpty()) {
			if (this.activeDivisionArea  == EnumCobolReservedWords.PROC_DIVISION) {
				ictx.typeCopySource = EnumSourceType.COBOL_COPY_PROC ;
				ictx.typeCopyObject = EnumObject.OBJECT_COPY_COBOL_PROC;
			} else if (this.activeDivisionArea  == EnumCobolReservedWords.DATA_DIVISION) {
				ictx.typeCopySource = EnumSourceType.COBOL_COPY_DATA;
				ictx.typeCopyObject = EnumObject.OBJECT_COPY_COBOL_DATA;
			} else if (this.activeDivisionArea  == EnumCobolReservedWords.ENV_DIVISION) {
				ictx.typeCopySource = EnumSourceType.COBOL_COPY_ENV;
				ictx.typeCopyObject = EnumObject.OBJECT_COPY_COBOL_ENV;
			} else {
				ictx.typeCopySource = EnumSourceType.COBOL_COPY_ID;
				ictx.typeCopyObject = EnumObject.OBJECT_COPY_COBOL_ID;
			}
		} else {
			// Analisi a fronte di analisi sources copy separati non analizzando un programma
			ictx.typeCopySource=ictx.si.getSourceType();
			ictx.typeCopyObject=ictx.typeCopySource.getObjectType();
		}		
 
		// Recupero eventuale copy già analizzato e codificato
		ictx.copyNameToInclude = instructionCopyStmt.copyGetName();
		ictx.objectCopyCobol = getCopyCobolCoded(ictx.copyNameToInclude);
	    
		// Copy non nested: clear array list entries
		if (ictx.copyNestinglevel == 0) {
			ictx.al_CopyEntry.clear();
		}
		

	}


	/*
     * Copy Source disponibile nelle librerie di search o in resources dell'analisi in corso.
     * per il sistema/sottosistema corrente.
     * Possibile attivare l'analisi ricorsiva 
     */
	private void includeAnalyzeCopyEntriesSourceFound(InnerContextAnalysis ictx
			                                        , InstructionCobol instructionCopyStmt
			                                        , String copyNameCaller) throws ExceptionAmrita, SQLException {
 		
		EntityObject eo = null;
 		EntityRelation entityRelation = null;
 		
		// Sorgente disponibile nel sys/subsys corrente: attivazione analisi ricorsiva

		// Analisi copy a fronte di analisi programma
		if (!this.pgmNameUnderParsing.isEmpty()) {
			logMessage(EnumMessageType.INFORMATION, "MI0034", this.pgmNameUnderParsing, ictx.copyNameToInclude, ictx.typeCopyObject.toString());				
		} else {
			// Analisi copy indipendentemente dai programmi
			logMessage(EnumMessageType.INFORMATION, "MI0204", ictx.copyNameToInclude, ictx.typeCopyObject.toString());				
		}

		// Impostazioni stato oggetto copy da inserire/aggiornare a fine elaborazione
		eo = this.analyzerDbInfo.getDbObjEntity(ictx.typeCopyObject, ictx.copyNameToInclude,this.di.systemInput, this.di.subSystemInput);
		
		// Oggetto non censito, potrebbe essere SQLCA: Inserisco oggetto e relazione
		if (eo == null) {
			if (this.activeDivisionArea == EnumCobolReservedWords.DATA_DIVISION) {
				eo = copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY, EnumObject.OBJECT_COPY_COBOL_DATA, instructionCopyStmt.copyGetName(), "", this.curNumDefDataDiv, instructionCopyStmt.getTypeInstrCategory(), instructionCopyStmt);
			} else if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
				eo = copyIncludeAddObjectAndRelation(this.programName, EnumRelation.PGM_COPY, EnumObject.OBJECT_COPY_COBOL_PROC, instructionCopyStmt.copyGetName(), "", this.curNumDefProcDiv, instructionCopyStmt.getTypeInstrCategory(), instructionCopyStmt);				
			}
		}
		
		eo.setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS); // Status di default
		eo.setTypeSource(ictx.typeCopySource);
		
		// Impostazioni come se il copy fosse alla sua prima analisi			
		// Se l'analisi NON è a fronte di COPY stmt nel programma l'oggetto COPY è gia stato Inserito in initialOperationsCopy()	
		if (!this.pgmNameUnderParsing.isEmpty()) {
			eo.setFileSource(ictx.copyNameToInclude);                // Nome file  
			eo.setSuffixFileSource(ictx.siCopy.getSourceSuffix());   // Suffisso
			eo.setLibraryDir(ictx.siCopy.getDirInput());             // Directory dove il sorgente è stato trovato
			eo.setLibrarySourceObject(ictx.siCopy.getLibraryCode()); // Nome oggetto LIBRARY libreria sorgente di analisi
			eo.setLibrarySource(ictx.siCopy.getDirInput());          // Libreria sorgente di analisi (Per oggetti direttamente dedotti da un file sorgente)				
			this.analyzerDbInfo.completeInfoObject(eo);
		}
		this.analyzerDbInfo.addObjEntity(eo); // Inserimento in struttura per aggiornamenti finali (Dovrebbe già esserci)

		// Sources TROVATO in una libreria elencata nel pilot di esecuzione, inserisco relazioni con LIBRARY
		if (!ictx.siCopy.getLibraryCode().isEmpty()) {
			// Oggetto LIBRARY
			eo = new EntityObject();
			eo.setSystem(this.di.systemInput);   						 
			eo.setSubSystem(this.di.subSystemInput);    		
			eo.setTypeObject(EnumObject.OBJECT_LIBRARY);						
			eo.setIdObject(ictx.siCopy.getLibraryCode());
			eo.setStatus(EnumObjectStatus.OBJECT_NOT_TO_BE_ANALYZED);
			eo.setLibrarySourceObject(ictx.siCopy.getLibraryCode());
			eo.setLibraryDir(ictx.siCopy.getDirInput());
			this.analyzerDbInfo.addObjEntity(eo);				
			// Relazione LIBRARY-COPY    
			entityRelation = new EntityRelation();
			entityRelation.setSystem(this.di.systemInput);   						 
			entityRelation.setSubSystem(this.di.subSystemInput); 
			entityRelation.setIdObjectA(ictx.siCopy.getLibraryCode());
			entityRelation.setTypeObjectA(EnumObject.OBJECT_LIBRARY);
			entityRelation.setRelation(EnumRelation.LIBRARY_COPY);
			entityRelation.setIdObjectB(ictx.copyNameToInclude);
			entityRelation.setTypeObjectB(ictx.typeCopyObject);
			this.analyzerDbInfo.addObjEntityRelation(entityRelation);
		} 		   

		// Inserimento sql Delete relazione sys-subsys-Copy-Missing per il sistema/sottosistema  
		sqlInsDeleteRelationSysSubsysCopyCobolMissing(ictx.copyNameToInclude, ictx.typeCopyObject, true);
		sqlInsDeleteRelationAndOriginAndOption(ictx.copyNameToInclude, ictx.typeCopyObject, true);

		// Impostazioni per analisi
		ictx.copyStmt = instructionCopyStmt;  
		if (ictx.copyNameAncestor.equals("")) {
			ictx.copyNameAncestor = ictx.copyNameToInclude;
			ictx.isCopyAncestorDeserialized = false;
		}
		this.di.curCopyUnderAnalysis = ictx.copyNameToInclude;	    // In caso exception durante l'analisi e altro
		this.di.curTypeCopyUnderAnalysis = ictx.typeCopyObject;	    // Tipologia copy per inserimento in struttura db
		
		// Analisi RICORSIVA modulo copy
		ictx.objectCopyCobol = analyzeCopyRecursive(ictx, ictx.copyNameToInclude, ictx.typeCopyObject, ictx.siCopy, copyNameCaller);
		
		// Errore di analisi del copy o di un copy nested
		if (ictx.isAnyInstructionErrorDetected) {
			if (!(this.pgmNameUnderParsing.trim()).equals("")) {
				logMessage(EnumMessageType.ERROR_INPUT, "ET0020", this.pgmNameUnderParsing, ictx.copyNameToInclude);
			} else {
				logMessage(EnumMessageType.ERROR_INPUT, "ET0047", this.copyNameUnderParsing, ictx.copyNameToInclude);
			}
			ictx.excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_COPY_ANALYSIS);
			instructionCopyStmt.setInfoError(EnumMessageType.ERROR_INTERNAL, "ET0047", "", ictx.excp, ictx.copyNameToInclude,  ictx.typeCopyObject.toString());
			instructionCopyStmt.setSemanticError(true);
			return;
		}

		// Copy nested: adjust posizionamento corretto copy e update descrittore programma
		if (ictx.objectCopyCobol.isCopyNested()) {
			copyNestedAdjustPositionCopyStmt(ictx, ictx.copyNameToInclude, ictx.objectCopyCobol);
			// Valido solo analizzando copy a partire dai ai programmi
			if (this.programCobol != null) {
				this.programCobol.getCopyNested().add(ictx.copyNameToInclude);
			}
		}
		this.di.curCopyUnderAnalysis = "";
		this.di.curTypeCopyUnderAnalysis = null;

		// Update subSysOwner in eventuali altri oggetti copy con subsys <> da corrente
		sqlInsUpdateObjectSubSysOwner(ictx.copyNameToInclude,  ictx.typeCopyObject, this.di.systemInput, this.di.subSystemInput);
		
		// è stato analizzato ricorsivamente, i suoi entry inseriti nelle strutture del programma e quindi serializzato.
		// Contestualmente all'analisi sono stati inseriti gli entry nel programma.
		// Successive istruzioni COPY implicano l'espansione dell'oggetto copy serializzato.
		return;			
	}


	/* ----------------------------------------------------------------------------------------
     * Nell'analisi ricorsiva dei copy nested, gli statement Copy non 
     * vengono collocati nella posizione corretta.
     * Ogni entry contiene il nome del copy a cui appartiene.
     * Questo metodo sposta ogni statement copy prima del primo
     * entry del copy stesso.
     * Successivamente aggiorna l'oggetto copy serializzato.
     * ----------------------------------------------------------------------------------------
     */
    private void copyNestedAdjustPositionCopyStmt(InnerContextAnalysis ictx, String copyName, CopyCobol objectCopyCobol) throws ExceptionAmrita {

      	ProgramCobolEntry<? extends Instruction>[] ar_copyEntry = null;
      	ProgramCobolEntry<? extends Instruction> copyEntry = null;
      	InstructionCobol instrCopy = null;
       	ArrayList<ProgramCobolEntry<? extends Instruction>> al_copyEntryNew = null;
    	String curCopyName = "";
    	boolean isCopyStmtToInsert = false;
       	int i = 0;
    	
        ar_copyEntry = objectCopyCobol.getEntries();
        al_copyEntryNew = new  ArrayList<ProgramCobolEntry<? extends Instruction>> ();
        
        // Sposto fino al primo nested copy
        curCopyName = ar_copyEntry[0].getUnderCopyName();
        
        for (i = 0; i < ar_copyEntry.length; i++) {
        	
        	copyEntry = ar_copyEntry[i];
        	
        	// Copy statement: skip
        	if (copyEntry.getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
		        continue;
			}
        	
        	// Stesso copy
        	if (copyEntry.getUnderCopyName().equals(curCopyName)) {
        		al_copyEntryNew.add(copyEntry);
        		continue;
			}
        	
        	// Inserimento copy statement
        	curCopyName = copyEntry.getUnderCopyName();
        	isCopyStmtToInsert = true;
        	for (ProgramCobolEntry<? extends Instruction> entryWork : al_copyEntryNew) {
            	if (entryWork.getTypeInstr() != EnumCobolReservedWords.DIR_COMPILER_COPY) {continue;}
            	instrCopy = (InstructionCobol) entryWork.getInstruction();
            	if (!instrCopy.copyGetName().equals(curCopyName)) {continue;}
            	isCopyStmtToInsert = false;
            	break;
			}
         	if (isCopyStmtToInsert) {
            	for (int j = 0; j < ar_copyEntry.length; j++) {
            		if (ar_copyEntry[j].getTypeInstr() == EnumCobolReservedWords.DIR_COMPILER_COPY) {
            			instrCopy = (InstructionCobol) ar_copyEntry[j].getInstruction();
            			// Inserimento statement copy
            			if (instrCopy.copyGetName().equals(curCopyName)) {
            				al_copyEntryNew.add(ar_copyEntry[j]);
            				break;
    					}
    				}
    			}
			}
        	// Inserimento entry corrente
        	al_copyEntryNew.add(copyEntry);
 		}
        
        // Update e serializzazione
        objectCopyCobol.setEntries(al_copyEntryNew);
		putSerialized(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjCopy(), SUFFIX_SERIALIZED_COPY, copyName, objectCopyCobol);
	}


	/* ---------------------------------------------
     * Update map_LabelSectionse istruzione label
     * ---------------------------------------------
     * 
     * Metodo attivato in fase di inclusione di moduli copy, quando
     * non si passa per l'analisi delle istruzioni.
     * Viene aggiornata la map di controllo di label e section
     * 
     */
 	@SuppressWarnings("unchecked")
	private void updateMapLabelSectionGoToPerform(InnerContextAnalysis ictx, Instruction instructionGeneric) {
		
 		InstructionCobolProcedure instructionCobol = null;
		Object ar_object[] = null;
		ArrayList<Integer> al_numInstr = null;
		String ar_label[] = null;
		String labelSection = "";
		String label = "";
		Boolean isSection = null;
		
		// Sol se ostruzione cobol nativa
		if (!(instructionGeneric instanceof InstructionCobolProcedure)) {
			return;
		}
		
		instructionCobol = (InstructionCobolProcedure) instructionGeneric;
		
		
		//////////////////////////////////////////////////////////
		// Label o Section
		//////////////////////////////////////////////////////////
		
		if (instructionCobol.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL
		||  instructionCobol.getTypeInstr() == EnumCobolReservedWords.PROC_SECTION		) {
			if (instructionCobol.getTypeInstr() == EnumCobolReservedWords.PROC_LABEL) {
				labelSection = instructionCobol.labelGetName();
				isSection = new Boolean(false);
			} else if (instructionCobol.getTypeInstr() != EnumCobolReservedWords.PROC_SECTION) {
				labelSection = instructionCobol.sectionGetName();
				isSection = new Boolean(true);
			} 
			// Map descrittore label|section
	 		ar_object = this.map_LabelSection.get(labelSection);

	 		// Label definita prima di perform/goTo
	 		if (ar_object == null) {
	 	 		ar_object = new Object[6];
	 			ar_object[0] = null;										// GraphNode
	 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
				ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
				ar_object[3] = instructionCobol.getNumInstr();				// Int numInstr def (prima incontrata)
				ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
	  	 	    this.map_LabelSection.put(labelSection, ar_object);
			}
			al_numInstr = (ArrayList<Integer>) ar_object[4];
			al_numInstr.add(instructionCobol.getNumInstr());
			ar_object[5] = isSection;					                // false/true section
		    return;
		}
		
		//////////////////////////////////////////////////////////
		// GoTo
		//////////////////////////////////////////////////////////
		
		if (instructionCobol.getTypeInstr() == EnumCobolReservedWords.PROC_GOTO) {
			ar_label = instructionCobol.goToGetLabels();
			
			// Scan label e inserimento simbolo in input all'istruzione
			for (int i = 0; i < ar_label.length; i++) {
				label = ar_label[i];
				
		 		// Map descrittore goTo
		 		ar_object = new Object[2];
				ar_object[0] = null;									    	// node goTo
				ar_object[1] = ar_label;										// String[] labels
		 	    this.map_GoTo.put(instructionCobol.getNumInstr(), ar_object);

		 	    // Map descrittore labelSection
				ar_object = this.map_LabelSection.get(label);
		 		if (ar_object == null) {
		 	 		ar_object = new Object[6];
		 			ar_object[0] = null;										// GraphNode
		 			ar_object[1] = new ArrayList<Integer> ();					// ArrayList<int> goTo instructions  
		 			ar_object[2] = new ArrayList<Integer> ();					// ArrayList<int> perform instructions 
					ar_object[3] = 0;											// Int numInstr def
		 			ar_object[4] = new ArrayList<Integer> ();					// ArrayList<int> def instructions 
		 			ar_object[5] = new Boolean(false);							// false suppongo label
		  	 	    this.map_LabelSection.put(label, ar_object);
				} 
				al_numInstr = (ArrayList<Integer>) ar_object[1];
				al_numInstr.add(instructionCobol.getNumInstr());
			}
			return;
		}

		//////////////////////////////////////////////////////////
		// Perform
		//////////////////////////////////////////////////////////
		
		if (instructionCobol.getTypeInstr() == EnumCobolReservedWords.PROC_PERFORM 
		&& !instructionCobol.performIsInnerPerform()) {
			labelSection = instructionCobol.performGetFrom();
	        ar_object = this.map_LabelSection.get(labelSection);
	        
			// Perform a label|section incontrata prima di definizione di label o section
			if (ar_object == null) {
				ar_object = new Object[6];
				ar_object[0] = null;											// GraphNode
				ar_object[1] = new ArrayList<Integer> ();						// ArrayList<int> goTo instructions  
				ar_object[2] = new ArrayList<Integer> ();						// ArrayList<int> perform instructions 
				ar_object[3] = 0;												// Int numInstr definizione label/section
				ar_object[4] = new ArrayList<Integer> ();						// ArrayList<int> def instructions 
				ar_object[5] = new Boolean(false);								// false suppongo paragrafo
		 	    this.map_LabelSection.put(labelSection, ar_object);
			} 
	        
			// Update num instr performing
			al_numInstr = (ArrayList<Integer>) ar_object[2];
			al_numInstr.add(instructionCobol.getNumInstr());
			return;
		}
	}

 	
 	
	/*
 	 * Inserimento statement Sql di delete relazione di copy missing
 	 * a livello di sistema/sottosistema
 	 * 
 	 */
	private void sqlInsDeleteRelationSysSubsysCopyCobolMissing(String copyNameToInclude, EnumObject typeCopyObject, boolean isCurSysSubsys) {
		String strSql = "";
		
		// Sotto sistema/sottosistema generico in relazione con il copy
		if (!isCurSysSubsys) {
			strSql = "DELETE FROM Relation  WHERE "
					+ "     sys = '"         + "*" + "'" 
					+ " AND subSys = '"      + "*" + "'" 
					+ " AND relation =  "    + EnumRelation.SYS_SUBSYS_COPY_MISSING.ordinal() 
					+ " AND idObjectA = '"   + this.di.systemInput + "-" + this.di.subSystemInput + "'" 
					+ " AND typeObjectA =  " + EnumObject.OBJECT_SYS_SUBSYS.ordinal() 
					+ " AND idObjectb = '"   + copyNameToInclude + "'"
					+ " AND typeObjectB =  " + typeCopyObject.ordinal();
	    // Sotto sistema/sottosistema corrente in relazione con il copy
		} else {
			strSql = "DELETE FROM Relation  WHERE  "
					+ "     sys = '"         + this.di.systemInput + "'"
					+ " AND subSys = '"      + this.di.subSystemInput + "'" 
		            + " AND relation =  "    + EnumRelation.SYS_SUBSYS_COPY_MISSING.ordinal() 
					+ " AND typeObjectA =  " + EnumObject.OBJECT_SYS_SUBSYS.ordinal() 
					+ " AND idObjectA = '"   + this.di.systemInput + "-" + this.di.systemInput  + "'" 
					+ " AND idObjectb = '"   + copyNameToInclude + "'"
					+ " AND typeObjectB =  " + typeCopyObject.ordinal();			
		}
		
		this.analyzerDbInfo.addSqlDeleteStatement(strSql);
	}


	/*
 	 * Inserimento statement Sql di update subSys owner
 	 * in tutti gli oggetti nel systema ATTIVO del tipo specificato
 	 * NON appartenenti al subSys  sotto analisi corrente 
 	 * 
 	 */
	private void sqlInsUpdateObjectSubSysOwner(String idObject, EnumObject typeObject, String sys, String SubSysOwner) { 
		String strSql = "";
		
		// Sotto sistema/sottosistema generico in relazione con il copy
		strSql = "UPDATE Object  "
			   + " SET subSysOwner = '"   + SubSysOwner + "'" 
			   + " WHERE sys = '"         + sys + "'"  
			   + "   AND subSys <> '"     + SubSysOwner + "'" 
			   + "   AND typeObject =  "  + typeObject.ordinal() 
			   + "   AND idObject = '"    + idObject  + "'" ;
		
		this.analyzerDbInfo.addSqUpdateStatement(strSql);
	}
	
	/*
 	 * Inserimento statement Sql di delete relazioni, origine relazioni e opzioni oggetto
 	 */
	private void sqlInsDeleteRelationAndOriginAndOption(String idObject, EnumObject typeObject, boolean isOptionToDelete) {
		String strSql = "";

		// Delete Origine Relazioni oggetto 
		strSql = "DELETE FROM RelationOrigin  WHERE  "
				+ "     sys = '"         + this.di.systemInput + "'"
				+ " AND subSys = '"      + this.di.subSystemInput + "'" 
				+ " AND typeObjectA =  "  + typeObject.ordinal() 
				+ " AND idObjectA  = '"   + idObject  + "'"; 		
		this.analyzerDbInfo.addSqlDeleteStatement(strSql);
		
		// Delete Relazioni oggetto 
		strSql = "DELETE FROM Relation  WHERE  "
				+ "     sys = '"         + this.di.systemInput + "'"
				+ " AND subSys = '"      + this.di.subSystemInput + "'" 
				+ " AND typeObjectA =  "  + typeObject.ordinal() 
				+ " AND idObjectA  = '"   + idObject  + "'"; 		
		this.analyzerDbInfo.addSqlDeleteStatement(strSql);
		
		if (!isOptionToDelete) {return;}
		
		// Delete Opzioni oggetto 
		strSql = "DELETE FROM ObjectOption  WHERE  "
				+ "     sys = '"         + this.di.systemInput + "'"
				+ " AND subSys = '"      + this.di.subSystemInput + "'" 
				+ " AND typeObject =  "  + typeObject.ordinal() 
				+ " AND idObject  = '"   + idObject  + "'"; 		
		
		this.analyzerDbInfo.addSqlDeleteStatement(strSql);
	}


	
 	/*
 	 * Inserimento relazione di copy missing
 	 * a livello di sistema/sottosistema
  	 */
	private void sqlInsRelationCopyCobolMissing(String copyNameToInclude, EnumObject typeCopyObject) {
		
		EntityRelation er = null;
		EntityRelationOrigin ero = null;
			
		// Inserimento relazione fra sys_SUBSYS e copy
   		er = new EntityRelation();
		er.setSystem(this.di.systemInput);   						 
		er.setSubSystem(this.di.subSystemInput); 
  		er.setIdObjectA("");
   		er.setIdObjectB(copyNameToInclude);
   		er.setTypeObjectA(EnumObject.OBJECT_SYS_SUBSYS);
   		er.setTypeObjectB(typeCopyObject);
   		er.setRelation(EnumRelation.SYS_SUBSYS_COPY_MISSING);
   		this.analyzerDbInfo.addObjEntityRelation(er);
		
   		// Analisi copy NON da statement copy in pgm sotto analisi: no operation
   		if (this.pgmNameUnderParsing.isEmpty()) {
		   return;
		}
   		
		// Inserimento relazione fra programma e copy mancante
   		er = new EntityRelation();
		er.setSystem(this.di.systemInput);   						 
		er.setSubSystem(this.di.subSystemInput); 
   		er.setTypeObjectA(EnumObject.OBJECT_PGM_COBOL);
  		er.setIdObjectA(this.pgmNameUnderParsing); 
   		er.setTypeObjectB(typeCopyObject);
   		er.setIdObjectB(copyNameToInclude);
   		er.setRelation(EnumRelation.PGM_COPY_MISSING);
   		this.analyzerDbInfo.addObjEntityRelation(er);

   		// Inserimento origine relazione nel programma
   		ero = new EntityRelationOrigin();
   		ero.setSystem(this.di.systemInput);
   		ero.setSubSystem(this.di.subSystemInput);
   		ero.setIdObjectRelA(this.pgmNameUnderParsing);
   		ero.setIdObjectRelB(copyNameToInclude);
   		ero.setTypeObjectA(EnumObject.OBJECT_PGM_COBOL);
   		ero.setTypeObjectB(typeCopyObject);
   		ero.setRelation(EnumRelation.PGM_COPY_MISSING);
   		ero.setRelationType(EnumRelationType.RELATION_DIRECT);
   		if (this.activeDivisionArea == EnumCobolReservedWords.DATA_DIVISION) {
   	   		ero.setNumInstrOrigin(this.curNumDefDataDiv);
		} else if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
			ero.setNumInstrOrigin(this.curNumDefProcDiv);
		}
   		ero.setInstrProgramArea(this.activeDivisionArea);
   		ero.setIdObjectOrigin(this.pgmNameUnderParsing);
   		ero.setTypeObjectOrigin(EnumObject.OBJECT_PGM_COBOL);
   		ero.setRelationSource(EnumRelationSourceProcess.SOURCE_STATIC_LOCAL);
   		ero.setInstrLang(EnumLanguageItemInstr.ITEM_COBOL);
   		ero.setInstrTypePrecompiler(EnumPrecompilerReservedWords.NOT_ASSIGNED);
   		this.analyzerDbInfo.addObjEntityRelationOrigin(ero);
  		
	}




	/*
	 * --------------------------------------------------------------------
	 * Inserimento campi copy in struttura db per inserimento tracciato.
	 * --------------------------------------------------------------------
	 * 
	 * Gli oggetti copy, anche nested e le opzioni di programma, sono già stati inseriti durante 
	 * l'analisi dello statement copy, attivata direttamente o ricorsivamente. 
	 * In questa fase vengono inserite le definizioni dei singoli campi del copy nelle strutture
	 * di inserimento db a fine elaborazione
	 */
    private void prepareCopyElementsForDbUpdate(CopyCobol  objectCopy   		// Oggetto copy
		    		                          , String copyName   				// Copy da includere
									          , EnumObject typeCopyObject		// Tipo oggetto copy 
									    	   ) throws ExceptionAmrita, SQLException {
							    	
		ProgramCobolEntry<? extends Instruction>[] ar_copyEntry = null;
		int numSeq = 0;
		int i;
 		
		// Tracciato già presente su db: no operation
		if (this.analyzerDbInfo.getCntFieldCopyDefined(this.di.systemInput, copyName, typeCopyObject, true, true) > 0) {
			return;
		}
		
		
		// Copy di procedure o environment division: return
		if (typeCopyObject == EnumObject.OBJECT_COPY_COBOL_ENV
		||  typeCopyObject == EnumObject.OBJECT_COPY_COBOL_ID) {
			return;
		}
		
		
		// Inserimento definizioni copy in struttura da inserire su db a fine elaborazione
		ar_copyEntry = objectCopy.getEntries();
		
		
		// Scan definizioni copy
		for (i = 0; i < ar_copyEntry.length; i++) {
			
			// Non è una definizione dati: skip
			if (!(ar_copyEntry[i].getInstruction() instanceof InstructionCobolDataItem)) {
				continue;
			}
			InstructionCobolDataItem dataItem = (InstructionCobolDataItem) ar_copyEntry[i].getInstruction();
			
			// COBOL_DATA_ITEM_LEVEL_88 e COBOL_DATA_ITEM_LEVEL_66
			// Vengono portati comunque in output
			
			EntityCopyEntityDefinition copyItemDefinition = new EntityCopyEntityDefinition();
			
			// Key
			copyItemDefinition.setSystem(this.di.systemInput);
			copyItemDefinition.setSubSystem(this.di.subSystemInput);
			copyItemDefinition.setIdObject(copyName);
			copyItemDefinition.setTypeObject(typeCopyObject);
			copyItemDefinition.setNumSeq(numSeq++);
			
			// Data
			copyItemDefinition.setIdField(dataItem.getDataName());
			copyItemDefinition.setLevel(dataItem.getLevelNumber());
			copyItemDefinition.setOccurs(dataItem.getOccursNumber());
			copyItemDefinition.setLngBytes(dataItem.getSizeBytes());
			copyItemDefinition.setPos(ar_copyEntry[i].getPos());
			copyItemDefinition.setNumInt(dataItem.getNumInt());
			copyItemDefinition.setNumDec(dataItem.getNumDec());
			copyItemDefinition.setSigned(dataItem.isSignClause());
			copyItemDefinition.setGroupField(dataItem.isGroupField());
			copyItemDefinition.setItemLang(EnumLanguageItemInstr.ITEM_COBOL);
			copyItemDefinition.setItemType(dataItem.getItemType());
			this.analyzerDbInfo.addObjEntityCopyDefinition(copyItemDefinition);
			
		} // end-for
		
		return;
		
    	
	}


	/*
	 * 
	 * Aggiornamento status del modulo copy in oggetto copy struttura db.
	 *  
	 */
    private EntityObject updateCopyStatusOnDbStructure(CopyCobol  objectCopy)  {
							    	
		
		// Aggiornamento stato copy in oggetto inserito a fronte di analisi statemet copy
		for (EntityObject eo : this.analyzerDbInfo.al_DbObject) {
			if ((eo.getTypeObject() == EnumObject.OBJECT_COPY_COBOL_DATA ||
			     eo.getTypeObject() == EnumObject.OBJECT_COPY_COBOL_PROC ||
			     eo.getTypeObject() == EnumObject.OBJECT_COPY_COBOL_ID   ||
			     eo.getTypeObject() == EnumObject.OBJECT_COPY_COBOL_ENV    
				)
			&&  eo.getIdObject().equals(objectCopy.getCopyName())) {
				if (objectCopy.isCopyWithAnyErrorDetected()) {
					eo.setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_ERRORS);
					return eo;
				} else {
					eo.setStatus(EnumObjectStatus.OBJECT_ANALYZED_WITH_NO_ERRORS);
					return eo;
				}
			}
		}
		
		return null;
		
    	
	}

    

	/*
     * 
     * Vengono applicate le regole di replacing by all'istruzione sorgente contenuta nell'entry
     * del modulo copy, aggiornando il source dell'istruzione.
     * Se è stato effettuato qualche replacing viene restituito true.
     * 
     * In caso di analisi di singolo copy tramiti il metodo analyzeCopy() di questa classe
     * e non di un programma con statemnts copy, non viene effettuata alcuna operazione.
     * 
     * 
     */
	private boolean applyReplacingBy(InnerContextAnalysis ictx				    // Contesto di analisi corrente
								   , Instruction stmtToReplaceBy			    // istruzione su cui applicare replacing by
							        )    {
	   	
		InstructionCobol copyStmt = null;
		ArrayList<InstructionCobol.InnerReplacingByEntry> al_replacingByEnrty = null;
		String ar_RowsSource[] = null;
		String sourceInstrToReplace = "";
		String sourceInstrReplaced = "";
		String valueToFind = "";
		String valueToReplace = "";
        int i = 0;
		
		// Si sta analizzando un copy come source a se stante: non può esserci replacing by
		if (!ictx.isAnalysisOfProgram) {
			return false;
		}
		
        copyStmt = ictx.copyStmt;
 		al_replacingByEnrty = copyStmt.copyGetReplacingBy();
        
		// Il copy non aveva replacing By: exit
		if (al_replacingByEnrty == null) {
			return false;
		}
		
		// Recupero stringa sorgente dal tipo di istruzione attiva nell'Entry del modulo copy
		sourceInstrToReplace = stmtToReplaceBy.getSourceInstr();		
		sourceInstrReplaced = sourceInstrToReplace;

		// Scan coppie replacing by
		for (InstructionCobol.InnerReplacingByEntry replacingByEntry : al_replacingByEnrty) {
			
			valueToFind = replacingByEntry.valueToFind;
			valueToReplace = replacingByEntry.valueToReplace;
			
			// Nessun match: analisi coppia successiva
			if (sourceInstrReplaced.indexOf(valueToFind) < 0) {
				continue;
			}
			
			// Match: gestione replacing
			// L'ultimo replace contiene l'oggetto stringa definitivo
			sourceInstrReplaced = sourceInstrReplaced.replace(valueToFind, valueToReplace);
			
		}

		// Verifica se c'è stata qualche variazione
		if (sourceInstrToReplace.equals(sourceInstrReplaced)) {
			return false;
		}
		
		// Replacing source pacchettizzato effettuato: eseguo replacing anche di righe singole
		stmtToReplaceBy.setSourceInstr(sourceInstrReplaced);		
		
		// Scan righe istruzione
		ar_RowsSource = stmtToReplaceBy.getRowsSource();
		for (i = 0; i < ar_RowsSource.length; i++) {
			
			// Recupero stringa sorgente dal tipo di istruzione attiva nell'Entry del modulo copy
			sourceInstrReplaced = ar_RowsSource[i];	

			// Scan coppie replacing by
			for (InstructionCobol.InnerReplacingByEntry replacingByEntry : al_replacingByEnrty) {
				
				valueToFind = replacingByEntry.valueToFind;
				valueToReplace = replacingByEntry.valueToReplace;
				
				// Nessun match: analisi coppia successiva
				if (sourceInstrReplaced.indexOf(valueToFind) < 0) {
					continue;
				}
				
				// Match: gestione replacing
				// L'ultimo replace contiene l'oggetto stringa definitivo
				sourceInstrReplaced = sourceInstrReplaced.replace(valueToFind, valueToReplace);
			}

			ar_RowsSource[i] = sourceInstrReplaced;			
		}
		
		return true;
	}


	/*
     * 
     * Aggiornamento delle Symbol table dell'oggetto ProgramCobol, sulla base
     * degli utilizzi dei simboli usati nell'istruzione, che è stata
     * analizzata e che è pronta per l'uso.
     * 
     */
	private void updateProgramXrefProcFromInstruction(
													  InnerContextAnalysis ictx				// Contesto corrente
													, Object instructionGeneric				// Istruzione analizzata
													, int curNumDefProcDiv                  // Numero istruzione corrente
													  ) {
		
		Instruction instruction = null;
		Instruction.InnerSymbolEntry ar_symbolsDefinedInside[] = null;
		Instruction.InnerSymbolEntry ar_symbolsInput[] = null;
		Instruction.InnerSymbolEntry ar_symbolsOutput[] = null;
		String symbolName = null;
		DataItemQualifier qualifier = null;
		EnumSymbolType symbolType = null;
		
		
		// Cast a Instruction, da cui tutte le istruzioni ereditano
		instruction = (Instruction) instructionGeneric;

		// Recupero simboli istruzione definiti, in input e output
		ar_symbolsDefinedInside = instruction.symbolsDefinedInside();
		ar_symbolsInput = instruction.symbolsUsedInput();
		ar_symbolsOutput = instruction.symbolsUsedOutput();

		// Scan simboli definiti all'interno dell'istruzione (Section o label)
		for (Instruction.InnerSymbolEntry entry : ar_symbolsDefinedInside) {
			programCobol.symbolDefinitionAddProc(entry.symbolName, curNumDefProcDiv, entry.qualifier.getSymbolType());
		}

		// Scan simboli in input
		for (Instruction.InnerSymbolEntry entry : ar_symbolsInput) {
			symbolName =  entry.symbolName;
			qualifier = entry.qualifier;
			symbolType = qualifier.getSymbolType();
			// Label, proc_internal, Copy, Precompiler....
			programCobol.symbolAddXrefProcInput(symbolName, curNumDefProcDiv, symbolType);
		}
		
		// Scan simboli in output. Possono essere solo in Procedure Division
		for (Instruction.InnerSymbolEntry entry : ar_symbolsOutput) {
			symbolName =  entry.symbolName;
			qualifier = entry.qualifier;
			symbolType = qualifier.getSymbolType();
			// Label, proc_internal, Data_item,....
			programCobol.symbolAddXrefProcOutput(symbolName, curNumDefProcDiv, symbolType);
		}
	}


	/*
     * 
     * Aggiornamento delle Symbol table dell'oggetto ProgramCobol, sulla base
     * degli utilizzi dei simboli usati nell'istruzione di definizione dati, che è stata
     * analizzata e che è pronta per l'uso.
     * 
     */
	private void updateProgramXrefDataFromInstruction(Object instructionGeneric, int curNumDefDataDiv) {
		
		Instruction instruction = null;
		Instruction.InnerSymbolEntry ar_symbolsDefinedInside[] = null;
			
		// Cast a Instruction, da cui tutte le istruzioni ereditano
		instruction = (Instruction) instructionGeneric;

		// Recupero simboli definizione dati referenziati in input e definiti dall'istruzione stessa
		ar_symbolsDefinedInside = instruction.symbolsDefinedInside();

		// Scan simboli definiti all'interno dell'istruzione
		for (Instruction.InnerSymbolEntry entry : ar_symbolsDefinedInside) {
			this.programCobol.symbolDefinitionAddData(entry.symbolName, curNumDefDataDiv, entry.qualifier.getSymbolType());
		}

	}


	/*
	 * -----------------------------------------------------------------------------------
	 * Recupero del nome del file interno specificato dallo statement di data division Fd.
	 * -----------------------------------------------------------------------------------
	 * 
	 * Viene fornito il record name, che deve essere un livello 01. 
	 * Viene recuperata l'istruzione di definizione del record name in data division 
	 * Viene recuperata la prima istruzione di File Definition precedente. 
	 * Viene estratto il nome del file e restituito al chiamante.
	 */
	private String fileNameFromRecordName(InstructionCobolProcedure instruction, String recordNameWrite) {
	
		ExceptionAmrita excp = null;  
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		InstructionCobolDataStruct instructionDataDivision = null;
        
		String fileName = "";
		int ar_InstrDataDef[] = null;
		int numInstrDef = 0;
		int i;

		
		// Array con con numero istruzioni di definizione dati nel programma
		ar_InstrDataDef = programCobol.getXrefSymbolDefData(recordNameWrite);
		
		// Ioarea dichiarata in Write/Rewrite NON definita in nessuna Fd: errore di analisi e excp
		if (ar_InstrDataDef == null) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOURCE_ANALYSIS);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0025", recordNameWrite, excp, this.programName, recordNameWrite);
			instruction.setSemanticError(true);
			return "";
		}
		
		// Ioarea definita in più punti: impossibile procedere
		if (ar_InstrDataDef.length > 1) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOURCE_ANALYSIS);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0026", recordNameWrite, excp, this.programName, recordNameWrite);
			instruction.setSemanticError(true);
			return "";
		}
		
		numInstrDef = ar_InstrDataDef[0];
		
		// Array con istruzioni di definizione del programma
		ar_entryDataDivision = this.programCobol.entriesData();
		
		// Scan reverse istruzioni di data division fino a incontrare uno statement Fd
		for (i = numInstrDef - 1; i > 0; i--) {
			
			entryDataDivision = ar_entryDataDivision[i];
			
			// Non è una istruzione di data Division (tipo FD, SD etc.)
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataStruct)) {
				continue;
			}
			
			instructionDataDivision = (InstructionCobolDataStruct) entryDataDivision.getInstruction();
			
			// Non è uno statement Fd: skip
			if (instructionDataDivision.getTypeInstr() != EnumCobolReservedWords.DATA_DIV_FD) {
				continue;
			}
			
			fileName = (String) instructionDataDivision.getMapDescriptorObject("$FILE$");
		    break;
			
		} // end-for

		// Fd non trovata: elaborazione interrotta
		if (fileName.equals("")) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_SOURCE_ANALYSIS);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0027", recordNameWrite, excp, this.programName, recordNameWrite);
			instruction.setSemanticError(true);
			return "";
		}
		
		// Internal file name rwecuperato da Fd e restituito al chiamante
		
		return fileName;
	}


	

 
    /*
     * 
     * Esamina e aggiorna ricorsivamente la lunghezza dei gruppi
     * sotto il livello 01 di partenza e più annidati.
     * Per ogni campo, di gruppo o meno aggiorna la posizione 0-based
     * Restituisce al chiamante la lunghezza totale in bytes del livello 01.
     * Calcola e memorizza la lunghezza di ogni gruppo interno.
     * 
     */
	private int updateGroupsLengthRecursive(InnerGroupSize igs, int iStart, boolean isActiveGroup, int firstLevelUnderGroup) {
        
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		InstructionCobolDataItem dataItemCobol = null;
		InstructionCobolDataItem dataItemCobolFirstUnderGroup = null;
		int lngBytesGroupCumulative = 0;
		int lngBytesGroupRecursive = 0;
		int lngBytesOccurs = 0;
		
		ar_entryDataDivision = this.programCobol.entriesData();

		// Ciclo generale di analisi data division a partire dal primo campo sotto il gruppo
		for (igs.i = iStart; igs.i <= igs.iEndLvl01; igs.i++) {
			
			entryDataDivision = ar_entryDataDivision[igs.i];
			
			// Non è un data item: skip
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {
				continue;
			}

			dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
			
			// Fine gruppo sotto analisi: return al chiamante lunghezza calcolata 
			if (isActiveGroup && dataItemCobol.getLevelNumber() < firstLevelUnderGroup) {
				return lngBytesGroupCumulative;
			}
			
			// Livello 66 o 88, non aumentano lunghezza gruppo: skip
			if (dataItemCobol.getLevelNumber() == 66
			||  dataItemCobol.getLevelNumber() == 88) {
				continue;
			}

			// E' un campo elementare semplice redefines con picture: skip 
			if (dataItemCobol.isRedefinesClause()
			&&  dataItemCobol.isPictureClause()) {
				continue;
			}

			// E' un campo elementare semplice renames con picture: skip 
			if (dataItemCobol.isRenamesClause()
			&&  dataItemCobol.isPictureClause()) {
				continue;
			}

			// E' un campo elementare occursato: totalizzo 
			if (dataItemCobol.isPictureClause() 
			&&  dataItemCobol.isOccursClause()) {
				lngBytesGroupCumulative = lngBytesGroupCumulative + dataItemCobol.getSizeBytes();
				continue;
			}

			// E' un nuovo campo di gruppo dentro quello corrente   
			// o  un nuovo campo di gruppo dentro quello corrente con occurs 
			// o  un nuovo campo di gruppo dentro quello corrente con redefines 
			// o  un nuovo campo di gruppo dentro quello corrente con redefines e occurs: rilancio analisi ricorsiva
			if ((dataItemCobol.isGroupField())
			||  (dataItemCobol.isOccursClause()     &&  !dataItemCobol.isPictureClause())
			||  (dataItemCobol.isRedefinesClause()  &&  !dataItemCobol.isPictureClause())) {
				
				// Campo occurs ultimo del gruppo corrente in analisi: calcolo lunghezza e return al caller
				if (dataItemCobol.isOccursClause() && igs.i == igs.iEndLvl01) {
					lngBytesGroupCumulative = lngBytesGroupCumulative + dataItemCobol.getSizeBytes() * dataItemCobol.getOccursNumber();
					return lngBytesGroupCumulative;
				}
				
				// Cerco primo campo del gruppo, bypassando eventuali copy
				for (; igs.i < ar_entryDataDivision.length; igs.i++) {
					entryDataDivision = ar_entryDataDivision[igs.i];
					if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
					break;
				}
				dataItemCobolFirstUnderGroup = (InstructionCobolDataItem) entryDataDivision.getInstruction();
				lngBytesGroupRecursive = updateGroupsLengthRecursive(igs, igs.i + 1, true, dataItemCobolFirstUnderGroup.getLevelNumber()); // Attivazione ricorsiva sul nuovo gruppo
				
				// Normale gruppo non redefines: aggiorno lunghezza totale 
				if (!dataItemCobol.isRedefinesClause() && !dataItemCobol.isOccursClause()) {
					dataItemCobol.setSizeBytes(lngBytesGroupRecursive);				   	// Update lunghezzsa gruppo nel data item
					lngBytesGroupCumulative = lngBytesGroupCumulative + lngBytesGroupRecursive;
					igs.i--;
				} // end-if
				
				// Occurs di gruppo non redefines: aggiorno lunghezza totale tenendo conto del numero di occorrenze
				if (dataItemCobol.isOccursClause() && !dataItemCobol.isRedefinesClause() && !dataItemCobol.isPictureClause()) {
					lngBytesOccurs = lngBytesGroupRecursive * dataItemCobol.getOccursNumber();
					dataItemCobol.setSizeBytes(lngBytesOccurs);	 						// Update lunghezza gruppo nel data item
					lngBytesGroupCumulative = lngBytesGroupCumulative + lngBytesOccurs;
					// E' lultima occurs del gruppo corrente: return al chiamante
					if (igs.i == igs.iEndLvl01) {
						return lngBytesGroupCumulative;
					}
					igs.i--;
				} // end-if

				// Occurs di gruppo redefines: non aggiorno lunghezza cumulativa 
				if (dataItemCobol.isOccursClause() && !dataItemCobol.isRedefinesClause() && !dataItemCobol.isPictureClause()) {
					lngBytesOccurs = lngBytesGroupRecursive * dataItemCobol.getOccursNumber();
					dataItemCobol.setSizeBytes(lngBytesOccurs);	 						// Update lunghezzsa gruppo nel data item
					igs.i--;
				} // end-if

				// Redefines di gruppo non occurs: non aggiorno lunghezza cumulativa 
				if (dataItemCobol.isRedefinesClause() && !dataItemCobol.isOccursClause() && !dataItemCobol.isPictureClause()) {
					dataItemCobol.setSizeBytes(lngBytesGroupRecursive);				   // Update lunghezza redefines nel data item
					igs.i--;
				} // end-if

			} // end-if
			
			
			// E' un campo elementare semplice non redefines: totalizzo nel gruppo corrente
			if (!dataItemCobol.isGroupField() 
			&&  !dataItemCobol.isRedefinesClause()
			&&  !dataItemCobol.isOccursClause()) {
				lngBytesGroupCumulative = lngBytesGroupCumulative + dataItemCobol.getSizeBytes();
			}
			
		} // end-for

		// Return lunghezza calcolata dell'ultimo campo dell'ultimo gruppo
		
		return lngBytesGroupCumulative;
	}

   /*
	* Viene aggiornata la posizione nell'ambito del gruppo a livello 01, 
	* per ogni campo definito.
	* Dal momento che il calcolo della posizione non può essere sempre sequenziale,
	* con incremento delle lunghezze, a causa delle definizioni redefines,
	* il processo viene implementato ricorsivamente.
	* Il campi di gruppo redefines possono anche essere di lunghezza inferiore
	* ai campi ridefiniti.
	* 
	*/
	private void updateDataItemPosRecursive(InnerGroupSize igs) {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entryDataDivision= null;
		ProgramCobolEntry<? extends Instruction> entryDataDivision = null;
		ProgramCobolEntry<? extends Instruction> entryRedefined = null;
		ProgramCobolEntry<? extends Instruction> entryRenamed = null;
		InstructionCobolDataItem dataItemCobol = null;
		InstructionCobolDataItem dataItemCobolLoop = null;
		String redefinesDataName = "";
		String renamesDataName = "";
		int[] ar_pointer = null;
		int pointerDef = 0;
		int lvlOccurs = 0;
		int iFieldStart = 0;
		int iFieldEnd = 0;
		int iFieldStartRed = 0;
		int iFieldEndRed = 0;
		int posField = 0;
		int i = 0;
		int l = 0;
		int iFirstGood = 0;
		
		// Caricamento variabili di contesto
		ar_entryDataDivision = this.programCobol.entriesData();
		iFieldStart = igs.iPosStart;
		iFieldEnd = igs.iPosEnd;
		posField = igs.curPosField;
		
		// Ciclo generale di analisi data division a partire dal primo campo sotto il gruppo
		for (i = iFieldStart + 1; i <= iFieldEnd; i++) {

			iFirstGood = getFirstDataEntryWithDataItem(i, iFieldEnd);
			if (iFirstGood > i) {
				i = iFirstGood - 1;
				continue;
			}
			
			entryDataDivision = ar_entryDataDivision[i];
			
			// Non è un data item: skip
			if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {
				continue;
			}

			dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
			
			// Livello 88: skip
			if (dataItemCobol.getLevelNumber() == 88) {
				continue;
			}

			// E' un campo elementare semplice e/o occursato no redefines con picture o usage pointer
			if (!dataItemCobol.isGroupField() 
			&&  !dataItemCobol.isRedefinesClause()
			&&  (dataItemCobol.isPictureClause()    || 
				  (   !dataItemCobol.isPictureClause() 
				   &&  dataItemCobol.isUsageClause() 
				   && (dataItemCobol.getUsage() == EnumCobolUsage.USAGE_POINTER    || 
					   dataItemCobol.getUsage() == EnumCobolUsage.USAGE_PROCEDURE_POINTER
				      )
				  )
				)
			   ) {
				entryDataDivision.setPos(posField);
				posField = posField + dataItemCobol.getSizeBytes();
				continue;
			}
			
			// E' un campo elementare semplice redefines con picture.
			// La posizione è quella del campo ridefinito.
			// La posizione progressiva NON viene alterata
			if (!dataItemCobol.isGroupField() 
			&&   dataItemCobol.isPictureClause()
			&&   dataItemCobol.isRedefinesClause()) {
				redefinesDataName = dataItemCobol.getRedefinesDataName();
				ar_pointer = this.programCobol.getXrefSymbolDefData(redefinesDataName);
				pointerDef = ar_pointer[0];
				entryRedefined = this.programCobol.entryDataDivision(pointerDef);
				entryDataDivision.setPos(entryRedefined.getPos());
				continue;
			}

			// E' un campo redefines di gruppo.
			// La posizione iniziale è quella del campo ridefinito. 
			// Viene attivato ricorsivamente questo metodo per NON alterare il contesto,
			// estraendo la porzione di campi ridefinenti
			if (dataItemCobol.isRedefinesClause() 
			&&  dataItemCobol.isGroupField()) {
				// Estrazione entry campo ridefinito, update posizione campo corrente
				redefinesDataName = dataItemCobol.getRedefinesDataName();
				ar_pointer = this.programCobol.getXrefSymbolDefData(redefinesDataName);
				pointerDef = ar_pointer[0];
				entryRedefined = this.programCobol.entryDataDivision(pointerDef);
				entryDataDivision.setPos(entryRedefined.getPos());
				// Estrazione pointer a inizio campo ridefinente 
				iFieldStartRed = getFirstDataEntryWithDataItem(i + 1, iFieldEnd);
				// Estrazione pointer a fine campo ridefinente 
				for (l = iFieldStartRed; l <= iFieldEnd; l++) {
					if (!(this.programCobol.entryDataDivision(l).getInstruction() instanceof InstructionCobolDataItem)) {continue;}
					dataItemCobolLoop = (InstructionCobolDataItem) this.programCobol.entryDataDivision(l).getInstruction();
					if (dataItemCobolLoop.getLevelNumber() <= dataItemCobol.getLevelNumber()) {break;}
					iFieldEndRed = l;
				}
	    		// Attivazione ricorsiva sui soli campi ridefinenti
				igs.iPosStart = iFieldStartRed;							// Da campo redefines  
				igs.iPosEnd = iFieldEndRed;								// A campo
				igs.curPosField = entryRedefined.getPos();				// Da posizione
				updateDataItemPosRecursive(igs);
				i = iFieldEndRed;                                       // Continuo dal campo successivo all'ultimo campo ridefinente
				continue;
			}
			
			// E' un campo renames.
			// La posizione è quella del campo rinominato.
			if (dataItemCobol.isRenamesClause()) {
				renamesDataName = dataItemCobol.getRenamesDataName();
				ar_pointer = this.programCobol.getXrefSymbolDefData(renamesDataName);
				if (ar_pointer.length == 1) {
					pointerDef = ar_pointer[0];
				} else {
					for (int j : ar_pointer) {
						if (j <  i && j > iFieldStart) {
							pointerDef = j;
						}
					}
				}
				entryRenamed = this.programCobol.entryDataDivision(pointerDef);
				entryDataDivision.setPos(entryRenamed.getPos());
				continue;
			}

			// E' un campo di gruppo semplice no occurs: la posizione non aumenta
			if (dataItemCobol.isGroupField() 
			&& !dataItemCobol.isRedefinesClause()
			&& !dataItemCobol.isPictureClause()) {
				entryDataDivision.setPos(posField);
				continue;
			}

			// E' un campo di gruppo occurs.
			// La definizione contiene la lunghezza complessiva, di eventuali altre dimensioni.
			// Bypass campi successivi fino a esaurimento definizioni Occurs
			if (dataItemCobol.isGroupField() 
			&&  dataItemCobol.isOccursClause()
			&& !dataItemCobol.isRedefinesClause()
			&& !dataItemCobol.isPictureClause()) {
				entryDataDivision.setPos(posField);
				posField = posField + dataItemCobol.getSizeBytes();
				lvlOccurs = dataItemCobol.getLevelNumber();
				// Scan definizioni sotto la occurs
				for (i++; i <= iFieldEnd; i++) {
					entryDataDivision = ar_entryDataDivision[i];
					if (!(entryDataDivision.getInstruction() instanceof InstructionCobolDataItem)) {continue;}
					dataItemCobol = (InstructionCobolDataItem) entryDataDivision.getInstruction();
					if (dataItemCobol.getLevelNumber() <= lvlOccurs) {
						i--;
						break;
					}
				}
				continue;
			}
			
		} // end-for

	}

    /* -------------------------------------------------------------------------------
     * Restituzione primo entry con una definizione dati a partire dal numero fornito 
     * -------------------------------------------------------------------------------
     * 
     * 
     */
	private int getFirstDataEntryWithDataItem(int iStart, int iFieldEnd) {
		
		int i = 0;

		for (i = iStart; i < iFieldEnd; i++) {
			
			if (!(this.programCobol.entryDataDivision(i).getInstruction() instanceof InstructionCobolDataItem)) {
				continue;
			}
			return  i;
		}
	return iFieldEnd;
	}
    /* -----------------------------------------------------------------------------------
     * Restituzione precedente entry con una definizione dati a partire dal numero fornito 
     * -----------------------------------------------------------------------------------
     * 
     */
	@SuppressWarnings("unused")
	private int getPrecDataEntryWithDataItem(int iStart, int iFieldEnd) {
		
		int i = 0;

		for (i = iStart; i >= 0; i--) {
			
			if (!(this.programCobol.entryDataDivision(i).getInstruction() instanceof InstructionCobolDataItem)) {
				continue;
			}
			return  i;
		}
	return 0;
}


	/*
	 * Impostazione di tutti i sottocampi come simboli di input o output, per l'istruzione
	 * 
	 * Viene fornita in input un'istruzione e un oggetto DataItemCobolIdentifier,
	 * che rappresenta un campo e la sua qualificazione di utilizzo, per esempio
	 * con una clausola OF oppure degli indici.
	 * Nel caso il Data Item sia un campo di gruppo, tutti i suoi sottocampi, siano
	 * o meno anche loro dei campi di gruppo, vengono dichiarati come simboli di output
	 * per l'istruzione.
	 * 
	 */
    public void addInstructionSymbolsUsedAndDefinedGroup(Instruction instruction
													   , DataItemCobolIdentifier dataItemCobolIdentifier
													   , String typeUseSymbol
														 )  {
		
     	InstructionCobolDataItem dataItemDefinition = null;		// Descrittore campo
    	DataItemQualifier dataItemQualifier = null;				// Qualificatore di utilizzo 
    	ExceptionAmrita excp = null; 
    	
       	int ar_DataItemsUnderGroupPointer[] = null;				// Pointers a definizioni sotto il campo di gruppo fornito
    	int ar_DataItemsDefinitionPointer[] = null;				// Pointers a definizioni di campi
    	Integer dataNamePointer = 0;								// Ponter singolo campo
    	String dataItemName = "";								// Nome campo
    	String underGroupName = "";								// Gruppo dichiarato in clausolas OF
  
    	
		// Non si tratta di un data item ma di una literal: exit
		if (dataItemCobolIdentifier.getIdentifierType() != EnumCobolReservedWords.DATA_DIV_DATA_ITEM ) {
			return;
		}
    	
 		// Estrazione nome campo e qualificatore di utilizzo
		dataItemQualifier = dataItemCobolIdentifier.getQualifier();
		dataItemName = dataItemCobolIdentifier.getNameIdentifier();
		
		// Nome campo non definito: errore di programma o sorgente corrotto
		if (dataItemCobolIdentifier.getIdentifierType() == EnumCobolReservedWords.DATA_DIV_DATA_ITEM && !this.programCobol.isSymbolDefined(dataItemName)) {
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_INDEXING_INSTRUCTION);
			instruction.setInfoError(EnumMessageType.ERROR_INTERNAL, "EI0023", dataItemName, excp, this.programName, dataItemName);
			instruction.setSemanticError(true);
			return;
		}
		
		// Eventuale qualificazione del campo sotto un gruppo specifico (clausola OF group-name)
		if (dataItemQualifier != null) {
			underGroupName = dataItemQualifier.getGroupNameField();
		}
		
		// Individuazione pointer a definizione campo (qualificato da gruppo oppure no)
		if (underGroupName.equals("")) {
			ar_DataItemsDefinitionPointer = this.programCobol.dataItemPointers(dataItemName);
			dataNamePointer = ar_DataItemsDefinitionPointer[0];
		} else {
			dataNamePointer = this.programCobol.dataItemPointer(dataItemName, underGroupName);
		}
		
		// Campo non definito o sorgente corrotto
		if (dataNamePointer < 0 || dataNamePointer == null) {
			instruction.setSemanticError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", dataItemName, excp, new String[]{this.programName});

		}
		
		// Descrittore definizione campo
		dataItemDefinition = this.programCobol.instructionDataItem(dataNamePointer);
		
		// Il campo non è un gruppo: return
		if (!dataItemDefinition.isGroupField()) {
			return;
		}
			
		// Estrazione di tutti i campi definiti nel gruppo, anche se a loro volta gruppi
		ar_DataItemsUnderGroupPointer = this.programCobol.dataItemsUnderGroupPointers(dataNamePointer, DATA_ITEMS_ALL);
		
		// Scan pointer a campi definiti sotto il campo di gruppo fornito in input
		for (int i : ar_DataItemsUnderGroupPointer) {
			
			// Estrazione nome campo 
			dataItemName = this.programCobol.dataItemName(i);
			if (dataItemName.equals("FILLER")) {
				continue;
			}
			
			//Impostazione come simbolo in input o in output per l'istruzione
			if (typeUseSymbol.equals(INSTR_USE_DATA_ITEM_INPUT)) {
				instruction.addSymbolInput(dataItemName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			} else {
				instruction.addSymbolOutput(dataItemName, EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
			}
		}
		
		return;
	}



	

	/*
	 * Logging istruzioni errate con tutte le informazioni disponibili
	 * al momento del parsing
	 * 
	 * 
	 */
	private void loggingParsingErrorsWarning() {
		
		ProgramCobolEntry<? extends Instruction>[] ar_entries = null;
		
		// Si stanno analizzando moduli copy, non un programma
		if (this.programCobol == null) {
			return;
		}
		
		logMessage(EnumMessageType.INFORMATION, "MI0300", this.pgmNameUnderParsing);				
		
		// Identification Division
		ar_entries = this.programCobol.entriesIdentification();
		loggingParsingErrorsWarningDivision(ar_entries);

		// Environment Division
		ar_entries = this.programCobol.entriesEnvironment();
		loggingParsingErrorsWarningDivision(ar_entries);
		

		// Data Division
		ar_entries = this.programCobol.entriesData();
		loggingParsingErrorsWarningDivision(ar_entries);
		
		// Procedure Division
		ar_entries = this.programCobol.entriesProcedure();
		loggingParsingErrorsWarningDivision(ar_entries);
		
		logMessage(EnumMessageType.INFORMATION, "MI0301", this.pgmNameUnderParsing);				
		
	}
  


	/*
	 *  Logging istruzioni errate o con warning di specifica divisione
	 * 
	 */
	private void loggingParsingErrorsWarningDivision(ProgramCobolEntry<? extends Instruction>[] ar_entries) {
		
		Instruction instrGeneric = null;

		
		// Scan Istruzioni  
		for (ProgramCobolEntry<? extends Instruction> entryInstrucion : ar_entries) {
			
			instrGeneric = entryInstrucion.getInstruction();
			
			// Istruzione parsata e analizzata senza errori: continue
			if (!instrGeneric.isParsingError() 
			&&  !instrGeneric.isSemanticError()
			&&  !instrGeneric.isWarning()) {
				continue;
			}
			
			// Errori di parsing o di analisi semantica identificatori
				
			// Messagio e informazioni generati al momento dell'intercettamento dell'errore
			if (di.optStackTraceOnParsingError) {
				logMessage(instrGeneric.getMsgType(), instrGeneric.getMsgCode(), instrGeneric.getExcpError(),  instrGeneric.getMsgParm());
			} else {
				logMessage(instrGeneric.getMsgType(), instrGeneric.getMsgCode(), instrGeneric.getMsgParm());
			}
			
			// Logging dettaglio istruzione in errore
			logMessageDetail(instrGeneric);
			
		} // end-for
	}

    
    /*
     * Logging informazioni di dettaglio istruzione
     */
	private void logMessageDetail(Instruction instrGeneric) {
		
		logMessage(EnumMessageType.INFORMATION
			 	 , "MI0044" 
				 , this.pgmNameUnderParsing
				 , instrGeneric.getSourceInstr()
				 , instrGeneric.getTokenInError()
				 , instrGeneric.getRowStartSource()+""
				 , instrGeneric.getPosStartInstr()+"" 
				 , instrGeneric.getRowEndSource()+""
				 , instrGeneric.getPosEndInstr() +""
		           );
	}


	/*
	 * 
	 * Caricamento Map con istruzioni da correlare di fine blocco e con istruzioni possibili blocco di appartenenza
	 * Questa map ha come chiave l'istruzione di inzio blocco o da correlare a quella di inizio blocco: IF .. ELSE, EVALUATE, WHEN, ...
	 * Come value ha una ArrayList con: L'istruzione di chiusura se prevista o tutte le istruzioni di inizio blocco possibili (exception)
	 *
	 * 
	 */
	private void populateMapInstrRelated(Map<EnumCobolReservedWords, ArrayList<EnumCobolReservedWords>> map_InstrRelated) {
		
		// Tipologie possibili di istruzioni Owner di quella in stack
	    ArrayList<EnumCobolReservedWords> al_InstrRelated = null;
        
	    // Caricamento map con istruzioni di fine blocco END-xxx
	    for (EnumCobolReservedWords instrCobol : EnumCobolReservedWords.values()) {
	    	
			// Non è un'istruzione di chiusura: skip
	    	if (!instrCobol.getValueText1().startsWith("END-")) {
				continue;
			}
	    	
		    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
		    al_InstrRelated.add(instrCobol);	                                                // Istruzione owner (come IF se quella corrente è END-IF)
		    map_InstrRelated.put(instrCobol.getCobolInstrRelated(), al_InstrRelated );		// map istruzione chiusura 
	    	
		}
	    
	    // ELSE
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_IF);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_ELSE, al_InstrRelated);

	    // NEXT SENTENCE
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_IF);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NEXT_SENTENCE, al_InstrRelated);

	    // CONTINUE
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_PERFORM);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_CONTINUE, al_InstrRelated);

	    // WHEN di EVALUATE/SEARCH
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_EVALUATE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_SEARCH);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_WHEN_EVALUATE_SEARCH, al_InstrRelated);
	    
	    // ON_SIZE_ERROR NOT_ON_SIZE_ERROR
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_ADD);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_SUBTRACT);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_COMPUTE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_DIVIDE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_MULTIPLY);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_ON_SIZE_ERROR, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_ON_SIZE_ERROR, al_InstrRelated);
	    
	    // ON_OVERFLOW NOT_ON_OVERFLOW
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_CALL);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_STRING);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_UNSTRING);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_ON_OVERFLOW, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_ON_OVERFLOW, al_InstrRelated);
	    
	    // ON_EXCEPTION NOT_ON_EXCEPTION
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_CALL);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_ON_EXCEPTION, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_ON_EXCEPTION, al_InstrRelated);
	    
	    // AT_END NOT_AT_END
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_READ);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_RETURN);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_SEARCH);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_AT_END, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_AT_END, al_InstrRelated);

	    // AT_END_OF_PAGE NOT_AT_END_OF_PAGE
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_WRITE);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_AT_END_OF_PAGE, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_AT_END_OF_PAGE, al_InstrRelated);

	    // AT_EOP NOT_AT_EOP
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_WRITE);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_AT_EOP, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_AT_EOP, al_InstrRelated);

	    // INVALID_KEY NOT_INVALID_KEY
	    al_InstrRelated = new ArrayList<EnumCobolReservedWords> ();
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_DELETE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_READ);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_WRITE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_REWRITE);
	    al_InstrRelated.add(EnumCobolReservedWords.PROC_START);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_INVALID_KEY, al_InstrRelated);
	    map_InstrRelated.put(EnumCobolReservedWords.PROC_NOT_INVALID_KEY, al_InstrRelated);
	}


    
	/*
	 * 
	 * Viene gestito il reperimento del modulo Copy già analizzato e serializzato.
	 * 
	 * Se il copy serializzato non esiste, restituisce null.
	 * 
	 * @return CopyCobol copy deserializzato
	 */
    private CopyCobol getCopyCobolCoded(String copyNameToInclude   // Contesto chiamante (programma o altro copy)
 							    	 ) throws ExceptionAmrita  {
							    	
		CopyCobol copyCobolUnserialized = null;
        
		// Allocazioni per recupero sorgente copy
		SourceManager sm = new SourceManager(ucfg);
 		
		// Copy serializzato non presente nella libreria dei copy serializzati
		if (sm.fileInfo(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjCopy(), copyNameToInclude, SUFFIX_SERIALIZED_COPY) == null) {
			return null;
		}
		
		// Deserializzo copy
		copyCobolUnserialized = (CopyCobol) getSerialized(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjCopy(), copyNameToInclude, SUFFIX_SERIALIZED_COPY);
		
		return copyCobolUnserialized;
	}

	/*
	 * 
	 * Viene gestito il reperimento del programma già analizzato e serializzato.
	 * 
	 * Se il copy serializzato non esiste, restituisce null.
	 * 
	 * @return CopyCobol copy deserializzato
	 */
    private ProgramCobol getProgramCobolCoded(String programName   // Contesto chiamante (programma o altro copy)
 							    	         ) throws ExceptionAmrita  {
							    	
    	ProgramCobol pgmCobolUnserialized = null;
        
		// Allocazioni per recupero sorgente copy
		SourceManager sm = new SourceManager(ucfg);
 		
		// Copy serializzato non presente nella libreria dei copy serializzati
		if (sm.fileInfo(ucfg.getDirCobolObjPgm(), programName, SUFFIX_SERIALIZED_PGM) == null) {
			return null;
		}
		
		// Deserializzo copy
		pgmCobolUnserialized = (ProgramCobol) getSerialized(ucfg.getPathUser() + File.separator + ucfg.getDirCobolObjPgm(), programName, SUFFIX_SERIALIZED_PGM);
		
		return pgmCobolUnserialized;
	}

    
	/* -------------------------------------------------------------
	 * Viene restituito il descrittore del sorgente del copy.
	 * -------------------------------------------------------------
	 * 
	 * Viene gestito il reperimento del copy sorgente da analizzare.
	 * Si verifica se il copy è già stato catalogato a fronte di una LibraryScan.
	 * Lo si cerca prima con il sistema/sottosistema corrente e, se non lo si trova,
	 * si cerca su qualsiasi sistema/sottosistema.
	 * 
	 * Se il copy è già catalogato nel sistema a fronte di una LibraryScan,
	 * si recupera direttamente il copy con il path completo memorizzato.
	 * 
	 * Se il copy non è già catalogato nel sistema si cerca nell'elenco
	 * delle librerie in search specificate nelle direttive di esecuzione.<br>
	 * 
	 * Se non sono specificate librerie in source, oppure se il sorgente non viene 
	 * trovato in queste librerie, si cerca nella stessa libreria del sorgente sotto analisi.<br>
	 * Se il sorgente non viene trovato, restituisce null.
	 * 
	 * Il copy, se non già catalogato, viene cercato con i suffissi specificati nelle
	 * direttive di esecuzione. Se questi non sono specificati si utilizza lo stesso
	 * suffisso del programma in esecuzione.
	 * 
	 * 
	 * @return SourceInput copy  
	 */
    private SourceInput getSourceCopy(InnerContextAnalysis ictx   // Contesto chiamante (programma o altro copy)
    		                        , String copyName          	  // Copy da includere
								     ) throws ExceptionAmrita, SQLException  {
							    	
        InnerGetSource igs = null;                      // Info oggett SOURCE_MEMBER
    	String libraryPath = "";
        String copyPathComplete = "";					// Path completo source copy da OBJT
        String copyPathLibrary = "";					// Path libreria copy
        String copyPathSuffix = "";					    // Suffisso copy
		int iDot = 0;
		int iLastBackslash = 0;
		int i = 0;
        
		// Allocazioni per recupero sorgente copy
		SourceInput siCopy = null;
		SourceManager sm = new SourceManager(ucfg);
		                                                                                                                                                                                                                                                                                                                                                                                                                               
        // Initial
		ictx.isCopySourceDetected = false;				// Suppongo copu NON acquisito da LibraryScan
		ictx.isCopyFoundOnPathSourceDetected = false;
		
		
		/////////////////////////////////////////////////////////////////////
		// Gestione copy già acquisito da ScanLibrary
		/////////////////////////////////////////////////////////////////////
 
		// Ricerca path 
		igs = new InnerGetSource();
		copyPathComplete = getCopyPathAcquired(copyName, igs);
		ictx.copyPathSourceDetected = copyPathComplete; 
		
		// Copy già acquisito nel sistema e path disponibile
		if (!copyPathComplete.equals("")) {
			ictx.isCopySourceDetected = true;
			ictx.sysCopyNameToInclude = igs.objectSourceMember.getSystem();
			ictx.subSysCopyNameToInclude = igs.objectSourceMember.getSubSystem();
			// Estrazione library path e suffix
			iDot = copyPathComplete.lastIndexOf(".");
			iLastBackslash = copyPathComplete.lastIndexOf("\\");
			if (iLastBackslash < 0) {iLastBackslash = copyPathComplete.lastIndexOf("/");}
			if (iDot > 0) {
				copyPathLibrary = copyPathComplete.substring(0, iLastBackslash + 1);
				copyPathSuffix = copyPathComplete.substring(iDot + 1);
			} else {
				copyPathLibrary = copyPathComplete.substring(0, iLastBackslash + 1);
			}
			
			// Recupero sorgente per attivazione processo di analisi ricorsivo
			siCopy = sm.getSource(copyPathLibrary				// Libreria
			                	 ,copyName						// Nome copy
			                     ,copyPathSuffix     			// Suffix
			                     ,false                         // Nessun controllo sul tipo sorgente
			                     ,false                         // Nessuna informazione completa di file system
			                     );
			
			// Sorgente individuato: exit
			if (siCopy != null) {
				ictx.isCopyFoundOnPathSourceDetected = true;
				siCopy.setSystemOwner(igs.objectSourceMember.getSystemOwner());	
				siCopy.setSubSystemOwner(igs.objectSourceMember.getSubSystemOwner());	
				return siCopy;
			}
            
			// Sorgente non trovato nel path di analisi
			
			return null;
		}
		
		
		/////////////////////////////////////////////////////////////////////
		// Gestione copy da individuare nelle librerie in search
		/////////////////////////////////////////////////////////////////////
				
		// Scan librerie in search nel pilot di esecuzione
		for (String librarySearchCode : this.di.al_librarySourceSearchCode) {
			
			// Scan librerie definite nel pilot di esecuzione
            for (i = 0; i < this.di.al_libraryCode.size(); i++) {
				if (this.di.al_libraryCode.get(i).equals(librarySearchCode)) {
					break;
				}
			}
			
			// Nome libreria in search non definita nel pilot: skip
            if (i >= this.di.al_libraryCode.size()) {
				continue;
			}
            
            libraryPath = this.di.al_libraryPath.get(i);
            
            // Nessuna direttiva FILE_SUFFIX_COPY: si cerca con lo stesso suffisso del programma
            if (di.al_fileSuffixCopy.size() == 0) {
    			// Recupero sorgente per attivazione processo di analisi ricorsivo
    			siCopy = sm.getSource(libraryPath					// Ricerca nella libreria in path
    			                	 ,copyName						// Estratto dallo statement Copy 
    			                     ,ictx.si.getSourceSuffix()     // Ricerca source con lo stesso suffisso del chiamante
    			                     ,false                         // Nessun controllo sul tipo sorgente
    			                     ,false                         // Nessuna informazione completa di file system
    			                     );
    			
    			// Sorgente individuato con lo stesso suffisso del programma: exit
    			if (siCopy != null) {
    				siCopy.setLibraryCode(librarySearchCode);
    				return siCopy;
    			}
       			// Si cerca senza suffisoo
    			siCopy = sm.getSource(libraryPath					// Ricerca nella libreria in path
    			                	 ,copyName						// Estratto dallo statement Copy 
    			                     ,""     						// Nessun suffisso
    			                     ,false                         // Nessun controllo sul tipo sorgente
    			                     ,false                         // Nessuna informazione completa di file system
    			                     );
    			
    			// Sorgente individuato senza suffisso: exit
    			if (siCopy != null) {
    				siCopy.setLibraryCode(librarySearchCode);
    				return siCopy;
    			}
   			
    			continue;					// next library
			}
            
            // Direttiva/e FILE_SUFFIX_COPY presente/i: si cerca con il suffisso sulla direttiva
            for (String suffixOnDirective : di.al_fileSuffixCopy) {
      			siCopy = sm.getSource(libraryPath					// Ricerca nella libreria in path
    			                	 ,copyName						// Estratto dallo statement Copy 
    			                     ,suffixOnDirective             // Ricerca source concon il suffisso dichiarato nel pilot di esecuzione
    			                     ,false                         // Nessun controllo sul tipo sorgente
    			                     ,false                         // Nessuna informazione completa di file system
    			                     );
    			
    			// Sorgente individuato: exit
    			if (siCopy != null) {
    				siCopy.setLibraryCode(librarySearchCode);
    				return siCopy;
    			}
				
			}
			
            // Cerco senza suffisso
  			siCopy = sm.getSource(libraryPath						// Ricerca nella libreria in path
  					,copyName										// Estratto dallo statement Copy 
                    ,""             				 				// Ricerca source senza suffisso
                    ,false                         					// Nessun controllo sul tipo sorgente
                    ,false                         					// Nessuna informazione completa di file system
                    );
			// Sorgente individuato senza suffisso: exit
			if (siCopy != null) {
				siCopy.setLibraryCode(librarySearchCode);
				return siCopy;
			}
          
            
			// Next libreria
			
		} // end-for library
		
		// Sorgente non trovato nelle librerie in search: cerco nella stessa directory del sorgente sotto analisi con i suffissi esterni
        // Scan suffissi dichiarati
        for (String suffixOnDirective : di.al_fileSuffixCopy) {
  			siCopy = sm.getSource(ictx.si.getDirInput()			// Ricerca nella libreria in path
			                	 ,copyName						// Estratto dallo statement Copy 
			                     ,suffixOnDirective             // Ricerca source con il suffisso dichiarato nel pilot di esecuzione
			                     ,false                         // Nessun controllo sul tipo sorgente
			                     ,false                         // Nessuna informazione completa di file system
			                     );
			
			// Sorgente individuato: exit
			if (siCopy != null) {
				siCopy.setLibraryCode("");
				return siCopy;
			}
		}

		
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		// Ultimo tentativo: si cerca nella stessa directory del programma in analisi con lo stesso suffisso
		//////////////////////////////////////////////////////////////////////////////////////////////////////
		
		// Sorgente non trovato nelle librerie in search: cerco nella stessa directory del sorgente sotto analisi con lo stesso suffisso
		if (siCopy == null) {
			siCopy = sm.getSource(ictx.si.getDirInput()			// Ricerca nella stessa libreria corrente
			                	 ,copyName				        // Estratto dallo statement Copy 
			                     ,ictx.si.getSourceSuffix()     // Ricerca source con lo stesso suffisso del programma
			                     ,false                         // Nessun controllo sul tipo sorgente
			                     ,false                         // Nessuna informazione completa di file system
			                     );
		}
		// Sorgente individuato: exit
		if (siCopy != null) {
			siCopy.setLibraryCode("");
			return siCopy;
		}

		siCopy = sm.getSource(ictx.si.getDirInput()				// Ricerca nella stessa libreria corrente
           	 				,copyName				        	// Estratto dallo statement Copy 
           	 				,""     							// Senza suffisso
           	 				,false                         		// Nessun controllo sul tipo sorgente
           	 				,false                        	    // Nessuna informazione completa di file system
                			);

		return siCopy;
	}


    
    /* -----------------------------------------------------------
     * Recupero path completo copy se già acquisito da ScanLibrary 
     * -----------------------------------------------------------
     * 
     * Si cerca  il copy con lo stesso nome in tutti i sottosistemi
     * e si restituisce quello individuato
     * 
     */
	private String getCopyPathAcquired(String copyName, InnerGetSource igs) throws SQLException, ExceptionAmrita {
		
		String copyPathAcquired = "";
		String sameSys = "";
		@SuppressWarnings("unused")
		String sameSubSys = "";
		String sameLibrarySource = "";
		String sameSuffixSource = "";
		String firstSys = "";
		
		// Entities, contenitori dei dati
		EntityObject entityObject = null;
		List<EntityObject> ar_objEntity = null;

		// Lettura oggetti OBJECT_SOURCE_MEMBER per recupero path 
   	    entityObject = new EntityObject();	
      	String whereCondition = "";
      
     	// Composizione Where di lettura oggetto stesso sistema e <> sottosistema, owner
      	whereCondition =  "      idObject = '" + copyName  + "'"
                       +  " AND sys =  '" + this.di.systemInput  + "'" 
                       +  " AND subSys = subSysOwner " 
     	               +  " AND typeObject =  " + EnumObject.OBJECT_SOURCE_MEMBER.ordinal();
 
      	Connection conn = DataBaseConnections.getConnection();
     	IDAOObject eoDAO = (DAOImplObject) AmritaStartup.sqlFactory.getDAOObject(conn, false,false, ucfg);        
     	ar_objEntity = eoDAO.findAllWhere(whereCondition, "");
     	DataBaseConnections.releaseConnection(conn);
     	
     	// Copy non acquisito in nessun sistema/sottosistema
     	if (ar_objEntity.size() == 0) {
         	igs.copyPathAcquired="";
         	igs.objectSourceMember=null;
			return "";
		}
     	
     	// Scan oggetti OBJECT_SOURCE_MEMBER individuati (deve essercene solo 1 nel systema)
     	for (int i = 0; i < ar_objEntity.size(); i++) {    		
     		entityObject = (EntityObject) ar_objEntity.get(i);
     		break;
  		}
     	
     	// Composizione path copy completo
     	copyPathAcquired = entityObject.getLibrarySource() + File.separator + copyName;
     	if (!sameSuffixSource.equals("")) {
     		copyPathAcquired = copyPathAcquired + "." +  entityObject.getSuffixFileSource();
		}
     	
     	igs.copyPathAcquired=copyPathAcquired;
     	igs.objectSourceMember=entityObject;
  
     	 
		return copyPathAcquired;
	} 


	/* -----------------------------------------------------
	 * Normalizzazione identificatori
	 * -----------------------------------------------------
	 * 
	 * Inserimento di space prima e dopo gli operatori.
	 * Eventuali literal presenti arrivano già come token atomici senza
	 * spazi, sostituiti da carattere speciale dal chiamante.
	 * Vengono inseriti spazi prima e dopo gli operatori possibili
	 * Viene scomposta la stringa nelle sue parole  
	 * Le parole separate da operatori meno (-) vengono scomposte
	 * Viene ricomposta una nuova stringa con tutte le parole separate da spazi
	 * 
	 */
	private String normalizeIdentifiers(Instruction instruction, String strInput) {
        
		ExceptionAmrita excp = null;
		Scanner scn = null;
		ArrayList<InnerInstructionWordsEntry> al_reservedWordEntry = null;  
		LiteralCobol literalCobol = null;
		String token = "";
		StringBuffer sb = null;
		String strOutput = "";
		String strWork = "";
		String strBeforeHiphen = "";
		String strAfterHiphen = "";
		String strLiteral = "";
		String strFieldStartingNum = "";
		String chrAfterLiteralNum = "";         // Carattere dopo literal numerica come 123+ o 123F             
		char singleApice = 39;					// Apice singol '
		char doubleApice = 34;					// Doppio apice ""
		boolean isTokenDivided = false;
		boolean isFieldStartingNum = false;     // True indica un campo del tipo 123-AA4307-ZZ
		boolean isCtrlStartingNumToDo = false;  // True indica che il controllo di inizio campo con numeri è da fare 
		int i = 0;
		int j = 0;
		int iEndLiteral = 0;
		
		literalCobol = new LiteralCobol ();
		strWork = strInput + " "; 
		strOutput = strInput; 
		sb = new StringBuffer();
		
  		
        ////////////////////////////////////////////////////////////////////////////
		// (1) Normalizzazione primaria di separazione operandi, operatori e literal
        ////////////////////////////////////////////////////////////////////////////
		  
		for (i = 0; i < strWork.length(); i++) {
			
			// Space: porto in output
			if (strWork.charAt(i) == ' '){
				sb.append(" ");
			    continue;
			}      
			  
			// Verifica se literal valida a partire  dalla posizione fornita
			iEndLiteral = literalCobol.parseLiteral(strWork + " ", i);
   
			// Campo che potrebbe iniziare con un numero, delimitato da space o operatore diverso da - o fine stringa
			if (literalCobol.isLiteralNumInt()) {
				// Impostazione condizione per effettuare il controllo su campo con inizio numerico
				isCtrlStartingNumToDo = false;
				chrAfterLiteralNum = strWork.substring(iEndLiteral + 1, iEndLiteral + 2);
				if (!chrAfterLiteralNum.equals(" ")) {
					al_reservedWordEntry = this.map_ReservedWords.get(chrAfterLiteralNum);
					if (al_reservedWordEntry != null 
					&&  al_reservedWordEntry.get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_OPERATOR
					&&  al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolOperator() == EnumCobolOperator.SUB) {
						isCtrlStartingNumToDo = true;
					}
				}
				// Il controllo si fa se la literal numerica non termina con space o un operatore diverso da -
				if (isCtrlStartingNumToDo) {
					isFieldStartingNum = false;
					// Cerco fine campo
					for (j = iEndLiteral + 1; j < strWork.length(); j++) {
						// Campo con numero iniziale sicuramente terminato, deve essere definito nel programma
						// Se fosse stato separato da - come 123-F-G sarebbe stato intercettato dal test sotto
						if (strWork.charAt(j) == ' ') {
							strFieldStartingNum = strWork.substring(i, j);
							if (this.programCobol != null && this.programCobol.dataItemPointers(strFieldStartingNum) != null) {
								isFieldStartingNum = true;
							}
							break;
						}
						al_reservedWordEntry = this.map_ReservedWords.get(strWork.substring(j, j + 1));
						if (al_reservedWordEntry != null 
						&&  al_reservedWordEntry.get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_OPERATOR
						&&  al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolOperator() != EnumCobolOperator.SUB) {
							strFieldStartingNum = strWork.substring(i, j);
							if (this.programCobol.dataItemPointers(strFieldStartingNum) != null) {
								isFieldStartingNum = true;
							}
							break;
						}
					}
					// Campo valido che inizia con un numero seguito da combinazioni di lettere e/o trattini
					if (isFieldStartingNum) {
						sb.append(" " + strFieldStartingNum + " ");
						i = j - 1;
						continue;
					}
					// Il campo è stato estratto formalmente ma non è definito nel programma.
					// Il chiamante segnalerà l'errore nell'istruzione.
				 }
			}
			
			// Literal alfanumerica o esadecimale o numerica: inserimento blank prima e dopo
			// Sono individuate literal 'Value', X'Value', NX'Value', 2, -45,6, 0,546E-2 etc
			if (literalCobol.isLiteralString() || literalCobol.isLiteralNum()) {
				strLiteral = strWork.substring(i, iEndLiteral + 1);
				sb.append(" " + strLiteral + " ");
				i = iEndLiteral;
				continue;  
			}

			// Operatori di due caratteri
			if (strWork.startsWith(">=", i)
			||  strWork.startsWith("<=", i)
			||  strWork.startsWith("**", i)) {
				sb.append(" " + strWork.substring(i, i + 2) + " ");
				i++;
			    continue;
			}

			// Operatori e separatori di un carattere: , + / * = ) ( : < > 
			// L'operatore - viene trattato successivamente in quanto potrebbe essere parte
			// di campi validi definiti in data division o reserved word cobol
			al_reservedWordEntry = this.map_ReservedWords.get(strWork.substring(i, i + 1));
			if (al_reservedWordEntry != null 
			&&  al_reservedWordEntry.get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_OPERATOR
			&&  al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolOperator() != EnumCobolOperator.SUB) {
				sb.append(" " + strWork.charAt(i) + " ");
				continue;
			}
			
			// Porto in output parola intera fino a primo space o operatore matematico diverso da sub o literal
			for (; i < strWork.length(); i++) {
				al_reservedWordEntry = this.map_ReservedWords.get(strWork.substring(i, i + 1));
				if (strWork.startsWith(" ", i) 
				||  strWork.charAt(i) == singleApice		
				||  strWork.charAt(i) == doubleApice		
				||  (al_reservedWordEntry != null                                                                 &&
				     al_reservedWordEntry.get(0).en_InstrCategory == EnumInstrDataCategory.COBOL_OPERATOR         &&
				     al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolOperator() != EnumCobolOperator.SUB
				    )) {
					i--;
				  break;
				}
				sb.append(strWork.charAt(i)); // Porto in output
			}
			
		} // end-for 
		
		strOutput = sb.toString();
		
		
        ///////////////////////////////////////////////////////////////////////////////
		// (2) Operatore - a inizio o fine operando  
        ///////////////////////////////////////////////////////////////////////////////
		
		sb = new StringBuffer();
		scn = new Scanner(strOutput);
		token = nextToken(scn); 
        
		// Scan token e  trattamento operatore -
		while (!token.equals("")) {

			// Token literal alfanumerica o numerica.
			iEndLiteral = literalCobol.parseLiteral(token + " ", 0);
			if (literalCobol.isLiteralString() 
			||  literalCobol.isLiteralNum()) {
				sb.append(" " + token + " ");
				token = nextToken(scn);
				continue;  
			}

			// Il token inizia con -; divido
			if (token.startsWith("-")) {
				sb.append(" - ");
				sb.append(token.substring(1));
				token = nextToken(scn); 
				continue;
			}
			
			// Il token termina con -; divido
			if (token.endsWith("-")) {
				sb.append(token.substring(0, token.length() - 1));
				sb.append(" - ");
				token = nextToken(scn); 
				continue;
			}
			
			// Porto direttamente in output
			sb.append(" " + token);
			token = nextToken(scn); 
		}

		strOutput = sb.toString();


		////////////////////////////////////////////////////////////////////////////
		// (3) Divisione operandi con - operatore matematico come PREZZO-QTA
        ////////////////////////////////////////////////////////////////////////////
		
		sb = new StringBuffer();
		scn = new Scanner(strOutput);
		token = nextToken(scn); 
        
		// Scan token e  trattamento operatore -
		while (!token.equals("")) {

			// Parola riservata Cobol Function
            al_reservedWordEntry = this.map_ReservedWords.get(token);
            if (al_reservedWordEntry != null 
            &&  al_reservedWordEntry.get(0).en_WordReservedOwner.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_FUNCTION_INTRINSIC) {
            	sb.append(" " + token + " ");		// FUNCTION
				token = nextToken(scn);	
				sb.append(" " + token + " ");		// functionName
				token = nextToken(scn);
				continue;
			}

			
			// Token literal alfanumerica o numerica.
			// Potrebbero esserci - nella literal alfanumerica
			iEndLiteral = literalCobol.parseLiteral(token + " ", 0);
			if (literalCobol.isLiteralString() 
			||  literalCobol.isLiteralNum()) {
				sb.append(" " + token + " ");
				token = nextToken(scn);
				continue;  
			}
			
			// Token non contiene trattini o trattino singolo
			if (token.indexOf('-') == -1 || token.equals("-")) {
				sb.append(" " + token + " ");
				token = nextToken(scn);
				continue;
			}
			
			// Il token contiene dei trattini.
			// Può essere una parola riservata Cobol
			// Oppure un campo definito nel programma
			// Oppure una espressione fra due campi, da dividere
			
			// Campo definito nel programma
			if (this.programCobol != null && this.programCobol.dataItemPointers(token) != null) {
				sb.append(" " + token + " ");
				token = nextToken(scn);
				continue;
			}
  
			// Parola riservata Cobol
            al_reservedWordEntry = this.map_ReservedWords.get(token);
            if (al_reservedWordEntry != null) {
            	sb.append(" " + token + " ");
				token = nextToken(scn);
				continue;
			}
            
            // Può essere solo una espressione fra due campi NON interspaziata
			i = token.indexOf("-");
			isTokenDivided = false;
			while (i > 0) {
				strBeforeHiphen = token.substring(0, i);
				strAfterHiphen = token.substring(i + 1);
                // I due campi sono definiti ne programma
				if (this.programCobol != null && this.programCobol.dataItemPointers(strBeforeHiphen) != null
				&&  this.programCobol != null && this.programCobol.dataItemPointers(strAfterHiphen)  != null) {
					sb.append(" " + strBeforeHiphen + " - " + strAfterHiphen + " ");
					 isTokenDivided = true;
					 break;
				}
				i = token.indexOf("-", i + 1);
			}   
			 
			// Token composto correttamente da due campi con - in mezzo senza spazi
			if (isTokenDivided) {
				 token = nextToken(scn);
				 continue;
			}
			
			// Token con trattini non riconducibile a espressione algebrica: errore
			instruction.setSemanticError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0009", token, excp, new String[]{this.programName});
			sb = new StringBuffer();
			sb.insert(0, token);
			break;
		}
		
		strOutput = sb.toString().trim();
		return strOutput;
	}


	/* ----------------------------------------------------------
	 * Normalizzazione source copy per il trattamento come token.
	 * ----------------------------------------------------------
	 * 
	 * Replace di space con _ dentro le stringhe
	 * Replace di space con _ dentro le stringhe fra i delimiter ==
	 * 
	 * In caso di sorgentr maslformato, literal o delimiter non chiusi,
	 * viene impostato il falg di pasrsing error nell'istruzione.
	 * 
	 */
	private String normalizeInstructioCopy(Instruction instruction, String strInput) {
        
		String strWork = "";
		StringBuffer sb = null;
		ExceptionAmrita excp = null; 
		int iDelimiterStart =  0;
		int iDelimiterEnd =  0;
		int j  = 0;
		
		
		// Tratto eventuali literal
		strWork = replaceSpaceInLiteralWithUnderscore(instruction, strInput);

		// Literal non chiusa: exit
		if (instruction.isParsingError()) {
			return strInput;
		}
		
		sb = new StringBuffer(strWork);
		
		// Sostituzione space con _ (underscore) dentro stringhe fra delimiter == ... ==
		
		iDelimiterStart = sb.indexOf("==");			// Primo delimiter
		
		// Scan literal
		while (iDelimiterStart >= 0) {
			
			// Ricerca fine literal
			for (int i = iDelimiterStart + 2; i < strInput.length(); i++) {
				iDelimiterEnd = -1;
				// Fine literal trovata
				if (sb.substring(i, i + 2).equals("==")) {
					iDelimiterEnd = i;
					break;
				}
			} // end-for
			
			// Literal non chiusa: parsing identifier error
			if (iDelimiterEnd < 0) {
				// Definizione errata
				instruction.setParsingError(true);
				excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_COPY);
				instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", "", excp, new String[]{"Delimiter"});
				return "";
			} // end-if
			
			// Delimiter aperto e chiuso correttamente: replace space con undescore
			
			// Scan char inside string delimited
			for (j = iDelimiterStart + 2; j < iDelimiterEnd; j++) {
				if (sb.charAt(j) == ' ') {
					sb.setCharAt(j, '_');
				}
			} // end-for
			

			iDelimiterStart = sb.indexOf("==", j + 2);			// Next delimiter
			
		} // end-while
		
		
		return sb.toString();
	}

	/* ----------------------------------------------------------
	 * Normalizzazione source con inserimento spazi
	 * ----------------------------------------------------------
	 * 
	 */
	private String getSourceNormalized(String sourceInput) {
		String sourceNormalized = "";
		sourceNormalized = sourceInput;
		sourceNormalized = sourceNormalized.replace("(", " ( ");
		sourceNormalized = sourceNormalized.replace(")", " ) ");
		sourceNormalized = sourceNormalized.replace(";", " ");
		return sourceNormalized;
	}
        


	/**
	 * 
	 *  Eliminazione carattere finale se presente
	 * 
	 */
	private String deleteTrailingCharIfAny(String token, String charToDelete) {
		String tokenOut = "";
		
		// Non termina con crt fornito : Restituisco stringa originale
		if (!token.endsWith(charToDelete)) {
			return token;
		}
		
		// Eliminazione crt finale
		tokenOut = token.substring(0, token.length() - 1);
		return tokenOut;
	}

	/**
	 * 
	 *  Eliminazione carattere iniziale se presente
	 * 
	 */
	private String deleteLeadingCharIfAny(String token, String charToDelete) {
		String tokenOut = "";
		
		// Non inizia con char fornito : Restituisco stringa originale
		if (!token.startsWith(charToDelete)) {
			return token;
		}
		
		// Eliminazione crt iniziale
		tokenOut = token.substring(1);
		return tokenOut;
	}



    

    /* 
     * Ricerca le literal nella stringa e rimpiazza gli spazi con _
     * Se literal non chiusa imposta errore di parsing nell'istruzione.
     * 
     */
	private String replaceSpaceInLiteralWithUnderscore(Instruction instruction, String strInput) {

		StringBuffer sb = null;
		ExceptionAmrita excp = null; 
		char singleApice = 39;					// Apice singol '
		char doubleApice = 34;					// Doppio apice ""
		char curApice = 34;						// Apice corrente utilizzato dalla literal (singolo o doppio)
        int i = 0;
        boolean isLiteral = false;
        boolean isLiteralWellClosed = true;
        
        
        sb = new StringBuffer(strInput);
        
        // Scan caratteri stringa
        for (i = 0; i < strInput.length(); i++) {
        	
            // Cerca primo apice
            for (; i < strInput.length(); i++) {
             	// Non apice singolo e non apice doppio: skip
            	isLiteral = false;
       			if (strInput.charAt(i) == singleApice) {
       				isLiteral = true;
    			}
	   			if (strInput.charAt(i) == doubleApice) {
	   				isLiteral = true;
    			}
	   			// Inizio literal: trattala
	   			if (isLiteral) {
					break;
				}
       		}

            // Fine stringa
            if (i >= strInput.length()) {
				break;
			}

 			curApice = strInput.charAt(i);
 			isLiteralWellClosed = false;
 			
            // replace space in _
            for (i = i + 1; i < strInput.length(); i++) {
            	// Replace space con underscore
    			if (strInput.charAt(i) == ' ') {
    				sb.setCharAt(i, '_');
					continue;
				}
    			
    			// Bypass doppio apice
    			if (curApice == singleApice 
    			&& strInput.charAt(i) == curApice
    			&& i < (strInput.length() -1)
    			&& strInput.charAt(i + 1) == curApice) {
					i = i + 1;
					continue;
				}
    			
    			// Fine literal
       			if (strInput.charAt(i) == curApice) {
       				isLiteralWellClosed = true;
 					break;
				}
       			
       		} // end-for
            
		} // end-for
		
        
        // Literal Non chiusa
        if (!isLiteralWellClosed) {
			instruction.setParsingError(true);
			excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_IDENTIFIER);
			instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", "", excp, new String[]{"Literal"});
			return "";
		}
        
        return sb.toString();
        
	}



	/*
	 * -----------------------------------------------------------------
	 * Restituisce un oggetto ProgramCobolEntry<? extends Instruction> 
	 * istanziato con la corretta istruzione fornita in input.
	 * -----------------------------------------------------------------
	 * 
	 * 
	 * Vengono inoltre valorizzate tutte le variabili correnti disponibili,
	 * come eventuale section sotto la quale è definita l'istruzione,
	 * se definita dentro un modulo copy etc.
	 * Viene anche valorizzato il tipo istruzione nell'oggetto instruction.
	 * 
	 */
	private ProgramCobolEntry<? extends Instruction> createProgramEntry(Object objectInstruction, InnerContextAnalysis ictx) throws ExceptionAmrita {
		
		ProgramCobolEntry<? extends Instruction> programEntry = null;
		InstructionCobol instructionCobol = null;		
		InstructionCics instructionPrecompilerCics = null;		
		InstructionSql instructionPrecompilerSql = null;		
		InstructionDL1 instructionPrecompilerDL1 = null;		
		
		// Impostazione tipo istruzione nell'istruzione in input

		// InstructionPrecompiler Cics
		if (objectInstruction instanceof InstructionCics) {
			instructionPrecompilerCics = (InstructionCics) objectInstruction;
			instructionPrecompilerCics.setTypeInstr(ictx.activeTypeInstr);
		// InstructionPrecompiler Sql
		} else if (objectInstruction instanceof InstructionSql) {
			instructionPrecompilerSql = (InstructionSql) objectInstruction;
			instructionPrecompilerSql.setTypeInstr(ictx.activeTypeInstr);
			// InstructionPrecompiler DL1
		} else if (objectInstruction instanceof InstructionDL1) {
			instructionPrecompilerDL1 = (InstructionDL1) objectInstruction;
			instructionPrecompilerDL1.setTypeInstr(ictx.activeTypeInstr);
		// not InstructionPrecompiler
		} else {
			instructionCobol = (InstructionCobol) objectInstruction;
			instructionCobol.setTypeInstr(ictx.activeTypeInstr);
		}
		
		// InstructionCobolIdentification
		if (objectInstruction instanceof InstructionCobolIdentification) {
			programEntry = new ProgramCobolEntry<InstructionCobolIdentification>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobolIdentification)objectInstruction);
		// InstructionCobolEnvironment
		} else if (objectInstruction instanceof InstructionCobolEnvironment) {
			programEntry = new ProgramCobolEntry<InstructionCobolEnvironment>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobolEnvironment)objectInstruction);
		// InstructionCobolDataItem
		} else if (objectInstruction instanceof InstructionCobolDataItem) {
			programEntry = new ProgramCobolEntry<InstructionCobolDataItem>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobolDataItem)objectInstruction);
		// InstructionCobolDataStruct			
		} else if (objectInstruction instanceof InstructionCobolDataStruct) {
			programEntry = new ProgramCobolEntry<InstructionCobolDataStruct>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobolDataStruct)objectInstruction);
		// InstructionCobolProcedure
		} else if (objectInstruction instanceof InstructionCobolProcedure) {
			programEntry = new ProgramCobolEntry<InstructionCobolProcedure>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobolProcedure)objectInstruction);
		// InstructionPrecompiler Cics
		} else if (objectInstruction instanceof InstructionCics) {
			programEntry = new ProgramCobolEntry<InstructionCics>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCics)objectInstruction);
			// InstructionPrecompiler Sql
		} else if (objectInstruction instanceof InstructionSql) {
			programEntry = new ProgramCobolEntry<InstructionSql>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionSql)objectInstruction);
		// InstructionPrecompiler DL1
		} else if (objectInstruction instanceof InstructionDL1) {
			programEntry = new ProgramCobolEntry<InstructionDL1>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionDL1)objectInstruction);
			
		// InstructionCobol	generic	(incluso statement copy)
		} else {
			programEntry = new ProgramCobolEntry<InstructionCobol>();
			programEntry.setProgramDivision(this.activeDivisionArea);
			programEntry.setProgramSection(this.activeSectionArea);
			programEntry.setInstruction((InstructionCobol)objectInstruction);
		}
			
		// Istruzione definita dentro una procedura interna (Section)
		if (ictx.curProcInternalPointer > 0) {
			programEntry.setUnderProcInternal(true);
			programEntry.setUnderProcInternalPointer(ictx.curProcInternalPointer);		
		}
        
		// Tipo, categoria istruzione e info su copy nesting
		programEntry.setTypeInstr(ictx.activeTypeInstr);
		try {
			programEntry.setEntryType(ictx.activeTypeInstr.getCobolInstrCategory());
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();   // ????????????
		}
		programEntry.setLevelNestingCopy(ictx.copyNestinglevel);
		programEntry.setUnderCopyName(ictx.copyName);
		if (!ictx.copyName.equals("")) {
			programEntry.setUnderCopy(true);
			programEntry.setUnderCopyName(ictx.copyName);
		}
		return programEntry;

	}



	/*
     * 
     * Inserimento nell'istruzione utilizzi simboli di qualificazione, 
     * sicuramente in input come indici, reference modification etc.
     * Inserimento nell'istruzione simboli definiti dall'istruzione
     * 
     */
	private void addInstructionSymbolsQualifier(Instruction instruction
											  , DataItemCobolIdentifier identifier
					                          , DataItemQualifier qualifier
					                          ) {
		
		ExpressionCobol ar_index[] = null;
		ExpressionCobol posRefMod = null;
		ExpressionCobol lengthRefMod = null;
		

		// Caricamento group name
		if (qualifier.isUnderGroupDeclared()) {
			instruction.addSymbolInput(qualifier.getGroupNameField(), EnumSymbolType.COBOL_SYMBOL_DATA_ITEM);
		}
		
		// Indici e reference modification sicuramente in input
		
		// Caricamento indici in input
		ar_index = qualifier.getIndexes();
		if (ar_index != null) {
			// Scan espressioni indici
			for (ExpressionCobol expressionIndex : ar_index) {
				addInstructionSymbolsExpressionInput(instruction, expressionIndex);
			} // end-for
		} // end-if
		
		
		// Caricamento reference modification 
		// possono essere nomi di campo, special register o literal numeriche
		if (qualifier.isThereRefModification()) {
			
			// Expression pos
			posRefMod = qualifier.getPos();
			addInstructionSymbolsExpressionInput(instruction, posRefMod);
            
			// Expression length
			lengthRefMod = qualifier.getLength();
			addInstructionSymbolsExpressionInput(instruction, lengthRefMod);
			
		} // end-if


	}
 


	/*
     * 
     * Inserimento nell'istruzione utilizzi simboli di espressione algebrica e logica
     * 
     */
	private void addInstructionSymbolsExpressionInput(Instruction instruction
											   		, ExpressionCobol expression
													) {
		
		
        DataItemCobolIdentifier identifier = null;
        
		// Scan elementi espressione posizione
		for (ExpressionCobolElement expressionElement : expression.getElements()) {
			
			identifier = expressionElement.getDataItemIdentifier();
			
			// operatore: skip
			if (!expressionElement.isOperand()) {
				continue;
			}

			// Reference identificatore cobol completo
			instruction.addOperandInput(identifier.getNameIdentifier(), identifier);
			
			// Operando  (data item, figurative, literal, special register
		    instruction.addSymbolInput(expressionElement.getValue(), expressionElement.getSymbolType());
			
		    
			// Simbolo definiti dentro l'istruzione (literal o costante figuratival)
			if (identifier.getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_NUM
			||  identifier.getIdentifierType() == EnumCobolReservedWords.OPERAND_LITERAL_ALPHA
			   ) {
				instruction.addSymbolDefinedInside(identifier.getNameIdentifier(), identifier.getIdentifierType().getCobolSymbolType());
			}
		    
		} // end-for

	}
 



	/*
	 * 
	 * Aggiorna le informazioni di lunghezza, interi e decimali
	 * 
	 * Casi gestiti:
	 * 
	 * 1) XXX...XX oppure XAAX...  oppure A(nn))(nn)X(nn)Z(nn)  
	 * 2) X(nn) 
	 * 3) ZZ.ZZ. oppure ZZ,ZZ...., oppure -ZZ99 oppure CRZZZ
	 * 3) Z(nn).Z(nn). oppure ZZ,ZZ...., oppure -ZZ99 oppure CRZZZ
	 * 4) S999... oppure 999... oppure 9(nn)
	 * 5) 99V9999 oppure V9999 oppure V9(7)
	 * 6) CRZZ.ZZZ
	 * 
	 * I valori vengono caricati direttamente nell'istanza dell'oggetto InstructionCobolDataItem corrente
	 * 
	 * 
	 */
	private void extractAndSetPictureInfo(InstructionCobolDataItem instruction, String token) throws ExceptionAmrita {
		
		ExceptionAmrita excp = null; 
		String lngInParmStr = "";
		String crt = "";
		String crtPrec = "";
		boolean isVirtualPointOnLeft = false;
		int i = 0;
		int iParEnd = 0;
		int numInt = 0;
		int numDec = 0;
		int sizeBytes = 0;
		int lngInParmNum = 0;
		
		// Segno
		if (token.substring(0, 1).equals("S")) {
			instruction.setSignClause(true);
			i = 1;
		}

		// Default campo di testo
		instruction.setGenericType(EnumDataItemGeneric.DATA_ITEM_TEXT);
		instruction.setItemType(EnumDataItemType.COBOL_DISPLAY);
		
		// scan caratteri componenti la picture
		for (int j = i; j < token.length(); j++) {
			
			crt = token.substring(j, j+1);
			
			// Caratteri diversi da concorrono alla lunghezza in bytes
			if (!crt.equals("V") 
			&&  !crt.equals("(") 
			&&  !crt.equals(")") ) {
				sizeBytes++;
			}
			
			// Incontrato punto virtuale
			if (crt.equals("V")) {
				isVirtualPointOnLeft = true;
				crtPrec = crt;
				continue;
			}
			
			// Cifra numerica intera
			if (crt.equals("9") && !isVirtualPointOnLeft) {
				instruction.setGenericType(EnumDataItemGeneric.DATA_ITEM_NUMERIC);
				instruction.setItemType(EnumDataItemType.COBOL_ZONED);
				numInt++;
				crtPrec = crt;
				continue;
			}

			// Cifra numerica decimale
			if (crt.equals("9") && isVirtualPointOnLeft) {
				instruction.setGenericType(EnumDataItemGeneric.DATA_ITEM_NUMERIC);
				instruction.setItemType(EnumDataItemType.COBOL_ZONED);
				numDec++;
				crtPrec = crt;
				continue;
			}
            
			// Parentesi aperta
			if (crt.equals("(")) {
				iParEnd = token.indexOf(')', j + 1);
				if (iParEnd < 0) {
					// Definizione incompleta
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Picture"});
					return;
				}
				lngInParmStr = token.substring(j + 1, iParEnd);
				if (!StringService._isNumeric(lngInParmStr)) {
					// Definizione errata
					instruction.setParsingError(true);
					excp = new ExceptionAmrita(EnumAmritaExceptionError.ERROR_PARSING_COBOL_DATA_ITEM);
					instruction.setInfoError(EnumMessageType.ERROR_INPUT, "ET0007", token, excp, new String[]{"Picture"});
					return;
				}
				lngInParmNum = Integer.parseInt(lngInParmStr);
				
				// Caso X(nn) A(nn) Z(nn)
				if (!crtPrec.equals("9")) {
					instruction.setGenericType(EnumDataItemGeneric.DATA_ITEM_TEXT);
					instruction.setItemType(EnumDataItemType.COBOL_DISPLAY);
					sizeBytes = sizeBytes + lngInParmNum - 1;
					j = iParEnd;
					crtPrec = crt;
					continue;
				}
				
				// Caso 9(nn) e 9(5)V99 e 9(3)V9(2)
				if (crtPrec.equals("9")) {
					instruction.setGenericType(EnumDataItemGeneric.DATA_ITEM_NUMERIC);
					instruction.setItemType(EnumDataItemType.COBOL_ZONED);
					if (isVirtualPointOnLeft) {
						numDec = numDec + lngInParmNum - 1;
					} else {
						numInt = numInt + lngInParmNum - 1;
					}
					j = iParEnd;
					crtPrec = crt;
					continue;
				}
			}
			
			crtPrec = crt;
			
		}
		
		instruction.setNumInt(numInt);
		instruction.setNumDec(numDec);
		instruction.setSizeBytes(sizeBytes);
		return;
	}



	/*
     * 
     * 
     *  Restituisce il token successivo dopo aver verificato che esiste.
     *  Se non esiste restituisce ""
     *  Viene gestito un Token di Replacing By dello statement Copy 
     *  ==x==  oppure == x ==, come ==05== == 05 == ==(05)==
     *  
     * 
     */
	private String nextToken(Scanner scn) {
		
		String newToken = "";
		
		// Non ci sono altri token: return stringa vuota
		if (scn.hasNext()) {
			newToken = scn.next();
		} 

		return newToken;
	}

	

	
	/*
	 * 
	 * Inserimento in map parole riservate Cobol, con collegamento alla EnumCobolResevedWords
	 * principale che identifica l'istruzione o direttiva o parola chiave figurativa etc.
	 * 
	 */
	private void putMapReservedWords(EnumCobolReservedWords en_reservedWord) {

		ArrayList<String> al_wordKeyDefinition = null;					// Parole chiave valide come inizio di istruzione
		ArrayList<String> al_wordKeySequence = null;					// Sequenza di parole chiave valide identificanti un0istruzione  
		
		
		al_wordKeyDefinition = new ArrayList<String> ();
		al_wordKeySequence = new ArrayList<String> ();
				
		// Caricamento valori singole parole, che possono essere multiple e opzionali (se precedute da "|")
		
		// Key word Label e Section NON possono essere riconosciute da una prima parola chiave
		if (en_reservedWord.getValueText1().equals("")) {
			return;		 
		}
		al_wordKeyDefinition.add(en_reservedWord.getValueText1());		// Per esmpio IF 
		if (!en_reservedWord.getValueText2().equals("")) {
			al_wordKeyDefinition.add(en_reservedWord.getValueText2());		// Per esmpio DIVISION di ID DIVISION
		}
		if (!en_reservedWord.getValueText3().equals("")) {
			al_wordKeyDefinition.add(en_reservedWord.getValueText3());		// Per esmpio SIZE di NOT ON SIZE ERROR
		}
		if (!en_reservedWord.getValueText4().equals("")) {
			al_wordKeyDefinition.add(en_reservedWord.getValueText4());		// Per esmpio ERROR di NOT ON SIZE ERROR
		}
		
		// Estrazione ricorsiva sequenze corrette di parole chiave
		
	    extractKeyRecursive(en_reservedWord, al_wordKeyDefinition, 0, al_wordKeySequence);		// -> map_ReservedWords
		
	}

    /*
     * Analisi ricorsiva singola parola chiave e inserimento in map
     * di tutte le possibili sequenze di chiave corrette per l'istruzione
     * 
     */
	@SuppressWarnings("unchecked")
	private void extractKeyRecursive(
									  EnumCobolReservedWords en_reservedWord
									, ArrayList<String> al_wordKey
									, int iStart
									, ArrayList<String> al_wordKeySequence
									) {
		
		InnerInstructionWordsEntry reservedSubWordEntry = null;
		ArrayList<InnerInstructionWordsEntry> al_reservedSubWordEntry = null;
		ArrayList<String> al_wordKeySequenceRecursive = null;
		
		String ar_valueKeyOptional[] = null;							// Valori chiave opzionali di ogni parola chiave
		String wordKey = ""; 
		String wordKeyFirst = ""; 
	
		// Scan stringhe descrittori parole chiave
		
		for (int i = iStart; i < al_wordKey.size(); i++) {
			
			wordKey = al_wordKey.get(i);
			
			// Non definita: skip
			if (wordKey.equals("")) {
				break;
			}
			
			// Ci sono valori opzionali nella posizione: attivazione ricorsiva
			if (wordKey.indexOf("|") > 0) {
				wordKey = wordKey.replace('|', ':');
				ar_valueKeyOptional = wordKey.split(":");
				// Scan valori opzionali
				for (String valueKeyOptional : ar_valueKeyOptional) {
					al_wordKeySequenceRecursive = (ArrayList<String>) al_wordKeySequence.clone();
					// Space indica opzionale: non deve essere inserito
					if (!valueKeyOptional.trim().equals("")) {
						al_wordKeySequenceRecursive.add(valueKeyOptional);
					}
					extractKeyRecursive(en_reservedWord, al_wordKey, i+1, (ArrayList<String>) al_wordKeySequenceRecursive);
				}
				return;
			}
		
			// C'è un valore chiave singolo nella posizione: accodo in ArrayList di output
			al_wordKeySequence.add(wordKey);
		}
		
		// Inserimento Sequenza valori chiave validi in map
		// La chiave è il primo valore della sequenza di chiavi
		
		wordKeyFirst = al_wordKeySequence.get(0);
		al_reservedSubWordEntry = map_ReservedWords.get(wordKeyFirst);
		if (al_reservedSubWordEntry == null) {
			al_reservedSubWordEntry = new ArrayList<InnerInstructionWordsEntry> ();
			map_ReservedWords.put(wordKeyFirst, al_reservedSubWordEntry);
		}
		
		// Creazione entry per nuova sequenza di valori chiave
		reservedSubWordEntry =  new InnerInstructionWordsEntry();
		reservedSubWordEntry.en_WordReservedOwner = en_reservedWord;
		reservedSubWordEntry.en_InstrCategory = en_reservedWord.getCobolInstrCategory();
		reservedSubWordEntry.wordKeyFirst = wordKeyFirst;
		reservedSubWordEntry.al_wordKey = al_wordKeySequence;
		
		// Accodamento a ArrayList associata al primo valore chiave
		al_reservedSubWordEntry.add(reservedSubWordEntry);
	}



  

	/*
	 * 
	 * Individua il tipo di istruzione, come sequenza di parole riservate, nell'elenco di token disponibili
	 * 
	 * Viene individuata anche un'istruzione di definizione dati.
	 * Se non viene individuata un'istruzione valida restituisce null.
	 * 
	 * Sono disponibili le variabili this.rowAll, this.rowStartSource, this.posStartInstr
	 * Viene effettuato o meno il controllo
	 * 
	 */
	private EnumCobolReservedWords getInstructionType(
													  InnerContextAnalysis ictx						// Informazioni di contesto
													, ArrayList<InnerTokenInstr> al_tokenSpreaded	// Token istruzione
													, int numTokenStart								// primo token dopo key word istruzione
	 												 ) {
		 

		EnumCobolReservedWords detectedTypeInstr = null;					//
		InnerTokenInstr innerLastTokenInstr = null;				    		// Descrittore ultimo token identificativo parola chiave istruzione
		ArrayList<InnerInstructionWordsEntry> al_innerReservedWord = null;	//
 		String curWordKey = "";												//
        String wordWithNoTrailingPoint = "";								//
        int rowStartNum = 0;  												// Numero riga dalla quale iniziare la ricerca
		int posStart = 0;													// Posizione un riga dalla quale iniziare la ricerca

		
 		// Sono disponibili le singole parole separate da spazi entro col 1-72 della riga corrente e della successiva 
 		// e il numero di parola dal quale iniziare la ricerca
 
		
		// Verifica se parola riservata di inizio istruzione
   
 		ictx.token = al_tokenSpreaded.get(numTokenStart).token;			// Prima parola chiave identificativa istruzione
 		ictx.curToken = ictx.token;

		// Cerco istruzione che inizia con il token come parola riservata, senza considerare eventuale punto finale.
 		ictx.token = deleteTrailingCharIfAny(ictx.token, ".");
		al_innerReservedWord = this.map_ReservedWords.get(ictx.token);
		
		// Parola chiave non censita: puo essere una label, una Section oppure una definizione dati.
		if (al_innerReservedWord == null) {
			
			// Definizione dati (inizia sicuramente con un numero di livello)
			if (this.activeDivisionArea == EnumCobolReservedWords.DATA_DIVISION  ) {
				if (StringService._isNumeric(ictx.token)) {
					detectedTypeInstr = EnumCobolReservedWords.DATA_DIV_DATA_ITEM;
					ictx.activeInstrKeyWordsSize = 1;
					return detectedTypeInstr;
				}
			}
			
		    // Label e section sono solo istruzioni di Procedure division
	        if (this.activeDivisionArea == EnumCobolReservedWords.PROC_DIVISION) {
	         	
	    		// Label: inizio a colonna 8, non è una una parola riservata ed è seguita da un punto.
				if (isLabelCobol(al_tokenSpreaded, numTokenStart)) {
					detectedTypeInstr = EnumCobolReservedWords.PROC_LABEL;
					ictx.activeInstrKeyWordsSize = 1;
					return detectedTypeInstr;
				}
				
				// Gestione caso in cui l'ultimo token bufferizzato è proprio quello che sto trattando
				// Per verificare se è una section servono ulteriori token
				if (numTokenStart == al_tokenSpreaded.size() - 1) {
					innerLastTokenInstr = al_tokenSpreaded.get(al_tokenSpreaded.size() - 1);
					rowStartNum = innerLastTokenInstr.numRowSource;
					posStart = innerLastTokenInstr.posInRow + innerLastTokenInstr.token.length();;	 
					getTokensSpreaded(ictx, al_tokenSpreaded, rowStartNum, posStart, COBOL_PREFETCH_PARSING_ROWS);
				} // end-if
				
				// Section: inizio a colonna 8 e termine con SECTION anche in riga successiva
				if (isSectionCobol(al_tokenSpreaded, numTokenStart)) {
					detectedTypeInstr = EnumCobolReservedWords.PROC_SECTION;
					ictx.activeInstrKeyWordsSize = 1;
					return detectedTypeInstr;
				}
			}

	        // Istruzione non identificabile a partire dalla parola richiesta
			return EnumCobolReservedWords.NOT_ASSIGNED;
		}

		// Istruzione identificabile da una più parole chiave e/o più sequenze di parole che iniziano con stessa parola chiave
		
		
 		// Scan possibili insiemi di parole chiave.
		// ogni insieme può essere una variante della stessa istruzione con valori opzionali o meno
		// oppure una possibile istruzione diversa
		for (InnerInstructionWordsEntry innerInstructionWordsEntry : al_innerReservedWord) {
			
			// Non è una parola chiave di inizio istruzione valida: cerca prossima combinazione
			if (!isValidStartInstruction(ictx, innerInstructionWordsEntry.en_WordReservedOwner)) {
				continue;
			}
			
			// Scan parole chiave dell' insieme corrente 
			for (int i = 0; i < innerInstructionWordsEntry.al_wordKey.size(); i++) {
				
				curWordKey = innerInstructionWordsEntry.al_wordKey.get(i);
				
				// Token non sufficienti a individuare l'istruzione: il chiamante accoderà altri token
				if (numTokenStart + i >= al_tokenSpreaded.size()) {
					return EnumCobolReservedWords.NOT_ASSIGNED;
				}
				
				// Match parola chiave: verifico la successiva
				wordWithNoTrailingPoint = deleteTrailingCharIfAny(al_tokenSpreaded.get(numTokenStart + i).token, ".");

				if (curWordKey.equals(wordWithNoTrailingPoint)) {
					
					// Ultima parola chiave: istruzione individuata
					if (i == innerInstructionWordsEntry.al_wordKey.size() - 1) {
						// Store numero parole chiave che hanno identificato l'istruzione
						detectedTypeInstr = innerInstructionWordsEntry.en_WordReservedOwner;
						// E' un registro speciale: non è una istruzione
						if (detectedTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_SPECIAL_REGISTER) {
							return EnumCobolReservedWords.NOT_ASSIGNED;
						}
						// E' un operatore Cobol: non è una istruzione
						if (detectedTypeInstr.getCobolSymbolType() == EnumSymbolType.COBOL_SYMBOL_OPERATOR) {
							return EnumCobolReservedWords.NOT_ASSIGNED;
						}
						ictx.activeInstrKeyWordsSize = innerInstructionWordsEntry.al_wordKey.size();
						return detectedTypeInstr;
						
					} // end-if
					
					// Next parola chiave
					continue;
					
				} // end-if
				
				break;
				
			} // end-for
			
			// Tutte le parole chiave correnti sono state esaminate
			// Analizzo successivo insieme di parole chiave
			
		} // end-for
		
		
		// Non è stata individuata nessuna istruzione o parola riservata utilizzando i token disponibili
		
		// Istruzione non identificabile a partire dalla parola richiesta
		return EnumCobolReservedWords.NOT_ASSIGNED;
	}




	/*
	 * ------------------------------------------------------
	 * Accoda token istruzione a partire da riga e posizione.
	 * ------------------------------------------------------
	 * 
	 * 
     * A partire dalla riga corrente, posizione corrente, restituisce una 
     * ArrayList con tutti i token estratti, indicando riga e posizione nella riga.
     * singola stringa con le successive numRowsDeep righe source accodate.
     * Delle successive righe viene considerata la sola porzione attiva
     * da col 8 a 72.
     * Viene così composta una unica stringa con l'istruzione da valutare
     * 
     */

	private ArrayList<InnerTokenInstr> getTokensSpreaded(
														  InnerContextAnalysis ictx						// Informazioni di contesto
														, ArrayList<InnerTokenInstr> al_tokenSpreaded	// Tokens estratti con info di origine
														, int numRowStart 								// Numero riga di inizio
														, int posStart									// Posizione di inizio in riga di inizio
														, int numRowsDeep								// Numero righe utili da considerare dopo quella di inizio
														 ) {
		
		InnerTokenInstr innerTokenInstr = null;					// Singolo token con parola chiave, istruzione, posizione, ...
		InnerTokenInstr innerTokenInstrCloned = null;			// Singolo token con parola chiave, istruzione, posizione, ...
		StringService ss = null;								// Gestore stringhe
		String rowStart = "";									// Numero riga di inizio
		String row = "";										// Singola riga precedebte
		String strToSplit = "";									// Porzione utile riga sorgente col 8-72
		String strDoubleApice = "";                             //
		char doubleApice = 34;									// ""
		int cntRows = 0;
         
		
		strDoubleApice = Character.toString(doubleApice);
		
        rowStart = ictx.ar_RowsSource[numRowStart];
		
 		// Porzione riga di partenza, da posizione di inizio, da trattare
		if (rowStart.length() > posStart) {
			if (rowStart.length() <= 72) {
				strToSplit = rowStart.substring(posStart).toUpperCase();
			} else {
				strToSplit = rowStart.substring(posStart, 72).toUpperCase();
			}
			// Estrazione di tutte le parole presenti
			ss = new StringService(strToSplit);  
			ss._words();			// Estrazione parole
			ss._wordsPos();			// Calcolo posizione in strToSplit
			
			// Scan token righe splittate sotto esame
			for (int j = 1; j <= ss._wordsCount(); j++) {
				innerTokenInstr = new InnerTokenInstr();
				innerTokenInstr.token = ss._word(j);
				innerTokenInstr.numRowSource = numRowStart;
				innerTokenInstr.posInRow = ss._wordPos(j) + posStart;			// 0-based
				// Caso Display seguito da literal senza spazi
				if (innerTokenInstr.token.startsWith("DISPLAY'") 
				||  innerTokenInstr.token.startsWith("DISPLAY" + strDoubleApice)) {
					innerTokenInstrCloned = (InnerTokenInstr) innerTokenInstr.clone();
					innerTokenInstr.token = innerTokenInstr.token.substring(0, 7);
					al_tokenSpreaded.add(innerTokenInstr);
					innerTokenInstrCloned.token = innerTokenInstrCloned.token.substring(7);
					innerTokenInstrCloned.posInRow = innerTokenInstrCloned.posInRow + 7;
					al_tokenSpreaded.add(innerTokenInstrCloned);
					continue;
				}
				// Caso normale 
				al_tokenSpreaded.add(innerTokenInstr);
			} // end-for
		} // end-if
	 
		
		// Scan righe sorgente a partire da quella successiva a quella in input
		for (int i = numRowStart + 1; i < ictx.ar_RowsSource.length; i++) {
			
			row = ictx.ar_RowsSource[i];
			
			// Riga vuota 
			if (isRowCobolEmpty(row)) {
				continue;
			}
			
			// Riga Commento 
			if (isCobolRowComm(row)) {
				continue;
			}
            
			// SQL: gestione commenti
			if (al_tokenSpreaded.get(0).token.equals("EXEC")) {
				row = sqlRemoveTrailingComment(row);
				// Riga commento SQL:scarto
				if (row.equals("")) {
					ictx.ar_RowsSource[i] = "";
					continue;
				}
				// Commenti su riga eliminati
				ictx.ar_RowsSource[i] = row;
			}

			// Riga > 72 crt
			if (row.length() > 72 ) {
				strToSplit = row.substring(7, 72);
				strToSplit = StringService._rtrim(strToSplit);
			}
			// Riga <= 72 crt
			if (row.length() <= 72 ) {
				strToSplit = row.substring(7);
				strToSplit = StringService._rtrim(strToSplit);
			}

			// Estrazione di tutte le parole presenti
			ss = new StringService(strToSplit.toUpperCase());  
			ss._words();			// Estrazione parole
			ss._wordsPos();			// Calcolo posizione in strToSplit
			
			// Scan token righe splittate sotto esame
			for (int j = 1; j <= ss._wordsCount(); j++) {
				innerTokenInstr = new InnerTokenInstr();
				innerTokenInstr.token = ss._word(j);
				innerTokenInstr.numRowSource = i;
				innerTokenInstr.posInRow = ss._wordPos(j) + 7;
				// Caso Display seguito da literal senza spazi
				if (innerTokenInstr.token.startsWith("DISPLAY'") 
				||  innerTokenInstr.token.startsWith("DISPLAY" + strDoubleApice)) {
					innerTokenInstrCloned = (InnerTokenInstr) innerTokenInstr.clone();
					innerTokenInstr.token = innerTokenInstr.token.substring(0, 7);
					al_tokenSpreaded.add(innerTokenInstr);
					innerTokenInstrCloned.token = innerTokenInstrCloned.token.substring(7);
					innerTokenInstrCloned.posInRow = innerTokenInstrCloned.posInRow + 7;
					al_tokenSpreaded.add(innerTokenInstrCloned);
					continue;
				}
				// Caso normale 
				al_tokenSpreaded.add(innerTokenInstr);
			}

			cntRows++;

			// Accodate le righe successive richieste
			if (cntRows > numRowsDeep) {
				break;
			}
		}

		return al_tokenSpreaded;
	}
    
	/*
	 * Rimozione commenti a istruzione SQL --
	 */
    private String sqlRemoveTrailingComment(String row) {
    	int i = 0;
		i = row.indexOf(" --");
		if (i < 0) {
		   return row;	
		}
		
		// Riga di solo commento: da scartare
		if (row.length() > 7 && row.substring(7, i).trim().equals("")) {
			return "";
		}
		
		// Riga con commento: elimino il commento dall'istruzione
		
		return row.substring(0, i);
	}


	/* ----------------------------------------------------------------
     * Restituisce true se la stringa termina con una literal completa
     * ----------------------------------------------------------------
     * 
     * Es. DISPLAY CAMPO "GGGG"
     *   -                CAMPO2
     * Es. DISPLAY CAMPO 'GG"GG'
     *   -                CAMPO2
     */
	private boolean isRowEndedeByLiteral(String rowPrec, String strApiceDelimiter) {
		
		String rowN = "";
		@SuppressWarnings("unused")
		char singleApice = 39;					// Apice singolo '
		@SuppressWarnings("unused")
		char doubleApice = 34;					// Doppio apice ""
		String lastChr = "";
		
		// Controllo di sicurezza
		if (rowPrec.trim().equals("")) {
			return false;
		}
		
		rowN = rowPrec;
		if (rowPrec.length() > 72) {
			rowN = rowPrec.substring(0, 72).trim();
		}
		if (rowPrec.length() <= 72) {
			rowN = rowPrec.substring(0).trim();
		}
		if (rowN.length() == 0) {
			return false;
		}
		
		lastChr = rowN.substring(rowN.length() - 1);
		if (lastChr.equals(strApiceDelimiter)) {
			return true;
		} 
		return false;
	}

    /* ----------------------------------------------------------------
     * Restituisce true se la stringa termina con un campo
     * ----------------------------------------------------------------
     * 
     * Es. DISPLAY CAMPO "GGGG"CAMPO2
     *   -               "HHH"
     * Es. DISPLAY CAMPO1  
     *   -               "HHH"
     */
	private boolean isRowEndedeByItem(String rowPrec) {
		
		String rowN = "";
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
		char lastChr = ' ';
		char apiceDelimiter = ' ';
		int cntApiceSingolo = 0;
		int cntApiceDoppio = 0;
		int i = 0;
		int j = 0;
		
		// Controllo di sicurezza
		if (rowPrec.trim().equals("")) {
			return false;
		}
		
		rowN = rowPrec;
		if (rowPrec.length() > 72) {
			rowN = rowPrec.substring(0, 72).trim();
		}
		if (rowPrec.length() <= 72) {
			rowN = rowPrec.substring(0).trim();
		}
		
		lastChr = rowN.charAt(rowN.length() - 1);
		if (lastChr == singleApice || lastChr == doubleApice) {
			return false;
		} 
		
		// Ricerca backward un apice o uno spazio
		for (i = rowN.length() - 2; i > 0; i--) {
			
			// Carattere di un campo
			if (rowN.charAt(i) != singleApice 
			&&  rowN.charAt(i) != doubleApice) {
				continue;
			} 
			apiceDelimiter = rowN.charAt(i);
			
			// Apice: verifico se è stato aperto
			for (j = i; j > 0; j--) {
				
				// Doppio apice dello stesso tipo (merda MF): bypass
				if (j > 1 && rowN.charAt(j) == apiceDelimiter  && rowN.charAt(j - 1) == apiceDelimiter) {
					j--;
					continue;
				}
				
				if (rowN.charAt(j) == singleApice) {
					cntApiceSingolo++;
				} 
				if (rowN.charAt(j) == doubleApice) {
					cntApiceDoppio++;
				} 

			}
			break;
		}
		
		// Nessun apice singolo o doppio prima del cammpo presunto
		if (cntApiceDoppio == 0 && cntApiceSingolo == 0) {
			return false;
		}
		
		// Apici aperti e non chiusi
		if (cntApiceSingolo > 0) {
			if (cntApiceSingolo % 2 > 0) {
				return false;
			}
		}
		if (cntApiceDoppio > 0) {
			if (cntApiceDoppio % 2 > 0) {
				return false;
			}
		}
		
		return true;
	}

	/* ----------------------------------------------------------------
     * Restituisce true se la stringa termina con un literal aperta
     * Questa è la norma IBM
     * ----------------------------------------------------------------
     * 
     * Es. DISPLAY CAMPO "GGGG 
     *   -               "HHH"
     */
	private boolean isRowEndedByCrtOfLiteral(String rowPrec) {
		
		String rowN = "";
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
		char lastChr = ' ';
		char apiceDelimiter = ' ';
		int i = 0;
		int j = 0;
		
		rowN = rowPrec;
		if (rowPrec.length() > 72) {
			rowN = rowPrec.substring(0, 72).trim();
		}
		if (rowPrec.length() <= 72) {
			rowN = rowPrec.substring(0).trim();
		}
		
		lastChr = rowN.charAt(rowN.length() - 1);
		if (lastChr == singleApice 
		||  lastChr == doubleApice) {
			return false;
		} 
		
		// Ricerca backward un apice 
		for (i = rowN.length() - 2; i > 0; i--) {
			
			// Apice 
			if (rowN.charAt(i) != singleApice 
			||  rowN.charAt(i) != doubleApice) {
				continue;
			} 
			
			apiceDelimiter = rowN.charAt(i);
			
			// Verifica se è un apice di chiusura
			for (j = i - 1; j > 0; j--) {
				
				// Doppio apice dello stesso tipo (merda MF): bypass
				if (j > 1 && rowN.charAt(j) == apiceDelimiter  && rowN.charAt(j - 1) == apiceDelimiter) {
					j--;
					continue;
				}
				
				// Trovato apice di aperura
				if (rowN.charAt(j) == apiceDelimiter ) {
					return false;
				}
			}
		    return true;
		}
		return false;
	}


	/*
	 * Individua l'istruzione successiva e pertanto la fine dell'istruzione 
	 * corrente in termini di riga e posizione.
	 * 
	 * Viene fornita in input una ArrayList con le parole chiave che hanno identificato
	 * l'istruzione, per esempio "FD"
	 * 
	 * Viene cercata la fine dell'istruzione analizzando le parole chiave successive a
	 * quelle identificanti e verificando se identificano una nuova istruzione. 
	 * L'ultimo elemento iswntifica la riga e la posizione dell'ultimo token utile.
	 * 
	 * La fine dell'istruzione viene identificata, nell'ordine in due modi:
	 * 
	 * 1) Si cerca un token terminato con un punto (.)
	 *    Se il token NON è dentro una stringa, allora identifica la fine dell'istruzione
	 * 2) Si verifica se un token con i successivi identifica una istruzione.
	 *    Ciò avviene nel caso l'istruzione corrente NON sia chiusa da un punto.
	 *    Se il token NON è dentro una stringa allora identifica la fine dell'istruzione
	 *    
	 */
	private EnumCobolReservedWords getInstructionTypeNext(
														  InnerContextAnalysis ictx							// Informazioni di contesto
														, EnumCobolReservedWords instrType    				// Tipo istruzione corrente        
														, ArrayList<InnerTokenInstr> al_tokenSpreaded		// Tokens istruzione corrente
														, int iFirstTokenNoKey								// Primo token dopo keys identificative istruzione
														) {

		InnerTokenInstr innerLastTokenInstr = null;				    // Descrittore ultimo token identificativo parola chiave istruzione
		EnumCobolReservedWords nextTypeInstr = null;				// Codice successiva istruzione identificata
		String tokenCur = "";                                       // token corrente istruzione sotto esame
		String tokenPrec = "";                                      // token precedente istruzione sotto esame
		int posStart = 0;											// Posizione un riga dalla quale iniziare la ricerca
		int iTokenStart = 0;										// Numero token dal quale iniziare la ricerca
		int rowCur = 0;                                             // Riga corrente da cui cercare la fine istruzioni
		int iTokenCur = 0;                                          // Indice corrente token
		
		
		
		// La ricerca inizia dal primo token successivo all'ultimo token identificativo dell'istruzione
		iTokenStart = iFirstTokenNoKey;

        // Impostazione flag di istruzione di precompilatore in corso
		// Non devono essere verificati i token fino a end-exec
        if (ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_CICS
        ||  ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_SQL	
        ||  ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_DL1) {
			ictx.isInstrPrecompilerInProgress = true;
		}
 
        
		// Scan righe sorgente a partire da quella corrente, posizione successiva a inizio istruzione
		while (rowCur < ictx.ar_RowsSource.length) {
						
			// Scan token su righe splittate sotto esame 
			// a partire dal token successivo a quello identificativo dell'istruzione corrente
			for (iTokenCur = iTokenStart; iTokenCur < al_tokenSpreaded.size(); iTokenCur++) {
				      
				// Estraggo token corrente e precedente  
				tokenCur = al_tokenSpreaded.get(iTokenCur).token;
                tokenPrec = "";  
                if (iTokenCur > 0) {
                	tokenPrec = al_tokenSpreaded.get(iTokenCur - 1).token;
				}
				
                // Fine istruzione precompilatore: il prossimo token può iniziare una nuova istruzione
                if (ictx.isInstrPrecompilerInProgress
                && (tokenCur.equals("END-EXEC") || tokenCur.startsWith("END-EXEC."))) {
                	ictx.isInstrPrecompilerInProgress = false;
                	continue;
				}
                
                // Bypass token dentro Exec Cics/Sql/Dl1
                if (ictx.isInstrPrecompilerInProgress) {
					continue;
				}
                
                // Impostazione flag di inizio/fine token sotto literal
                // Token da non considerare: , (separator), under literal
                if (isTokenToBypass(ictx, tokenCur)) {
					continue;  
				}
                  
				//  Individuazione possibile nuova istruzione a partire dal token corrente iTokenCur
				ictx.activeInstrKeyWordsSize = ictx.activeInstrKeyWordsSize;
				nextTypeInstr = getInstructionType(ictx, al_tokenSpreaded, iTokenCur); 

				// (1) L'istruzione di cui trovare la fine è identificato da una sola key 
				//     Si tratta di eject, skip, title con una istruzione valida successiva
				if (ictx.activeInstrKeyWordsSize == 1 
				&&  ictx.activeTypeInstr.getCobolInstrCategory() == EnumInstrDataCategory.COBOL_COMPILER_DIRECTIVE
				&&  nextTypeInstr != EnumCobolReservedWords.NOT_ASSIGNED) {
					ictx.numLastTokenCurInstr = iTokenCur - 1;
					ictx.numFirstTokenNextInstr = iTokenCur;
	                return nextTypeInstr;
				}


				// (2) Il Token inizia un'istruzione successiva data item, e quellotermina EXEC ...
				// 	   ...
				//     END-EXEC
				//     05 CAMPO  PIC 99.   		        token = "05"
				if (nextTypeInstr == EnumCobolReservedWords.DATA_DIV_DATA_ITEM
				&& (tokenPrec.equals("END-EXEC") || tokenPrec.equals("END-EXEC.")) 
				&&  !tokenCur.endsWith(".")) {
					ictx.numLastTokenCurInstr = iTokenCur - 1;
					ictx.numFirstTokenNextInstr = iTokenCur;
	                return nextTypeInstr;
				}

				// (3) Il Token inizia un'istruzione successiva data item, e quello precedente termina con .
				// 	   Non è un data item e deve essere SCARTATO.
				//     Caso  FD SKEDA BLOCK 01 RECORDS.    		token = "01"
				//     Caso  MOVE 5 TO campo					token = "5"	
				if (nextTypeInstr == EnumCobolReservedWords.DATA_DIV_DATA_ITEM
				&&  !tokenPrec.endsWith(".")
				&&  !tokenCur.endsWith(".")) {
	                continue;
				}

				// (4) Il Token termina il data item corrente.
				// 	   Non è un data item e deve essere SCARTATO.
				//     Caso  05 CAMPO  PIC 99.   		        token = "99."
				if (nextTypeInstr == EnumCobolReservedWords.DATA_DIV_DATA_ITEM
				&&  !tokenPrec.endsWith(".")
				&&   tokenCur.endsWith(".")) {
	                continue;
				}
				
				// (5) Il Token inizia un'istruzione successiva data item, e quello precedente termina con .
				//     Si tratta di istruzione valida di definizione dati successiva a quella corrente.
				// 		Caso  FD SKEDA BLOCK 01 RECORDS.
				//            05 Area PIC X(80).			token = "05"
				// 	    Caso  01 AREA.
				//            07 FILLER PIC X.				token = "07"
				if (nextTypeInstr == EnumCobolReservedWords.DATA_DIV_DATA_ITEM
				&&  tokenPrec.endsWith(".")) {
					ictx.numLastTokenCurInstr = iTokenCur - 1;
					ictx.numFirstTokenNextInstr = iTokenCur;
	                return nextTypeInstr;
				}

				// (5) Il Token inizia un'istruzione successiva di exception da scartare
				// 	   Si tratta di un token Exception dentro una istruzione Use
				//     Caso  Use Global After Standard ESXCEPTION Procedure On Input. token = "EXCEPTION"
				if (nextTypeInstr == EnumCobolReservedWords.PROC_ON_EXCEPTION
				&&  ictx.activeTypeInstr  == EnumCobolReservedWords.PROC_USE) {
		            continue;
				}
				
				// (6) Il Token inizia un'istruzione successiva valida per la sezione/divisione attiva.
				// 	   Si tratta di un token di inizio di una istruzione preceduto da istruzione
				//     chiusa o meno da un punto.
				//     Caso  MOVE A TO B,  IF A = B				token = "IF"
				if (nextTypeInstr != EnumCobolReservedWords.NOT_ASSIGNED) {
					ictx.numLastTokenCurInstr = iTokenCur - 1;
					ictx.numFirstTokenNextInstr = iTokenCur;
	                return nextTypeInstr;
				}
				
				// Token non trattato da nessun caso precedente
				// Si considera il token appartenente all'istruzione corrente
                
			} // end-for

			
	        
			// Sono stati trattati tutti i token disponibili senza individuare la fine
			// dell'istruzione corrente o l'inizio di una nuova istruzione.
			// Vengono accodati nuovi token dalle righe successive e si riprende la ricerca
			
			
			// La ricerca continua a partire dalla fine dell'ultimo token dell'ultima riga considerata. 
			// Per le righe successive si va da posizione 7 (0-based) per  colonne 8-72 (1-based)
			iTokenStart = al_tokenSpreaded.size();	
			
			// Recupero riga e posizione ultimo token accodato
			innerLastTokenInstr = al_tokenSpreaded.get(al_tokenSpreaded.size() - 1);
			rowCur = innerLastTokenInstr.numRowSource;
			posStart = innerLastTokenInstr.posInRow + innerLastTokenInstr.token.length();;	 
			
			// Accodo i token presenti nelle successive COBOL_PREFETCH_PARSING_ROWS righe utili
			getTokensSpreaded(ictx, al_tokenSpreaded, rowCur, posStart, COBOL_PREFETCH_PARSING_ROWS);
			
			// Nessun ulteriore token accodato: fine sorgente
			if (al_tokenSpreaded.size() == iTokenStart) {
				break;
			}
			
		} // end-while

		
		return EnumCobolReservedWords.NOT_ASSIGNED;
	}




	/* -------------------------------------------------------------------
	 * Compone l'istruzione a partire dalla riga e posizione di partenza.
	 * -------------------------------------------------------------------
	 * 
	 * Si considera da posStartInstr, rowStartInstr fino alla riga e 
	 * posizione di fine posEndInstr, rowEndInstr 
	 * Vengono eliminate le righe vuote e i commenti, accodati in cima all'istruzione
	 * Vengono scartate le righe con / a colonna 7
	 * In caso di riga di continuazione, con  trattino a colonna 7, se la riga inizia
	 * con un apice, si considera dal casrattere successivo
	 * 
	 */
	private String packageInstr(InnerContextAnalysis ictx) {
		
		String instrPackaged = "";
		String strInstrToPackage = "";
		String row = "";
         
        
		// Istruzione tutta sulla stessa riga
 
		// Accodamento da prima riga istruzione
		if (ictx.rowEndSource == ictx.rowStartSource) {
			instrPackaged = ictx.ar_RowsSource[ictx.rowStartSource].substring(ictx.posStartInstr, ictx.posEndInstr + 1);
			return instrPackaged.trim();
		}
		
		
 		// Istruzione spalmata su più righe
 		
		// Prima riga istruzione
		if (ictx.ar_RowsSource[ictx.rowStartSource].length() <=  72) {
			instrPackaged = ictx.ar_RowsSource[ictx.rowStartSource].substring(ictx.posStartInstr) + " ";
		} 
		if (ictx.ar_RowsSource[ictx.rowStartSource].length() >  72) {
			instrPackaged = ictx.ar_RowsSource[ictx.rowStartSource].substring(ictx.posStartInstr, 72);
		}  
				
		// Accodamento righe centrali e gestione ultima riga 
		for (int i = ictx.rowStartSource + 1; i <= ictx.rowEndSource; i++) {

			row = ictx.ar_RowsSource[i];
			
			// Estrazione commenti left, right e centrali e accodamento in array list di istruzione
			extractRowFields(ictx, ictx.ar_RowsSource[i]);
			if (row.length() > 7) {
				if (row.charAt(6) == '*') {
					ictx.al_CommentsBeforeInstr.add(ictx.rowInstr);
				}
			}
			if (!ictx.rowLeft.trim().equals("")) {
				ictx.al_CommentsLeftInstr.add(ictx.rowLeft);
			}
			if (!ictx.rowRight.trim().equals("")) {
				ictx.al_CommentsLeftInstr.add(ictx.rowRight);
			}

			// Riga vuota, o da 7 a 72 vuota
            if (isRowCobolEmpty(row)) {
				continue;
			}
            
			// Riga commento o salto a canale
            if (isCobolRowComm(row)){
				continue;
			}
            
			// Parte centrale riga vuota
			if (row.length() > 72) {
				if (row.substring(7, 72).trim().equals("")) {
					continue;
				}
			}
			if (row.length() > 7 && row.length() < 72) {
				if (row.substring(7).trim().equals("")) {
					continue;
				}
			}

			// Accodamento righe istruzione centrali a stringa con istruzione completa
			if (i < ictx.rowEndSource && row.length() > 7) {
				if (row.length() < 72) {
					strInstrToPackage = row.substring(7).trim();
				} else {
					// Istruzioni precompilatori senza i vincoli cobol
					if (ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_SQL 
					||  ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_CICS
					||  ictx.activeTypeInstr == EnumCobolReservedWords.PRECOMPILER_DL1) {
						strInstrToPackage = row.substring(7);
						// Escludo col 73-80 cobol se presenti
						if (row.length() == 80 && row.charAt(71) == ' ' && !row.substring(72).equals("") ) {
							strInstrToPackage = row.substring(7, 72).trim();
						}
					// Istruzione cobol fino a col 72
					} else {
						strInstrToPackage = row.substring(7, 72).trim();
					}
				}
				// Non è una riga di continuazione: spaziatura fra i token
				if (row.charAt(6) != '-') {
					instrPackaged = instrPackaged + " " + strInstrToPackage;
					continue;
				}
				// Continiuazione: si deve accodare senza spazi
				instrPackaged = instrPackaged.trim() + strInstrToPackage;
				continue;
			}

			// Ultima riga istruzione 
			if (i == ictx.rowEndSource) {
				// Non è una riga di continuazione: spaziatura fra i token
				if (row.charAt(6) != '-') {
				   instrPackaged = instrPackaged + " " + row.substring(7, ictx.posEndInstr + 1).trim();
				   continue;
				}
				// Continuazione: si deve accodare senza spazi
				instrPackaged = instrPackaged.trim() +  row.substring(7, ictx.posEndInstr + 1).trim();
				continue;
			}
		}
		
		return instrPackaged.trim();
	}

  
	/**
	 * 
	 * Estrazione informazioni specifiche dalla riga di 80 crt (max)
	 * ovvero continuazione, valore a sinistra, a destra e parte centrale
	 * 8-72, ovvero l'istruzione effettiva.
	 * @param ictx 
	 * 
	 */
	private void extractRowFields(InnerContextAnalysis ictx, String rowAll ) {
		
		ictx.rowLeft = "";
		ictx.rowCont = "";
		ictx.rowRight = "";
		ictx.rowInstr = "";
		
		if (rowAll.length() > 6) {ictx.rowLeft = rowAll.substring(0, 6);}
		if (rowAll.length() > 7) {ictx.rowCont = rowAll.substring(6, 7);}             
		if (rowAll.length() > 72) {ictx.rowRight = rowAll.substring(72);} 
		
		if (rowAll.length() == 72) {ictx.rowInstr = rowAll.substring(7);}         
		if (rowAll.length() > 72) {ictx.rowInstr = rowAll.substring(7,72);}         
		if (rowAll.length() > 7 && rowAll.length() < 72 ) {ictx.rowInstr = rowAll.substring(7);}
		
	}


	/**
	 * 
	 * Inizializzo strutture dinamiche di memorizzazione di una istruzione
	 * @param ictx 
	 * 
	 */
	private void initializeForNewInstruction(InnerContextAnalysis ictx) {
		
		ictx.rowLeft = "";			
		ictx.rowRight = "";		
		ictx.rowInstr = "";          
		ictx.rowCont = "";
		
		// Per gestione dinamica commenti incontrati prima dell'istruzione, a sinistra e a destra
		ictx.al_CommentsBeforeInstr.clear();       
		ictx.al_CommentsLeftInstr.clear();              
		ictx.al_CommentsRightInstr.clear();           
	} 
	
	/**
	 * 
	 * Accodamento commenti a sinistra e a destra dell'istruzione.
	 * @param ictx 
	 * 
	 */
	private void addCommentsLeftRight(InnerContextAnalysis ictx) {

		ictx.al_CommentsLeftInstr.add(ictx.rowLeft);
		ictx.al_CommentsRightInstr.add(ictx.rowRight);
	} 

	/*
	 * 
	 *  Salva le informazioni di origine sorgente dell'istruzione a meno di:
	 *  
	 *     	rowStartSource 
     * 		rowEndSource 
     * 		posStartInstr 
     * 		posEndInstr 
     *
	 * Impostati a fine reperimento istruzione 
	 * @param ictx 
	 */
	private void saveSourceInstructionInfo(InnerContextAnalysis ictx, InstructionCobol i) {
	    
		int k = 0;
	    int j = 0;
		
		// Allocazione e caricamento Arrays
		ictx.ar_CommentsBeforeInstr = new String[ictx.al_CommentsBeforeInstr.size()];
		ictx.ar_CommentsBeforeInstr = ictx.al_CommentsBeforeInstr.toArray(ictx.ar_CommentsBeforeInstr);
		ictx.ar_CommentsLeftInstr = new String[ictx.al_CommentsLeftInstr.size()];
		ictx.ar_CommentsLeftInstr = ictx.al_CommentsLeftInstr.toArray(ictx.ar_CommentsLeftInstr);
		ictx.ar_CommentsRightInstr = new String[ictx.al_CommentsRightInstr.size()];
		ictx.ar_CommentsRightInstr = ictx.al_CommentsRightInstr.toArray(ictx.ar_CommentsRightInstr);
		
		ictx.ar_RowsSourceInstruction = new String[ictx.rowEndSource - ictx.rowStartSource + 1];
		j = 0;
        for (k = ictx.rowStartSource; k <= ictx.rowEndSource; k++) {
        	ictx.ar_RowsSourceInstruction[j] = ictx.ar_RowsSource[k];
        	j++;
		}
		
		// Caricamento informazioni sorgente nell' oggetto istruzione
        i.setNumInstr(ictx.numInstr);
    	i.setName(ictx.nameInstr);   
        i.setCommentsBefore(ictx.ar_CommentsBeforeInstr);
//    	i.setCommentsLeft(ictx.ar_CommentsLeftInstr);
//    	i.setCommentsRight(ictx.ar_CommentsRightInstr);
    	i.setRowsSource(ictx.ar_RowsSourceInstruction);
    	i.setSourceInstr(ictx.sourceInstr);
    	i.setTerminatedWithPoint(ictx.instrTerminatedWithPoint);
 	}
	

	/**
	 * 
	 *  Memorizza le informazioni di origine sorgente dell'istruzione
	 *  nell'istruzione generata
	 *  
	 */
	private void storeSourceInstructionInfo(Instruction instrSaved, Instruction instrToUpdate) {
	    
		// Caricamento informazioni sorgente nell' oggetto istruzione
		instrToUpdate.setNumInstr(instrSaved.getNumInstr());
     	instrToUpdate.setRowStartSource(instrSaved.getRowStartSource());
     	instrToUpdate.setRowEndSource(instrSaved.getRowEndSource()); 
    	instrToUpdate.setPosStartInstr(instrSaved.getPosStartInstr()); 
     	instrToUpdate.setPosEndInstr(instrSaved.getPosEndInstr()); 
    	instrToUpdate.setName(instrSaved.getName());   
    	instrToUpdate.setCommentsBefore(instrSaved.getCommentsBefore());
//    	instrToUpdate.setCommentsLeft(instrSaved.getCommentsLeft());
//    	instrToUpdate.setCommentsRight(instrSaved.getCommentsRight());
    	instrToUpdate.setRowsSource(instrSaved.getRowsSource());
    	instrToUpdate.setSourceInstr(instrSaved.getSourceInstr());
    	instrToUpdate.setTerminatedWithPoint(instrSaved.isTerminatedWithPoint());
 	}


 	


	/* ----------------------------------------------------------
	 * Verifica se token di inizio, fine o dentro literal
	 * ----------------------------------------------------------
	 * 
	 * Viene restituito true nei seguenti casi:
	 * 
	 * 1) Il token inizia una literal fra apici normali come
	 *    ', 'A, ''', '", etc
	 *    Mette ON il flag di literal aperta.
	 *    
	 * 2) Il token inizia una literal fra apici doppi come
	 *    ", "A, """, "', etc
	 *    Mette ON il flag di literal aperta.
	 *    
	 * 3) Il token chiude una literal fra apici normali come
	 *    ', Z', "', etc.
	 *    Mette OFF il flag di literal aperta.
	 *    
	 * 4) Il token chiude una literal fra apici doppi come 
	 *    ", Z", '", etc
	 *     Mette OFF il flag di literal aperta.
	 *     
	 * 5) Il token apre e chiude una literal fra apici normali come
	 *    '', 'ABCD', 'A"', 'A""Z', etc
	 *     Nessuna variazione al flag di literal aperta.
	 *     
	 * 6) Il token apre e chiude una literal fra apici doppi come
	 *    "", "ABCD", "A'", "A''Z", etc
	 *    Nessuna variazione al flag di literal aperta.
	 * 
	 * 7) Il token è dentro una literal ed è del tipo
	 *    ABC'', A'''', ZZ'''''', ABC"", A"""", ZZ""""""
	 *    ''ABC, ''''A, ''''''ZZ, ""ABC, """"A, """"""ZZ
	 * 
	 * 8) Il token non inizia e non termina con apici ma  
	 *    il flag di literal aperta è on.
	 *    
	 * 9) Il token è una virgola di interpunzione o parentesi
	 * 
	 * 
	 * Negli altri casi restituisce false
	 *  
     */
	private boolean isTokenToBypass(InnerContextAnalysis ictx, String token) {
        
		String tokenNormalized = "";
		char singleApice = 39;					// Apice singolo '
		char doubleApice = 34;					// Doppio apice ""
		char curApice = 39;					    // Apice corrente apertura/chiusura literal
		char curApiceAlternative = 34;			// Apice corrente apertura/chiusura literal
		int countApice = 0;                     // Numero apici presenti nel token
		int countApiceAlternative = 0;          // Numero apici presenti nel token
		int iApiceSingle = 0;                   // Offset apice singolo nel token
		int iApiceDouble = 0;					// Offset apice doppio   nel token

		
		//////////////////////////////////////////////////
		// In Identification division nessuna gestione
		//////////////////////////////////////////////////
		
		if (this.activeDivisionArea == EnumCobolReservedWords.ID_DIVISION) {
			return false;
		}

		
		//////////////////////////////////////////////////
		// Da bypassare sia dentro sia fuori literal
		//////////////////////////////////////////////////
		
		// Token sotto esame virgola di interpunzione
		if (token.equals(",")) {
			return true;
		}

		// Doppi o quadrupli apici semplici '': dentro literal o literal vuota
		if (token.equals("''")
		||  token.equals("''''")) {
			return true;
		}
		
		// Doppi o quadrupli apici "": dentro literal o literal vuota
		if (token.equals(doubleApice + doubleApice)
	    ||  token.equals(doubleApice + doubleApice + doubleApice + doubleApice)	) {
			return true;
		}


		//////////////////////////////////////////////////
		// Normalizzazione token
		//////////////////////////////////////////////////
		
		tokenNormalized = token;
		
		// Elimino eventuale virgola iniziale, finale, punto finale e parentesi chiusa
		// per semplificare i controlli
		if (tokenNormalized.startsWith(",")) {
			tokenNormalized = tokenNormalized.substring(1);
		}
		if (tokenNormalized.endsWith(",")) {
			tokenNormalized = tokenNormalized.substring(0, tokenNormalized.length() - 1);
		}
		if (tokenNormalized.endsWith(".")) {
			tokenNormalized = tokenNormalized.substring(0, tokenNormalized.length() - 1);
		}
		if (tokenNormalized.endsWith(")")) {
			tokenNormalized = tokenNormalized.substring(0, tokenNormalized.length() - 1);
		}

		/////////////////////////////////////////////////
		// Da bypassare sicuramente
        /////////////////////////////////////////////////
		
        if (tokenNormalized.equals("")
        ||  tokenNormalized.equals("(")	
        ||  tokenNormalized.equals(")")) {
			return true;
		}
		
        
		// Da bypassare sicuramente: apici dentro statement Author
		if (ictx.activeTypeInstr == EnumCobolReservedWords.ID_DIV_AUTHOR
		&& (tokenNormalized.indexOf(singleApice) > 0 ||	tokenNormalized.indexOf(doubleApice) > 0)) {
			return true;
		}
		
        
		/////////////////////////////////////////////////
		// Condizioni di literal piena aperta e chiusa
        /////////////////////////////////////////////////
		
		// Literal aperta e chiusa da apici singoli
		if (!ictx.isLiteralInProgress
	    &&  tokenNormalized.length() > 2
		&&  tokenNormalized.charAt(0)  ==  singleApice
		&&  tokenNormalized.charAt(tokenNormalized.length() - 1)  ==  singleApice
		&&  StringService._countCrt(tokenNormalized, singleApice)%2 == 0) {
			return true;
		}

		// Literal aperta e chiusa da apici doppi
		if (!ictx.isLiteralInProgress
		&&	tokenNormalized.length() > 2
		&&  tokenNormalized.charAt(0)  ==  doubleApice
		&&  tokenNormalized.charAt(tokenNormalized.length() - 1)  ==  doubleApice
		&&  StringService._countCrt(tokenNormalized, doubleApice)%2 == 0) {
			return true;
		}
		

		/////////////////////////////////////////////////
		// Condizioni di apertura literal
        /////////////////////////////////////////////////
		
		// Inizio literal con apici singoli
		if (!ictx.isLiteralInProgress
		&&  tokenNormalized.charAt(0)  ==  singleApice
		&&  StringService._countCrt(tokenNormalized, singleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = false;
			return true;
		}

		// Inizio literal con apici doppi
		if (!ictx.isLiteralInProgress
		&&  tokenNormalized.charAt(0)  ==  doubleApice
		&&  StringService._countCrt(tokenNormalized, doubleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = true;
			return true;
		}  

		// Inizio literal speciali con apici singoli  
		if (!ictx.isLiteralInProgress
		&& (tokenNormalized.startsWith("N'") ||
		    tokenNormalized.startsWith("Z'") ||
		    tokenNormalized.startsWith("X'") ||
		    tokenNormalized.startsWith("NX'")
		   )
		&&  StringService._countCrt(tokenNormalized, singleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = false;
			return true;
		}
		
		// Inizio literal speciali con apici doppi  
		if (!ictx.isLiteralInProgress
		&& (tokenNormalized.startsWith("N"+doubleApice) ||
		    tokenNormalized.startsWith("Z"+doubleApice) ||
		    tokenNormalized.startsWith("X"+doubleApice) ||
		    tokenNormalized.startsWith("NX"+doubleApice)
		   )
		&&  StringService._countCrt(tokenNormalized, doubleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = true;
			return true;
		}
		
		// Offset eventuali primi apici singoli e doppi nel token
		iApiceSingle = tokenNormalized.indexOf(singleApice);
		iApiceDouble = tokenNormalized.indexOf(doubleApice);

		// Inizio literal con apici singoli preceduta da altri crt (par chiusa, istruzione etc.)
		if (!ictx.isLiteralInProgress
		&&  iApiceSingle > 0
		&& (iApiceDouble > iApiceSingle || iApiceDouble == -1)
		&&  StringService._countCrt(tokenNormalized, singleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = false;
			return true;
		}

		// Inizio literal con apici singoli preceduta da altri crt (par chiusa, istruzione etc.)
		if (!ictx.isLiteralInProgress
		&&  iApiceDouble > 0
		&& (iApiceSingle > iApiceDouble || iApiceSingle == -1)
		&&  StringService._countCrt(tokenNormalized, doubleApice)%2 > 0) {
			ictx.isLiteralInProgress = true;
			ictx.isLiteralDoubleDelimited = true;
			return true;
		}
		
		
		
		
		/////////////////////////////////////////////////
		// Condizioni di skip dentro literal
        /////////////////////////////////////////////////
		
		// Impostazione crt di delimitazione literal e il suo opposto
		if (ictx.isLiteralDoubleDelimited) {
			curApice = doubleApice;
			curApiceAlternative = singleApice;
		} else {
			curApice = singleApice;
			curApiceAlternative = doubleApice;
		}
		
		// Token contiene un numero pari di apici semplici ('AA'B)
		countApice = StringService._countCrt(token, singleApice);
		if (ictx.isLiteralInProgress
		&&	countApice > 0 && NumericService.isEven(countApice)) {
			// Token NON di chiusura literal
			if (tokenNormalized.charAt(tokenNormalized.length() - 1)  !=  curApice) {
				return true;
			}
		}
				
		// Token contiene un numero pari di apici doppi ("AA"B)
		countApice = StringService._countCrt(token, doubleApice);
		if (ictx.isLiteralInProgress
		&&	countApice > 0 && NumericService.isEven(countApice)) {
			// Token NON di chiusura literal
			if (tokenNormalized.charAt(tokenNormalized.length() - 1)  !=  curApice) {
				return true;
			}
		}

		// Token contiene numero pari di apici e nessuno opposto (CCC'')
		countApice = StringService._countCrt(token, curApice);
		countApiceAlternative = StringService._countCrt(token, curApiceAlternative);
		if (ictx.isLiteralInProgress
		&&	countApice > 0 
		&& NumericService.isEven(countApice)
		&& countApiceAlternative == 0) {
			return true;
		}
		
		/////////////////////////////////////////////////
		// Condizioni di chiusura literal
        /////////////////////////////////////////////////
		
		// Fine literal fra apici singoli
		if (ictx.isLiteralInProgress
		&& !ictx.isLiteralDoubleDelimited
		&&  StringService._countCrt(tokenNormalized, singleApice)%2 > 0) {
			ictx.isLiteralInProgress = false;
			return true;
		}  

		// Fine literal fra apici doppi
		if (ictx.isLiteralInProgress
		&&  ictx.isLiteralDoubleDelimited
		&&  StringService._countCrt(tokenNormalized, doubleApice)%2 > 0) {
			ictx.isLiteralInProgress = false;
			return true;
		}  
		
		
		/////////////////////////////////////////////////
		// Literal non aperta, token da NON skippare
        /////////////////////////////////////////////////
		
		if (!ictx.isLiteralInProgress) {
			return false;
		}  

		
		
		// In questo punto la gestione literal è in progress
		// Il token non identifica la fine della literal corrente
		// Il token è all'interno della literal
		// Si restituisce true affinchè il chiamante non lo tratti

		return true;
	}


	
	/*
     * Restituisce true se qualche campo del copy è utilizzato nel programma
     * 
     */
    private boolean isAnyDataItemUsed(ArrayList<InstructionCobolDataItem> al_dataItemCopy) {
    	
        int dataItemPointer = 0;
        int ar_xrefPointerInput[] = null;; 
        int ar_xrefPointerOutput[] = null; 
        boolean isCopyUsed = false;
        
        
        // Scan data items copy
        for (InstructionCobolDataItem dataItem : al_dataItemCopy) {
          	
        	dataItemPointer = dataItem.getNumInstr();
         	
        	// Estraggo gli utilizzi in input nel programma
     		ar_xrefPointerInput = this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_INPUT);
         	ar_xrefPointerOutput = this.programCobol.xrefToDataItemInProcedure(dataItemPointer, INSTR_USE_DATA_ITEM_OUTPUT);
         	
        	if (ar_xrefPointerInput !=  null || ar_xrefPointerOutput !=  null) {
         		isCopyUsed = true;
         		break;
			}
            	
		} // end-for copy entries
  		
		return isCopyUsed;
	}



	/*
	 * 
	 * Verifica se l'istruzione corrente è una label Cobol.
	 * 
	 * Non deve essere una parola riservata.
	 * Deve terminare con un punto.
	 * Deve iniziare a colonna 8.
	 * 
	 */
    private boolean isLabelCobol(ArrayList<InnerTokenInstr> al_tokenSpreaded, int numToken) {
		
      	String label = "";
        String tokenNext = "";
        
    	label = al_tokenSpreaded.get(numToken).token;
    	if (numToken + 1 < al_tokenSpreaded.size()) {
    		tokenNext = al_tokenSpreaded.get(numToken + 1).token;
		}
    	
    	// Il token non inizia a colonna 8: non è una label
    	if ( al_tokenSpreaded.get(numToken).posInRow > 8) {
			return false;
		}
    	
    	// Il token è la terminazione di una Section.
    	// La Section viene identificata in modo esplicito.
    	if (label.equals("SECTION.")) {
			return false;
		}
    	
    	// Il token non termina con un punto e il token successivo NON è un punto.
    	// La label potrebbe essere codificata con un punto non consecutivo come:
    	//   label  . invece di label.
    	if (!label.endsWith(".")
    	&& 	!tokenNext.equals(".")	) {
			return false;
		}
     	
    	// Elimino il punto
    	label = label.substring(0, label.length() - 1);
    	
       	// Il token NON deve essere una parola riservata
    	if (map_ReservedWords.get(label) != null) {
			return false;
		}

    	// E' una label
    	
		return true;
	}

	/*
	 * 
	 * Verifica se l'istruzione corrente è una Section Cobol.
	 * 
	 */
    private boolean isSectionCobol(ArrayList<InnerTokenInstr> al_tokenSpreaded, int numTokenStart) {
         	
    	String token = "";
          	
        	token = al_tokenSpreaded.get(numTokenStart).token;
        	
        	// Il primo token non deve terminare con un punto
        	if (token.endsWith(".") ) {
    			return false;
    		}
         	
        	// Il primo token NON deve essere una parola riservata
        	if (map_ReservedWords.get(token) != null) {
    			return false;
    		}
         	
        	// Il secondo token, se c'è, deve essere section 
        	if (al_tokenSpreaded.size() > numTokenStart + 1) {
 				token = al_tokenSpreaded.get(numTokenStart + 1).token;
            	if (token.equals("SECTION.") || token.equals("SECTION")) {
            		return true;
       			}
     		}
           	return false;

	}




    /*
     * Restituisce true se la parola riservata è una parola valida di inizio istruzione.
     */
 
	private boolean isValidStartInstruction(InnerContextAnalysis ictx, EnumCobolReservedWords word) {
		
		EnumInstrDataCategory wordCategory = word.getCobolInstrCategory();
		
		// Categoria istruzioni analizzabili
		switch (wordCategory) {
				case COBOL_DATA_ITEM:
					if (this.activeDivisionArea != EnumCobolReservedWords.DATA_DIVISION) {
						return false;
					}
					if (word == EnumCobolReservedWords.DATA_DIV_DATA_ITEM) {
						return true;
					} else {
						return false;
					}
				case COBOL_SOURCE_IDENTIFICATION:
					return true;
				case COBOL_ENVIRONMENT_DEFINITION:
					return true;
				case COBOL_STRUCTURE_DEFINITION:
					return true;
				case COBOL_PROC_INSTRUCTION:
					// Incontrata Procedure division e divisione non impostata
					if (word == EnumCobolReservedWords.PROC_DIVISION) {
						return true;
					}
					// Ricerca next instrDynamic di Procedure division e divisione non impostata
					if (ictx.activeTypeInstr == EnumCobolReservedWords.PROC_DIVISION) {
						return true;
					}
					if (this.activeDivisionArea != EnumCobolReservedWords.PROC_DIVISION) {
						return false;
					} else {
						return true;
					}
				case COBOL_PROC_INSTRUCTION_EXCEPTION:
					if (this.activeDivisionArea != EnumCobolReservedWords.PROC_DIVISION) {
						return false;
					} else {
						return true;
					}
				case COBOL_SECTION_PROGRAM_DELIMITER:
					return true;
				case COBOL_COPY_INSTRUCTION:
					return true;
				case COBOL_COMPILER_DIRECTIVE:
					return true;
				case SQL_PRECOMPILER:
					return true;
				case CICS_PRECOMPILER:
					return true;
				case DL1_PRECOMPILER:
					return true;
		default:
			return false;
		}
						
   }

 

	/*
	 * 
	 * Restituisce true se las parola è unas parola di inizio
	 * clausola di un data item
	 * 
	 */
	private boolean isStartDataItemClause(String token) {
		
		// E' una parola di inizio clausola
		if (token.equals("REDEFINES") 
				||  token.equals("RENAMES")
				||  token.equals("PICTURE")
				||  token.equals("PIC")
				||  token.equals("USAGE")
				||  token.equals("BLANK")
				||  token.equals("JUSTIFIED")
				||  token.equals("JUST")
				||  token.equals("SIGN")
				||  token.equals("SYNCRONIZED")
				||  token.equals("SYNC")
		  		||  token.equals("OCCURS")
		  		||  token.equals("INDEXED")
	    	) {
			return true;
		}
		
		return false;
	}


	
    ////////////////////////////////////////////////////////////////////////////////////////////
	////////////////// Classi interne di servizio usate come strutture dati  /////////////////// 
    ////////////////////////////////////////////////////////////////////////////////////////////
	

	
	/*
	 * 
	 * Classe contenitore con le informazioni correnti sull'analisi del sorgente corrente.
	 * 
	 * Le informazioni sono relative al contesto di uno specifico livello ricorsivo.
	 * Una istanza viene istanziata relativamente al programma sotto analisi. 
	 * Per ogni modulo copy viene creata una nuova istanza e attivata l'analisi, ricorsivamente. 
	 * Così a qualsiasi livello di ricorsività dei moduli copy.
	 * 
	 */
	public class InnerContextAnalysis implements Cloneable {
		InnerDescriptorSource ids = null;               // Descrittore sorgente sotto analisi (non sempre valido)
		
		// Info per Procedure Division dentro copy, rilevate PRIMA dell'analisi, nella normalizzazione source
		String copyNameWithProcedureDivStmt = "";       // Nome copy da cui iniziare a considerare procedure division
		int numRowCopyNameWithProcedureDivStmt = 0;     // Numero riga sorgente con copy con procedure division
		boolean isProcDivisionInsideCopy = false;       // True indica copy NON visibile nel source
		
		// Divisioni cobol omesse (MF)
		boolean isEnvDivisionMissing = false;           // Omessa Environment division 
		boolean isDataDivisionMissing = false;          // Omessa Data division 
	    
		// Istruzione Copy origine dell'analisi ricorsiva, utilizzata per replacing by su items inclusi
		boolean isAnalysisOfProgram = true;             // False indica elaborazione a fronte di analisi specifica copy con metodo analyzeCopy()
		boolean isCopyIncludingInProgress = false;      // True inclusione di copy in corso. Eventuali copy statements NON devono essere inclusi nuovamente
		boolean isCopyAncestorDeserialized = false;     // True indica che il copy con copy nested presente nel programma è stato deserializzato e NON analizzato
		boolean isInstructionToAnalyze = false;         // True indica istruzione da analizzare in quanto nel source di programma o dentro copy con replacing by avvenuti
		boolean isSqlIncludeUnderAnalysis = false;      // True indica simulazione COPY stmt a fronte di SQL INCLUDE
		InstructionCobol copyStmt = null;               // Già analizzata e con le informazioni di replacing
		ArrayList<ProgramCobolEntry<? extends Instruction>> al_CopyEntry = null;   // Istruzioni nel copy al livello di nesting corrente.
        String copyName = "";                           // Nome copy corrente se attiva analisi di un copy, impostato anche a fronte di statement copy
        String copyNameCaller = "";                     // Nome copy chiamante
        String copyNameAncestor = "";                   // Nome copy primo livello di copy nested. E' il copy esplicitamente indicato nel programma
        int copyNestinglevel = 0;                       // Livello annidamento copy >= 0. 0 = nessun annidamento, >=1 = Copy annidato al livello indicato

		// Identificazione sorgente e istruzione
		SourceInput si = null;							// Descrittore completo sorgente sotto analisi
		EnumCobolReservedWords activeTypeInstr = null;  // Tipologia istruzione codificata, come parola riservata di inizio
		EnumSourceType activeTypeSource = null;         // Tipologia sorgente sotto analisi
		String[] ar_RowsSource = null;            		// Array righe sorgente  complessive
		String[] ar_RowsSourceInstruction = null;       // Array righe sorgente  istruzione corrente pacchettizzata. Include ebentuali altre istruzioni stessa riga
		String activeSourceName = "";                   // Nome sorgente in analisi, programma o copy al livello nesting corrente
		EnumObject activeTypeObject = null;             // Tipo oggetto sorgente in analisi, programma o copy al livello nesting corrente
		int activeInstrKeyWordsSize = 0;  	      		// Numero parole chiave che hanno identificato l'istruzione corrente
	    int numLastTokenCurInstr = 0;					// Ultima parola istruzione corrente
	    int numFirstTokenNextInstr = 0;					// Prima parola istruzione successiva
		int numInstr = 0;                     	 		// Numero sequenza entry (0-based)
		int rowStartSource = 0;	                 		// Numero riga sorgente di analisi di inizio
		int rowEndSource = 0;	                 		// Numero riga sorgente di analisi di fine
		int posStartInstr = 7;	             			// Pos 0-based inizio istruzione in riga sorgente (include col 1-7)
		int posEndInstr = 71;	                 		// Pos 0-based fine istruzione in riga sorgente   (include col 1-7)
		String nameInstr = null;                  		// Nome istruzione (es. IF)
		boolean isInstrPrecompilerInProgress = false;   // True indica token dentro Exec Cics/Sql/Dl1/..
		boolean isLiteralInProgress = false;            // True indica token dentro literal in identificazione istruzione successiva
		boolean isLiteralDoubleDelimited = false;       // Nome istruzione (es. IF)
	    String sourceInstr = "";			 		 	// Istruzione source estratta completa, senza punto finale
	    Object objectInstr = "";			 		 	// Oggetto Instruction codificato da sourceInstr
	    InstructionCobol curInstrInfo = null;           // Contiene numeri riga e posizione istruzione corrente  

		// Commenti istruzione corrente
	    ArrayList<String> al_CommentsBeforeInstr = null;// ArrayList righe commento precedenti l'istruzione  
	    ArrayList<String> al_CommentsLeftInstr = null;  // ArrayList righe commento prima di ogni istruzione     
	    ArrayList<String> al_CommentsRightInstr = null; // ArrayList righe commento dopo di ogni istruzione         
		String[] ar_CommentsBeforeInstr = null;   		// Array righe commento precedenti l'istruzione
		String[] ar_CommentsLeftInstr = null;     		// Array righe commento prima di ogni istruzione
		String[] ar_CommentsRightInstr = null;    		// Array righe commento dopo di ogni istruzione

		// Campi e variabili di servizio per estrazione istruzione da righe sorgente
	    String token = "";						  			// Token di servizio
	    String curToken = "";								// Token corrente istruzione sotto analisi
	    String rowAll = "";									// Pos 1-80
	    String rowLeft = "";								// Pos 1-6
	    String rowRight = "";								// Pos 73-80
	    String rowInstr = "";               				// Pos 8-72
		String rowCont = "";                				// Pos 7		(continuazione)

	    // Stato analisi istruzione e flag vari
		boolean instrTerminatedWithPoint = false; 			// True indica istruzione terminata con un punto
	    boolean isAnyInstructionErrorDetected = false;  	// True indica un errore di parsing durante l'analisi sorgenti o semantico o di ceazione grafo (semantico) 
	    boolean isAnyInstructionWarningDetected = false;	// True indica un warning da segnalare a fonte dell'analisi istruzione
	    boolean isCopySourceDetected = false;           	// True indica source copy già acquisito nel sistema a fronte di LibraryScan
        boolean isCopyFoundOnPathSourceDetected = false;	// True indica source copy trovato nel path individuato a fronte di LibraryScan
        boolean isCopyObjectFound = false;	                // True indica object copy trovato in tabella object per il sys/subsys corrente 	    
        boolean isWithDynamicCode = false;                  // True indica programma con codice dinamico
 	    boolean isWithDynamicCodeSolved = false;            // True indica programma con codice dinamico con tutte le istruzioni risolte
 	    boolean isWithDynamicCodeSpreadedToSolve = false;   // True indica programma con codice dinamico con istruzioni da risolvere in programmai chiamanti
 	    boolean isWithDynamicCodeWaitingForData = false;    // True indica programma con codice dinamico con istruzioni in attesa di dati esterni
  
        // Campi vari di servizio
		int curProcInternalPointer = 0;                 	// Numero istruzione ssection attiva
	    String curProcInternalName = "";                	// Section name attiva
		String copyPathSourceDetected = "";             	// Path completo di suffisso del copy acquisito da libraryScan
	    
	    // Metriche e informazioni su anomalie sorgente
		Metrics metrics = null;                             // Classe contenitore mtriche

        // ------------------------------------------------------------
	    // Informazioni specifiche a livello di analisi/inclusione copy
	    // ------------------------------------------------------------	    
		CopyCobol objectCopyCobol = null;
		ProgramCobolEntry<? extends Instruction> programEntry = null;
 		ProgramCobolEntry<? extends Instruction> ar_CopyEntry[] = null;
 		Instruction instructionGeneric = null;
		InstructionCobol instructionCobol = null;
		InstructionCics instructionCics = null;
		InstructionSql instructionSql = null;
      	Object ar_Object[] = null;                                      // Mappato da map copyDetected
       	ArrayList<InstructionCobol> al_CopyStmt = null;                 // Secondo elemento ar_Object
	    ArrayList<CopyCobol> al_CopyObject = null;                      // Terzo elemento ar_Object
 		SourceInput siCopy = null;
 		ExceptionAmrita excp = null;  
		String copyNameToInclude = "";
		String sysCopyNameToInclude = "";
		String subSysCopyNameToInclude = "";
		EnumSourceType typeCopySource = null;	
		EnumObject typeCopyObject = null;	
		boolean isStatementReplaced = false;

	    
	    /*
	     * 
	     * Costruttore
	     * 
	     */
		public InnerContextAnalysis() {
			al_CommentsBeforeInstr = new ArrayList<String>();       
			al_CommentsLeftInstr = new ArrayList<String>();        
			al_CommentsRightInstr = new ArrayList<String>();   
			activeTypeInstr = EnumCobolReservedWords.ID_DIVISION; 
		    curInstrInfo = new InstructionCobol();
		    al_CopyEntry = new ArrayList<ProgramCobolEntry<? extends Instruction>> ();
		    metrics = new Metrics();
		}


		/* (non-Javadoc)
		 * @see java.lang.Object#clone()
		 */
		@Override
		protected InnerContextAnalysis clone()  {
			InnerContextAnalysis ictxCloned = null;

			try {
				ictxCloned =   (InnerContextAnalysis) super.clone();
			} catch (CloneNotSupportedException e) {
				// Exception ne chiamanti
				ictxCloned = null;
			}
			
			// Inizializzazione variabili per nuovo contesto
			ictxCloned.activeInstrKeyWordsSize = 0;  	    
			ictxCloned.numLastTokenCurInstr = 0;				 
			ictxCloned.numFirstTokenNextInstr = 0;					 
			ictxCloned.numInstr = 0;                     	 		 
			ictxCloned.rowStartSource = 0;	                 		 
			ictxCloned.rowEndSource = 0;	                 		 
			ictxCloned.posStartInstr = 7;	             			 
			ictxCloned.posEndInstr = 71;	                 		 
			return ictxCloned;
		}

	
	}



	
	/*
	 *   Classe contenitore di servizio associato alla prima parola riservata di istruzioni Cobol.
	 *   
	 *   Tale parola può essere per esempio "NOT" di NOT AT END o di NOT INVALID KEY etc.,
	 *   che rappresentano istruzioni Cobol diverse.
	 *   Ogni entry contiene, se esistono, tutte parole che identificano l'istruzione 
	 *   
	 *   
	 */
	@SuppressWarnings("unused")
	private class InnerInstructionWordsEntry {
		
		// Per riconoscimento istruzioni o parte di istruzioni
		public EnumCobolReservedWords en_WordReservedOwner = null; // Enum parola riservata indicante l'istruzione
		public EnumInstrDataCategory en_InstrCategory = null;      // Categoria word: istruzione, costante figurativa etc.
		public ArrayList<String> al_wordKey = null;                // Sequenza completa di parole chiave valide identificanti l'istruzione 
		public String wordKeyFirst = "";                           // Prima parola chiave identificante l'istruzione
		
		
        /*
         * Costruttore
         */
        private InnerInstructionWordsEntry() {
        	en_WordReservedOwner = EnumCobolReservedWords.NOT_ASSIGNED;
        	en_InstrCategory = EnumInstrDataCategory.NOT_ASSIGNED;
        	al_wordKey = new ArrayList<String> ();
		}
	}

	
	
	
	/*
	 *   Classe contenitore di servizio per i singoli token estratti
	 *   dalle righe sorgente da valutare
	 *   
	 */
	private class InnerTokenInstr implements Cloneable{
		
		// Valori di identificazione token  
		String token = "";                           		  // Parola corrente estratta dalla riga sorgente
		int numRowSource = 0;                                 // Numero corrente riga sorgente di appartenenza
		int posInRow = 0;                                     // Posizione corrente in riga 0-based da colonna 1
		/**
		 * @return
	//	 * @see java.lang.String#toString()
		 */
		public String toString() {
			return token.toString();
		}
		/* (non-Javadoc)
		 * @see java.lang.Object#clone()
		 */
		@Override
		protected Object clone()  {
			try {
				return super.clone();
			} catch (Exception e) {
				return null;
			}
		}
        
	}
		
	/*
	 * 
	 * Descrive le informazioni sulle Section o le procedure 
	 * richiamate con Perform Thru dal programma.
	 * Nel caso di procedura interna richiamata con perform thru, il nome del sottografo
	 * è labelFrom-labelTo
	 * 
	 * 
	 */
	@SuppressWarnings("unused")	
	private class InnerInternalProcedure {
        
		// Identificativo uusato come chiave su db 
		// Se non era perform thru coincide con idProcedurePerformed
		String idProcedurePerformedComplete = "";       // Id completo come Perform proc:procThru
		
		// Section/paragrafo performata
		String idProcedurePerformed = "";				// Nome section da eseguire
		
		// Label di inizio e fine procedura interna
        String labelFrom = "";							// Label di inizio
        String labelTo = "";							// Indica anche la label di thru
        
        // Numero istruzione di inizio e fine procedura
		int instrFrom = 0;								// Section o label di inizio
		int instrTo = 0;								// Label di fine
		
		// Tipo procedura interna
		boolean isPerformToSection = false;				// true indica perform a  Section Cobol
		boolean isPerformToSectionThruLabel = false;	// true indica perform a  Section Cobol thru label
		boolean isPerformToLabelThruLabel = false;		// true indica perform a  label thru label-thru
		boolean isPerformToLabel = false;				// true indica perform a  label  
	}

	/*
	 * 
	 * Descrive le informazioni per l'aggiornamento della lunghezza dei campi di gruppo.
	 * Utilizzata anche per il calcolo della posizione di ogni campo
	 */
	private class InnerGroupSize {
		
		 // Per calcolo lunghezza campi
		 int i = 0;				        // Pointer a campo correntemente sotto analisi
		 int iStartLvl01 = 0;           // Pointer a campo definizione livello 01
		 int iEndLvl01 = 0;             // Pointer a campo ultima definizione livello 01
		 
		 // Per calcolo posizione campi
		 int iPosStart = 0;             // Pointer a campo da cui iniziare   a calcolare la posizione
		 int iPosEnd = 0;               // Pointer a campo con cui terminare a calcolare la posizione
		 int curPosField = 0;           // Posizione corrrente campo 0-based
	}

	/*
	 * Descrive informazioni necessarie durante l'individuazione delle violazioni.
	 */
	 @SuppressWarnings("unused")
	private class InnerViolationDetecting {
		
		 String procInternalName = "";			// Nome section o paragrafo richiamato con perform
		 int numInstrStart = 0;					// Numero istruzione di inizio  
		 int numInstrEnd = 0;           		// Numero istruzione di fine  
		 int numInstrStartInnerPerform = 0;		// Numero istruzione di inizio  
		 int numInstrEndInnerPerform = 0;       // Numero istruzione di fine  
		 int cntViolations = 0;       			// Numero violazioni in setction/paragrafo
		 boolean isSection = false;				// true indica section, false paragrafo
		 boolean isLoopPerformed = false;	    // true indica perform a section/paragrafo con VARYING/UNTIL condition
		 boolean isInnerPerform = false;		// true indica Perform inner, le istruzioni successive sono dentro un loop fino a end-perform
	}

	/*
	 * Descrive informazioni a fronte di recupero copy sorgente
	 */
	 @SuppressWarnings("unused")
	private class InnerGetSource {
		
		 String copyPathAcquired = "";		      // Path completo già composto dove il copy/pgm è stato trovato
		 EntityObject objectSourceMember  = null; // Object da LIBRARY_SCAN 
	}

}
